
-----------------------------------------------------------------------
1 bit_set - set bit in array
-----------------------------------------------------------------------
 INPUTS
    eax = bit number, zero based
          eax(0) sets bit 1 (00000001h)
          eax(32) sets first bit of second dword in array
    edi = array pointer
 OUTPUT
    bit set in array
    eax,edx modified
 NOTES
    file bit_set.asm
    note: see bit_test, blk_clear, wait_event

-----------------------------------------------------------------------
2 bit_set_list - set bits in array
-----------------------------------------------------------------------
 INPUTS
    esi = pointer to list of dword bit values
          0 = bit 1 or 00000001h
          -1 = end of list
          values in increasing order
    edi = array pointer
 OUTPUT
    bits set in array
    esi moved to end of list, beyond -1 entry
 NOTES
    file bit_set_list.asm
    note: see bit_test, blk_clear, wait_event

-----------------------------------------------------------------------
3 bit_test - test array of bits
-----------------------------------------------------------------------
 INPUTS
    eax = bit number
          (0=bit 1) or 00000001h
    edi = bit array pointer
 OUTPUT
    carry = bit set
    no-carry = bit cleared
    registers unchanged
 NOTES
    file bit_test.asm
    note: see bit_set_list, blk_clear, wait_event

-----------------------------------------------------------------------
4 blk_bmove - move large block bytes
-----------------------------------------------------------------------
 INPUTS    esi = ptr to source block
           edi = ptr to destination buffer
           ecx = number of bytes to move

 OUTPUT    esi - points to end of input block
           edi - points to end of output block
           ecx - zero   

 NOTES:  Source file is blk_move.asm
         Block moves will be faster if data is
         dword aligned.  Put "align 4" on segments
         and on buffers
         If input esi and edi are dword aligned, a
         faster move will occur.

-----------------------------------------------------------------------
5 blk_clear - clear array of bytes
-----------------------------------------------------------------------
 INPUTS
    ecx = size of array (byte count)
    edi = array pointer
    the CLD flag is set
 OUTPUT
    ecx = 0
    edi = unchanged
 NOTES
    file blk_clear.asm
    note: see bit_set_list, bit_test, wait_event

-----------------------------------------------------------------------
6 blk_del_bytes - delete area from block of data
-----------------------------------------------------------------------
    The freeded area at end of block is not cleared.
 INPUTS
    eax = number of bytes to delete
    edi = ptr to top of delete area
    ebp = end of data area.
 OUTPUT
    ebp = adusted file end ptr
 NOTES
    all registers destroyed
    file blk_pkg.asm
   The function blk_fdel_bytes is prefered over
   blk_del_hole.  Older function is being
   depreciated

-----------------------------------------------------------------------
7 blk_dmove - move large block of dwords
-----------------------------------------------------------------------
 INPUTS    esi = ptr to source block
           edi = ptr to destination buffer
           ecx = number of dwords to move

 OUTPUT    esi - points to end of input block
           edi - points to end of output block
           ecx - zero   

 NOTES:  Source file is blk_move.asm
         Block moves will be faster if data is
         dword aligned.  Put "align 4" on segments
         and on buffers
         If input esi and edi are dword aligned, a
         faster move will occur.

-----------------------------------------------------------------------
8 blk_fdel_bytes - delete area from block of data
-----------------------------------------------------------------------
    After deletion the block will be decreased in
    size.  Freeded area will be filled with zeros.
 INPUTS
    eax = number of bytes to delete
    edi = ptr to top of delete area
    ebp = end of data block
 OUTPUT
    ebp = adusted data block end ptr
 NOTES
    file blk_fill_pkg.asm
    

-----------------------------------------------------------------------
9 blk_find - search block of text for string
-----------------------------------------------------------------------
 INPUTS
    ebp    end of file ptr(fwd search)  start of file(backwards search)
    esi    match string
    edi    search start ptr in buffer
    edx    scan_direction +1 for forward -1 for reverse find
    ch     case mask df=ignore case, ff=match case
 OUTPUT
    ebx         match pointer if no carry (jnc match_found)
    clobbered   ecx,eax,esi
 NOTES
    The match string ends with zero and the buffer/block
    end is put in register ebp if needed (forward search)

-----------------------------------------------------------------------
10 blk_finsert_bytes - insert data into block
-----------------------------------------------------------------------
 INPUTS
    edi = insert point
    ebp = block end ptr (beyond end of valid data)
          this is not end of buffer, just data end.
    eax = lenght of insert string
    esi = address of string to insert
 OUTPUT
    ebp = adjusted block end ptr
 NOTES
   file: blk_fill_pkg.asm
   It is callers responsibility to check if buffer
   is big enought to hold increased data size after
   insert.

-----------------------------------------------------------------------
11 blk_fmake_hole - make hole and fill with zeros
-----------------------------------------------------------------------
    Create a hole in block of data and fill with
    zeroed bytes.
 INPUTS
    edi = hole creation point (address)
    ebp = file end address (beyond last valid byte)
    eax = size of hole (number of bytes to insert)
 OUTPUT
    ebp = adjusted file end ptr 
 NOTES
    file: blk_fill_pkg.asm
    hole is filled with zero bytes

-----------------------------------------------------------------------
12 blk_freplace - replace first match in buffer
-----------------------------------------------------------------------
    Freeded areas are zeroed
 INPUTS
    eax = ptr to replacement string
    ch  = search case mask, dfh=ignore 0ffh=use case
    esi = match string ptr
    edi = buffer search startng point
    ebp = eof (end of data in buffer)
 OUTPUT
    carry flag set if no replacement occured
    ebp = adusted file end ptr if any replaces occured
    edi = ptr to end of inserted string
 NOTES
   all registers are destroyed
   file blk_freplace.asm

-----------------------------------------------------------------------
13 blk_freplace_all - replace all matches in buffer
-----------------------------------------------------------------------
    freed area is zeroed
 INPUTS
    eax = ptr to replacement string
    ch  = search case mask, dfh=ignore 0ffh=use case
    esi = match string ptr
    edi = buffer search startng point
    ebp = eof (end of data in buffer)
 OUTPUT
    ebp = adusted file end ptr if any replaces occured
    edi = ptr to end of inserted string
 NOTES
    all registers destroyed
    file blk_freplace.asm

-----------------------------------------------------------------------
14 blk_insert_bytes - insert data into block
-----------------------------------------------------------------------
    The character beyond block end will be
    propagated and at end of expanded block.
 INPUTS
    edi = insert point
    ebp = block end ptr (not end of buffer)
    eax = lenght of insert string
    esi = string to insert
 OUTPUT
    ebp = adjusted block end ptr
 NOTES
   file blk_pkg.asm
   The function blk_finsert_bytes is prefered over
   blk_insert_bytes.  Older function is being
   depreciated

-----------------------------------------------------------------------
15 blk_make_hole - make hole in data block for insert
-----------------------------------------------------------------------
    The created hole is not cleared, and end character
    beyond end of block is propagated.
 INPUTS
    edi = insert point (address)
    ebp = end of data (not end of buffer)
    eax = number of characters to insert
 OUTPUT
    ebp = adjust data block end ptr 
 NOTES
    all registers destroyed
    file blk_pkg.asm
   The function blk_fmake_hole is prefered over
   blk_make_hole.  Older function is being
   depreciated

-----------------------------------------------------------------------
16 blk_move - move block of data
-----------------------------------------------------------------------
 INPUTS
    eax = move length
    esi = from address
    edi = to address
 OUTPUT
    edi - unchanged
 NOTES
    file blk_pkg.asm
    see also, str_move

-----------------------------------------------------------------------
17 blk_replace - replace first match in buffer
-----------------------------------------------------------------------
 INPUTS
    eax = ptr to replacement string
    ch  = search case mask, dfh=ignore 0ffh=use case
    esi = match string ptr
    edi = buffer search startng point
    ebp = eof (end of data in buffer)
 OUTPUT
    carry flag set if no replacement occured
    ebp = adusted file end ptr if any replaces occured
    edi = ptr to end of inserted string
 NOTES
   all registers are destroyed
   file blk_replace.asm
   This function is being depreciated, use
   blk_freplace instead.

-----------------------------------------------------------------------
18 blk_replace_all - replace all matches in buffer
-----------------------------------------------------------------------
 INPUTS
    eax = ptr to replacement string
    ch  = search case mask, dfh=ignore 0ffh=use case
    esi = match string ptr
    edi = buffer search startng point
    ebp = eof (end of data in buffer)
 OUTPUT
    ebp = adusted file end ptr if any replaces occured
    edi = ptr to end of inserted string
 NOTES
    all registers destroyed
    file blk_replace.asm
   This function is being depreciated, use
   blk_freplace_all instead.

-----------------------------------------------------------------------
19 blk_replace_table - replace strings using table
-----------------------------------------------------------------------
 INPUTS
    ebx = replace table with pairs of asciiz strings.
    example:
      db "find str1",0,   "replacement text1",0
      db "find str2",0,   "replacement text2",0
      db "find_str3",0,   0
      db 0 ;;end of table
    edi = buffer with text
    ebp = file end ptr
    ch = case flag for find str, 0df=ignore case 0ffh=use case
 OUTPUT
    buffer modified
    ebp = adjusted buffer end ptr
 NOTES
   source file: blk_replace_table.asm

-----------------------------------------------------------------------
20 margins - sets margins for paragraph function
-----------------------------------------------------------------------
 INPUTS
  * ah = left margin, 1=left most column
  * al = right margin, (right most column)
 OUTPUT
  * none
 NOTES
  * file: paragraph.asm

-----------------------------------------------------------------------
21 paragraph - formats one paragraph
-----------------------------------------------------------------------
 INPUTS
    esi = pointer inside paragraph somewhere
    edi = start of buffer with all paragraphs
    ebp = end of text data, (all paragraphs)
 OUTPUT
    ebp = new end of text data
    edi = end of reformated paragraph
 NOTES
    file paragraph.asm
    The paragraph function first finds the start and end of
    current text block.  Next, it creates a hole at top to
    place reformated data.  It is critical that text data
    area can expand without overflowing work area.
     
    The start of all text must have a 0ah character infront
    of the buffer.  the end of all text is expected to also
    have a 0ah terminator.

-----------------------------------------------------------------------
22 is_alpha - check if alpha 20h -> 7eh 
-----------------------------------------------------------------------
 INPUTS
    al = ascii char
 OUTPUT
    eq flag set for je if alpha
 NOTES
    source file: /char/is_alpha.asm

-----------------------------------------------------------------------
23 is_number - check if ascii number
-----------------------------------------------------------------------
 INPUTS
   al = ascii char
 OUTPUT
   eq flag set for je if numeric
 NOTES
   file: /char/is_number.asm

-----------------------------------------------------------------------
24 decrypt - move ascii data and decrypt
-----------------------------------------------------------------------
 INPUTS
     ah = key
    esi = ptr to ascii string
    edi - destination for decrypted output string
 OUTPUT:
    esi = ptr to end of input string (past zero byte)
    edi = ptr to end of stored string (past zero byte)
 NOTES
   source file: pak.asm

-----------------------------------------------------------------------
25 encrypt - simple string encryption
-----------------------------------------------------------------------
 INPUTS
    ah = key
    esi = ptr to ascii string
    edi - destination for encrypted string (terminating 0 encrypted)
 OUTPUT:
    esi = ptr to end of input string (past zero byte)
    edi = ptr to end of stored string (past zero byte)
 NOTES
   source file: encrypt.asm
   This routine is not secure, but may be useful for
   casual encription.

-----------------------------------------------------------------------
26 lz_compress - Lempel-Ziv data compressor
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to input data block
    edi = ptr to output buffer
    ebx = length input data block
    edx = ptr to work buffer
    eax = length of work buffer
   
    Output buffer size can be larger than the input
    buffer if the input data is already compressed.
    A safe value for the output buffer is:
   
    (input buffer size) + 64 + ((input buffer size)/8)

    Work buffer size must be also be a mask size as
    follows:  2000h, 4000h, 8000h, 10000h 20000h
              40000h 80000h 100000h 200000h
    
 OUTPUT:
    eax = length of compressed data block if positive
        = zero if input block is zero

    All registers are changed.

    The compressed block has dword at front with origional
    size of block before compression.  This is followed
    by compressed data.  If the input block has zero
    length, no  output block is created.

 NOTES
   source file: lz_compress.asm

   The compressor/decompressor performs as follows
   when processing a 753246 byte text file:

   Compressor   code  compress   compressed 
   name         size  time       data size
   ---------    ----  -----      ----------
   lz_compress  770   019ms        82759
   pak          089   027ms       461191
   gzip         big   044ms       135571


-----------------------------------------------------------------------
27 lz_decompress - Lempel-Ziv data uncompressor
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to input data block
          created by lz_compress
    edi = ptr to output buffer
   
    Output buffer size can be found in first dword
    of input block from lz_compress.
   
 OUTPUT:
    eax = length of decompressed data block

    All registers are changed.

    The compressed block has dword at front with origional
    size of block before compression.  This is followed
    by compressed data.

 NOTES
   source file: lz_decompress.asm

   The compressor/decompressor perform as follows
   when processing a 753246 length text file:

   deCompressor  code  decompress
   name          size  time      
   ---------     ----  -----     
   lz_decompress 146   014ms     
   upak          070   018ms     
   gzip          big   009ms     


-----------------------------------------------------------------------
28 pak - move ascii data and compress
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to ascii string
    ebx - destination for packed output string
 OUTPUT:
    esi = ptr to end of input string (past zero)
    ebx = ptr to end of stored string (past zero)
 NOTES
   source file: pak.asm
   pak uses a simple algrothm that works
   best if ascii strings have a lot of repeated
   characters in a row.  For ascii strings without
   repeats it can achieve 20-30 percent
   compression.  It is mostly used for speed
   and its ability to compress data as it
   copies.

-----------------------------------------------------------------------
29 upak - move ascii data and uncompress
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to ascii string
    edi - destination for unpacked output string
 OUTPUT:
    esi = ptr to end of input string (past zero byte)
    edi = ptr to end of stored string (past zero byte)
 NOTES
   source file: pak.asm

-----------------------------------------------------------------------
30 color_cursor - place a colored cursor on the screen
-----------------------------------------------------------------------
 INPUTS
     eax = cursor color 
     bh = row
     bl = column
     ecx = ptr to data under cursor (display char)
 OUTPUT
     solid character displayed
 NOTES
    source file crt_screen.asm
    data under cursor is expected to be normal ascii

-----------------------------------------------------------------------
31 crt_char_at - display one colored char at location.
-----------------------------------------------------------------------
 INPUTS
     eax = color (aa??ffbb) attribute,foreground,background
     bl = column
     bh = row
     cl = ascii char
 OUTPUT
    one colored character displayed
 NOTES
    file crt_char

-----------------------------------------------------------------------
32 crt_clear - clear the screen
-----------------------------------------------------------------------
 INPUTS
    eax = screen color
 OUTPUT
    screen is cleared
 NOTES
    file crt_vertical.asm
    see function crt_set_color for color info

-----------------------------------------------------------------------
33 crt_close
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    none
 NOTES
    This program is obsolete, see crt_open
;    file: crt_setup.asm
    Call this function if crt_open was called previously.  Normally
    this function is called before exiting the program.

-----------------------------------------------------------------------
34 crt_color_at - move cursor and display colored line
-----------------------------------------------------------------------
 INPUTS
    eax = color (aa??ffbb) attribute,foreground,background
    bl = column
    bh = row
    ecx = message ptr (asciiz)
 OUTPUT
    colored message string displayed
 NOTES
    file crt_color.asm

-----------------------------------------------------------------------
35 crt_horizontal - repeat display character 
-----------------------------------------------------------------------
 INPUTS
    bl = character to repeat at cursor position
    eax = color, see (mov_color) for format of color
    ecx = number of times to display character
    lib_buf is used to build display line
 OUTPUT
   eax = negative system error# or positive if success
 NOTES
    source file crt_horizontal.asm
    The current window width is not checked, crt_horizontal
    will attempth display even if window size too small. 

-----------------------------------------------------------------------
36 crt_line - display line with embedded color codes
-----------------------------------------------------------------------
     and fit line into window area
 INPUTS
    ebx = ptr to color list, each color def is dword
    ch = starting row 1+
    cl = starting column 1+
    dl = max line length, must be 1+
    esi = ptr to data for line, each line end with 0ah, or 0
      color codes start at 1 (first color in table)
      color codes 1-9 are possible.
    edi = scroll counter
 OUTPUT
    line is built in buffer lib_buf then displayed
    esi - points at char beyond 0ah
 NOTES
   source file: crt_line.asm

-----------------------------------------------------------------------
37 crt_open - get crt parameters and setup termios
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    [crt_rows] - global variable (byte) with row count
    [crt_columns] - global variable (byte) with collumn count
 NOTES
    This program is obsolete.  It puts terminal in raw mode
    and newer library calls do not need terminal in raw mode.
;    source file: crt_setup.asm
    Call crt_open if interactive terminal programs are utilized.
    This function provides information about window size and
    and disables default keyboard handling.  It allows individual
    keys to be processed without waiting for user to type a <return>.

-----------------------------------------------------------------------
38 crt_set_color - set color mode for display
-----------------------------------------------------------------------
 INPUTS
    eax = color code
    eax = aaxxffbb  aa-attr ff-foreground  bb-background
    30-blk 31-red 32-grn 33-brwn 34-blu 35-purple 36-cyan 37-gry
    attributes 30-normal 31-bold 34-underscore 37-inverse
 OUTPUT
    vt100 color string sent to display
 NOTES
    source file crt_color.asm
    This function sends vt100 color command to crt

-----------------------------------------------------------------------
39 crt_str - display asciiz string at curent cursor position
-----------------------------------------------------------------------
 INPUTS
    ecx = ptr to string
 OUTPUT
   uses current color, see crt_set_color, crt_clear
 NOTES
   source  file crt_str.asm

-----------------------------------------------------------------------
40 crt_table - display screen of data using table
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to table data
    [win_rows] - global variable set by crt_open
    [left_column] - global dword for scroll right-left, set by caller
    [lib_buf] - temp buffer used internaly
    colors described below are contained in file lib_data.asm and
      can be modified.
 OUTPUT
 
 NOTES
   file crt_table.asm
   Tables contain a mix of color information, line information, and
   negative codes indicating the process for ajacent data.  If a
   mouse click occurs on the screen, the table can be scaned for
   a negative number that signals the process to run.
   The caller can change colors as user clicks on various areas.
   The a_todo program edit mode uses this function.
    
   codes:  0 - end of table
           1 - normal color
           2 - edit/select field color
           3 - active edit/select field color
           4 - button color color
           5 - blank all rows from here to [window_rows]
           9 - add blanks to end of line, init for next line
          -x - process code for mouse clicks
    
   sample table --------------------
    
   db -67	;trap to catch clicks at upper left corner of screen
   edit_table:
   db 1,'  ',-73,4,'Previous(PgUp)',1,'  '
   db -74,4,'Next(PgDn)',1,'  ',-65,4,'Delete(F8)',1,'  '
   db -67,4,'Abort edits(F9)',1,'  ',-66,4,'Done(F10)',1,9
   db 1,9
   db 1,'todo state:   ',-1,2
   pending
   db 'Pending',1,'   ',-2,2
   completed
   db 'completed',1,'   ',-3,2
   deleted
   db 'deleted',1,9
   db 1,9
   db	1,9
   db 5
   db 0
   edit_table_end

     see also: crt_table_loc, cursor_to_table

-----------------------------------------------------------------------
41 crt_table_loc - use table ptr to find crt row/col
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to top of table
    edi = ptr any location inside table
 OUTPUT
    ah = row
    al = column
 NOTES
    source file crt_table.asm
    see also: crt_table, cursor_to_table

-----------------------------------------------------------------------
42 crt_vbar - display vertical bar lenght of window
-----------------------------------------------------------------------
 INPUTS
    [crt_columns] - set by crt_open
    [crt_rows] - set by crt_open
 OUTPUT
    vertical bar displayed on screen,
 NOTES
    source file crt_vertical.asm
    call crt_set_color to set bar color

-----------------------------------------------------------------------
43 crt_vertical - repeat char vertically
-----------------------------------------------------------------------
 INPUTS
     al = column (ascii)
     ah = row (ascii)
     bl = char
     bh = repeat count
 OUTPUT
    display character in vertical column
 NOTES
    source file crt_vertical.asm

-----------------------------------------------------------------------
44 crt_win_from_ptrs - display window using ptrs to lines
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to color table
    ch  = starting row
    cl  = starting col
    dl = number of cols
    dh = number of rows
    ebp = ptr to list of line ptrs
    edi = adjustment to pointers in pointer list (ebp).
          negative number ok, display starts at [ptr + edi]       
    each line terminated with 0ah or 0
    codes 1-9 found in line are color info.
 OUTPUT

 NOTES
   source file: crt_ptr_window.asm

-----------------------------------------------------------------------
45 crt_window - display one window/page of data
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to information block as follows
          dword - color for page
          dword - display data ptr
          dword - end of all display data, (not end of this page)
                  points at 0ah char beyond last data item.
          dword - scroll count, 0=left edge not scrolled
          byte  - total window columns 1+
          byte  - total window rows 1+
          byte  - starting row 1+
          byte  - starting column 1+
 OUTPUT
    none
 NOTES
    source file crt_window.asm
    buffer lib_buf is used to build each line displayed.
    This buffer is a temp buffer available for general use.
    lib_buf is 600 bytes long.

-----------------------------------------------------------------------
46 crt_window2 - display window with embedded color
-----------------------------------------------------------------------
    codes, window size is input.
 INPUTS
    ebx = ptr to color list, each color def is dword
    ch = starting row 1+
    cl = starting column 1+
    dl = max line length, must be 1+
    dh = row count 1+
    esi = ptr to data for line
      color codes start at 1 (first color in table)
      color codes 1-9 are possible.
      number of lines must equal or greater than size
      of window.
 PROCESSING:
    crt_window2 is given a buffer with lines of text.
    Each line ends with 0ah.  The lines are displayed
    by calling crt_line.
   
 OUTPUT
    window displayed
 NOTES
   source file:  crt_window2.asm

-----------------------------------------------------------------------
47 crt_write - display block of data
-----------------------------------------------------------------------
 INPUTS
    ecx = ptr to data
    edx = length of block
 OUTPUT
   uses current color, see crt_set_color, crt_clear
 NOTES
   source  file crt_str.asm

-----------------------------------------------------------------------
48 cursor_hide - hide the cursor
-----------------------------------------------------------------------
   inputs:
      none
   outputs:
      none, register ecx modified
   operation:
      call vt-100 control sequence ESC "[?25l" to hide cursor
   note:
      source file: crt_cursor.asm          

-----------------------------------------------------------------------
49 cursor_to_table - find table location from cursor row/col
-----------------------------------------------------------------------
 INPUTS
     esi = ptr to top of table
     cl = target column
     ch = target row 
 OUTPUT
     esi = table pointer for target row/column
 NOTES
    file crt_table.asm
    see also: crt_table, crt_table_loc

-----------------------------------------------------------------------
50 cursor_unhide - unhide the cursor
-----------------------------------------------------------------------
   inputs:
      none
   outputs:
      none, register ecx modified
   operation:
      call vt-100 control sequence ESC "[?25h" to unhide cursor
   note:
      source file: crt_cursor.asm          
          

-----------------------------------------------------------------------
51 mov_color - copy vt100 string to buffer
-----------------------------------------------------------------------
 INPUTS
    eax = color code
    eax = aaxxffbb aa-attr ff-foreground  bb-background
    30-blk 31-red 32-grn 33-brn 34-blu 35-purple 36-cyan 37-gry
    attributes 30-normal 31-bold 34-underscore 37-inverse
    edi = location to copy color string
 OUTPUT
    string is copied, edi points to zero at end of string
    register esi is preserved
 NOTES
    file crt_color.asm
    This function copies and asciiz string (including the zero)

-----------------------------------------------------------------------
52 move_cursor - move cursor
-----------------------------------------------------------------------
 INPUTS
     al = column (1-xx)
     ah = row    (1-xx)
 OUTPUT
    cursor placed on screen
 NOTES
    source file crt_move.asm
    This function moves the cursor by sending vt100
    escape commands to crt.

-----------------------------------------------------------------------
53 reset_clear_terminal - terminal soft reset plus clear
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
   none
 NOTES
    source file reset_soft.asm

-----------------------------------------------------------------------
54 reset_soft - terminal soft reset
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
   none
 NOTES
    source file reset_soft.asm

-----------------------------------------------------------------------
55 reset_terminal - output vt-100 setup strings
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
   none
 NOTES
    source file reset_terminal.asm

-----------------------------------------------------------------------
56 restore_cursor - restore cursor position
-----------------------------------------------------------------------
 INPUTS
    [saved_cursor] - global string with cursor info
      format is: db 1bh ;escape char
                 db '['
                 db '1' ;ascii row, 1 or 2 digits
                 db ';' ;separator
                 db '1' ;ascii column, 1 or 2 digits
                 db 'H' ;end code (set by restore_cursor)
                 db  0  ;string end
 OUTPUT
    none
 NOTES
    source file save_restore_cursor.asm

-----------------------------------------------------------------------
57 save_cursor - save current cursor position
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    [saved_cursor] - global string with cursor info
    see restore_cursor for format
 NOTES
    source file save_restore_cursor.asm

-----------------------------------------------------------------------
58 database_close - close currently active database
-----------------------------------------------------------------------
 INPUTS
    none
         
 OUTPUT
    eax = program status:
          positive indicates file written to disk
          negative values = error return codes.
                            -1=a database isn't open
          sign bit is set for js/jns instructions
    ebp points to work buffer, first entry is the
          'db' structure as follows:
        struc db
         .db_records resd 1 ;pointer to record area
         .db_index resd 1 ;pointer to index area
         .db_index_end resd 1 ;pointer to zero at end of index
                                can expand to db_append
         .db_append resd 1 ;pointer to appended record area
         .db_append_end  resd 1 ;pointer to start of free space.
         .db_path resb 200 ;copy of file path
         .db_separation resb 4 ;size followed by separation string
         .db_end  resd 6 ;copy of record separator codes,
                                first byte is length of codes.
        endstruc
          
 OPERATION
    The records are written to disk is same order they
    appear in index.

 NOTES
    source file: database_close.asm
    related functions: database_close, database_extract
                       database_insert, database_search
                     

-----------------------------------------------------------------------
59 database_copy_record - copy record to buffer
-----------------------------------------------------------------------
 INPUTS
    edi = storage point for new record
    eax = pointer to index entry for record to copy
         
 OUTPUT
    eax = size of record copied
        = negative if error, -1=database not open
    ebp = ptr to database structure
          
 NOTES
    source file: database_extract.asm
    related functions: database_close, database_extract
                       database_open, database_search
                     

-----------------------------------------------------------------------
60 database_extract - extract record (cut) and save copy
-----------------------------------------------------------------------
 INPUTS
    edi = storage point for new record or zero to delete
    eax = pointer to index entry for record to extract
         
 OUTPUT
    eax = size of record extracted or zero if delete
        = negative if error, -1=database not open
    ebp = ptr to database structure
          
 OPERATION
    record is copied or deleted.
    added.  The index list is updated.

 NOTES
    source file: database_extract.asm
    related functions: database_close, database_extract
                       database_open, database_search
                     

-----------------------------------------------------------------------
61 database_insert - insert record into open database
-----------------------------------------------------------------------
 INPUTS
    esi = pointer to record
    ecx = size of record without separation characters
          used in database, we will append separation chars.
    al=0 to  append, al=1 to  insert alphabetically.
         
 OUTPUT
    eax = positive if success
          negative if error, -1=no database active
          sign bit is set for js/jns instructions.
    ebp = ptr to database structure
          
 OPERATION
    record is copied to database and separation characters
    added.  The index list is updated.

 NOTES
    source file: database_insert.asm
    related functions: database_close, database_extract
                       database_open, database_search
                     

-----------------------------------------------------------------------
62 database_open - open or create a database file
-----------------------------------------------------------------------
    The database remains in memory until the
    database_close function is called.  While in
    memory the database insert, extract, search,
    etc. functions can be used.

 INPUTS
    esi = pointer to database path string.
          Path string is terminated by zero byte.
    edi = pointer to record separator string.
          The first byte is size of string.
          The max size is 4 bytes including size.
    ebp = pointer to work buffer.  Size must be
          large enough to hold database file, 
          index list, some record keeping, and 
          appended records.  Size is not checked,
          but after "database_open" the 'db' structure
          has sufficient information to do a error
          check.
         
 OUTPUT
    eax = program status:
          zero indicates the work buffer is setup
          negative values = error return codes.
                            -1=a database is open already
          sign bit is set for js/jns         
    ebp points to work buffer, first entry is the
          'db' structure as follows:
        struc db
         .db_records resd 1 ;pointer to record area
         .db_index resd 1 ;pointer to index area
         .db_index_end resd 1 ;pointer to zero at end of index
                                can expand to db_append
         .db_append resd 1 ;pointer to appended record area
         .db_append_end  resd 1 ;pointer to start of free space.
         .db_path resb 200 ;copy of file path
         .db_separation resb 4 ;size followed by separation string
         .db_end  resd 6 ;copy of record separator codes,
                                first byte is length of codes.
        endstruc
          
 OPERATION
    The database function is suitable for small lists
    which need to be updated easily and then stored in
    a file.
    Records are separated by a unique code which can
    not appear with the data itself.  The code is
    determined by caller.
    Initially, records are read and indexed by a
    list of pointers to the records.  The pointers
    can be sorted by caller or the "insert" function
    has an option to insert alphabetically.
    The format of each record is determined by the
    caller, but sorted databases may want the
    sort field first.    
 NOTES
    source file: database_open.asm
    related functions: database_close, database_extract
                       database_insert, database_search
                     

-----------------------------------------------------------------------
63 database_record_size - compute size of record in database
-----------------------------------------------------------------------
 INPUTS
    edi = ptr to index entry for target record
    ebp = database structure pointer
         
 OUTPUT
    edx = size of record
    ebx,ebp unchanged
          
 NOTES
    source file: database_record_size.asm
    related functions: database_close, database_extract
                       database_open, database_search
                     

-----------------------------------------------------------------------
64 database_search - scan the database for string
-----------------------------------------------------------------------
 INPUTS
    edi = ptr to index entry for start of search
          or if eax=0 start search at top of index.
    esi = search string in asciiz format.
         
 OUTPUT
    eax = -1 if no database active
          -2 if no match
           0 if success
          sign bit is set for js/jns jump
    edi = ptr to index entry with match
    ebp = ptr to database structure
          
 NOTES
    source file: database_search.asm
    related functions: database_close, database_extract
                       database_open, database_search
                     

-----------------------------------------------------------------------
65 ascii2days - convert ascii year,month,day to days since 1970
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to ascii string "YYYYMMDD"
 OUTPUT
    eax = binary days since 1970
 NOTES
   source file: ascii2days.asm

-----------------------------------------------------------------------
66 ascii2regs - convert ascii year,month,day to bin year,month,day
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to ascii string "yyymmdd" without separators
 OUTPUT
    edx = binary year
    ah = binary month 1-12
    al = binary day of month 1-31
 NOTES
   source file: ascii2regs.asm

-----------------------------------------------------------------------
67 bins2ascii - format date
-----------------------------------------------------------------------
  input: ebx = time/date data structure pointer
         ebp = format string pointer
         edi = output buffer pointer
  output: edi - points at end of output string
          ebp - points at end of format string
 
    the format string contains two types of data.  Numeric
    codes "0123456789" and non-numberic ascii characters.
    Non-numberic characters are passed to the output and
    not modified.  Any numberic character found is processed
    as follows:
      0  -stuff ascii year
      1  -stuff ascii month
      2  -stuff ascii day of month
      3  -stuff ascii hour
      4  -stuff ascii minute
      5  -stuff ascii second
      6- -stuff short month name
      6+ -stuff long month name
      7- -stuff short day of week name
      7+ -stuff long day of week name
      8  -stuff AM/PM
      9  -stuff 3 letter zone code

-----------------------------------------------------------------------
68 day_name - lookup name for day
-----------------------------------------------------------------------
 INPUTS
    ecx = day code, 0=sun 1=mons etc.
 OUTPUT
    esi = pointer to full asciiz name.
    
 NOTES
   source file: day_name.asm

-----------------------------------------------------------------------
69 days2ascii - convert days to week,day,month, etc.
-----------------------------------------------------------------------
 INPUTS
    eax = days since jan 1 1970
    ebx = buffer for ascii output
    ebp = format template for ascii output
    the format string contains two types of data.  Numeric
    codes "0123456789" and non-numberic ascii characters.
    Non-numberic characters are passed to the output and
    not modified.  Any numberic character found is processed
    as follows:
      0  -stuff ascii year
      1  -stuff ascii month
      2  -stuff ascii day of month
      6- -stuff short month name
      6+ -stuff long month name
      7- -stuff short day of week name
      7+ -stuff long day of week name
 OUTPUT
          edi - points at end of output string
          ebp - points at end of format string
  Note: the termporary library buffer "lib_buf" is utilized.
    
 NOTES
    source file: days2ascii.asm

-----------------------------------------------------------------------
70 days2dateregs - convert days to week,day,month, etc.
-----------------------------------------------------------------------
 INPUTS
    eax = days since jan 1 1970
 OUTPUT
    eax days_since_1970 - total days since 1970
    dh  [day_of_week] - 0=wednesday 1=thursday...-> 0=sunday
    ebx year - current year
    dl  day_of_month - 1 based
    esi month_number - 1 based
 NOTES
   source file: days2dateregs.asm

-----------------------------------------------------------------------
71 days_in_month - returns number of days in month
-----------------------------------------------------------------------
 INPUTS
    bl = binary month number, 1=january
    edx = binary year
 OUTPUT
    bl =  number of days in month
 NOTES
   source file: days_in_month.asm

-----------------------------------------------------------------------
72 get_raw_time - get raw time from kernel
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    eax - raw seconds since Jan 1 1970
    ebx - raw microseconds
 NOTES
   source file: get_raw_time.asm
    
   see date_get function before using this function.

-----------------------------------------------------------------------
73 leap_check - check for leap year
-----------------------------------------------------------------------
 INPUTS
    eax = binary year
 OUTPUT
    carry set if leap year
    eax - modified
 NOTES
   source file: leap_check.asm

-----------------------------------------------------------------------
74 leap_count - count leap years from 1970 till target
-----------------------------------------------------------------------
 INPUTS
    eax = binary year (target)
 OUTPUT
    eax = leap years between 1970 and target, excluding target
 NOTES
   source file: leap_count.asm
   note: the input year is not included in totals
         it is assumed date is jan 1 and leap has
         not occured yet.

-----------------------------------------------------------------------
75 month_name - lookup name for month
-----------------------------------------------------------------------
 INPUTS
    ecx = month code, 1=january 2= feb etc.
 OUTPUT
    esi = pointer to full asciiz name.
 NOTES
   source file: month_name.asm

-----------------------------------------------------------------------
76 raw2ascii - apply zone adjustment to raw system time
-----------------------------------------------------------------------
 INPUTS
    eax = raw system time from get_raw_time or file status
    edi = destination for ascii
    ebx = format string for ascii output, terminated by zero byte.
    the format string contains two types of data.  Numeric
    codes "0123456789" and non-numberic ascii characters.
    Non-numberic characters are passed to the output and
    not modified.  Any numberic character found is processed
    as follows:
      0  -stuff ascii year
      1  -stuff ascii month
      2  -stuff ascii day of month
      3  -stuff ascii hour
      4  -stuff ascii minute
      5  -stuff ascii second
      6- -stuff short month name
      6+ -stuff long month name
      7- -stuff short day of week name
      7+ -stuff long day of week name
      8  -stuff AM/PM
      9  -stuff 3 letter zone code
    example:  db "0-1-2 3:4:5",0  displays year-month-day hour:minute:sec
 OUTPUT
    ebx - points to time struc (in temporary lib buffer lib_buf)
      struc time
       .ct:		resd	1	; raw C time (seconds since the Epoch)
       .at:		resd	1	; zone adjusted seconds since last Epoch
       .zo:		resd	1	; time zone offset
       .zi:		resb	6	; time zone identifier
       .tz:		resb	10	; time zone name
       .dc:		resd	1	; days since last Epoch
       .sc:		resd	1	; seconds
       .mn:		resd	1	; minutes
      .hr:		resd	1	; hours
      .yr:		resd	1	; year
      .mr:		resd	1	; meridian (0 for AM)
      .wd:		resd	1	; day of the week (Sunday=0, Saturday=6)
      .dy:		resd	1	; day of the month
      .mo:		resd	1	; month (one-based)
    edi - points to end of stored ascii string
    ebp - points to end of format string
    all other registers are not preserved
    the temp library buffer lib_buf has time structure
 NOTES
   source file: raw2ascii.asm
   UNIX system time and file times need to be adjusted by local zone.

-----------------------------------------------------------------------
77 raw2seconds - apply zone adjustment to raw system time
-----------------------------------------------------------------------
 INPUTS
    eax = raw system time from get_raw_time
    edi = pointer to short form of time structure
      struc time
       .ct:		resd	1	; raw C time (seconds since the Epoch)
       .at:		resd	1	; zone adjusted seconds since last Epoch
       .zo:		resd	1	; time zone offset
       .zi:		resb	6	; time zone identifier
       .tz:		resb	10	; time zone name
 OUTPUT
    eax - seconds since Jan 1 1970 adjusted for zone
    also, fields .ct through .tz are filled out if zone data found.
    if zone not found, only .ct .at .zo and .zi are filled in
 NOTES
   source file: raw2seconds
   UNIX system time and file times need to be adjusted by local zone.

-----------------------------------------------------------------------
78 regs2ascii - format date
-----------------------------------------------------------------------
  input: eax = output buffer for asciiz date string
         ebp = format string pointer (see below)
         ebx = year
          cl = minute
          ch = second
          dl = day of month
          dh = day of week
         esi = month number
         edi = hour
         note: seconds2timeregs,seconds2dateregs can provide
               year,month,day,hour,minute,sec and day of week
  output: edi - points at end of output string
          ebp - points at end of format string
 
    the format string contains two types of data.  Numeric
    codes "0123456789" and non-numberic ascii characters.
    Non-numberic characters are passed to the output and
    not modified.  Any numberic character found is processed
    as follows:
      0  -stuff ascii year
      1  -stuff ascii month
      2  -stuff ascii day of month
      3  -stuff ascii hour
      4  -stuff ascii minute
      5  -stuff ascii second
      6- -stuff short month name
      6+ -stuff long month name
      7- -stuff short day of week name
      7+ -stuff long day of week name
      8  -stuff AM/PM

  Note: the termporary library buffer "lib_buf" is utilized.

-----------------------------------------------------------------------
79 regs2days - convert day,month,year to days since 1970
-----------------------------------------------------------------------
 INPUTS
    edx = binary year 1970-2099
    ah = binary month 1-12
    al = binary day 1-31
 OUTPUT
    eax = days elapsed since Jan 1 1970
 NOTES
   source file: regs2days.asm

-----------------------------------------------------------------------
80 seconds2bins - convert seconds to year,month,day,hr, etc.
-----------------------------------------------------------------------
 INPUTS
         ebp = ptr to time structure, see time.inc
         [ebp + time.at] = adjusted seconds
   
 OUTPUT
    the time structure is filled in as follows:
          [ebp + time.sc current seconds
          [ebp + time.mn current minute
          [ebp + time.hr current hour
          [ebp + time.mr meridian 0=AM
          [ebp + time.dc days since last epoch
          [ebp + time.yr current year
          [ebp + time.dy day of month
          [ebp + time.mo month number, one based 
 NOTES
    source file: seconds2bins.asm

-----------------------------------------------------------------------
81 seconds2dateregs - convert seconds to week,day,month, etc.
-----------------------------------------------------------------------
 INPUTS
    eax = seconds since jan 1 1970 
 OUTPUT
    eax days_since_1970 - total days since 1970
    dh  [day_of_week] - 0=wednesday 1=thursday...-> 0=sunday
    ebx year - current year
    dl  day_of_month - 1 based
    esi month_number - 1 based
    register ecx is restored 
 NOTES
   source file: seconds2dateregs.asm
    
   see also date_get

-----------------------------------------------------------------------
82 seconds2timeregs - seconds to hour,min,sec registers 
-----------------------------------------------------------------------
 INPUTS
    eax = seconds since Jan 1 1970
 OUTPUT
    eax = seconds since Jan 1 1970
    edi - dword binary hour
    cl  - dword binary minute
    ch  - dword binary seconds
 NOTES
   source file: seconds2timeregs.asm

-----------------------------------------------------------------------
83 dcache_buf_cursor - set cursor for next write to buffer
-----------------------------------------------------------------------
 INPUT
   ah=row  al=col
 OUTPUT
   eax = index set
 NOTE


-----------------------------------------------------------------------
84 dcache_clear - clear screen buffer
-----------------------------------------------------------------------
 INPUT
   al=color
 OUTPUT
   
 NOTE
   clear only sets display buffer, the function
   dcache_flush must be called to update display

-----------------------------------------------------------------------
85 dcache_color_range - set range of colors
-----------------------------------------------------------------------
 INPUT
   ah=row  al=col
   ch=color cl=length of range
 OUTPUT
   none
 NOTE
   color format.
   aafffbbb  aa-attr fff-foreground  bbb-background
    0-blk 1-red 2-grn 3-brwn 4-blu 5-purple 6-cyan 7-gry
    attributes 0-normal 1-bold 4-underscore 7-inverse

-----------------------------------------------------------------------
86 dcache_flush - write screen buffer to display
-----------------------------------------------------------------------
 INPUT
   none
 OUTPUT
   all image data not on screen is displayed.
 NOTE
   source file = dcache_flush.asm

-----------------------------------------------------------------------
87 dcache_read_char - read range of characters
-----------------------------------------------------------------------
 INPUT
   ah=row  al=col
   ecx=range
   edi=storage adr
 OUTPUT
   eax,ebx,ecx modified
   edi points beyond last char stored.

-----------------------------------------------------------------------
88 dcache_read_color - read color at location
-----------------------------------------------------------------------
 INPUT
   ah=row  al=col
   ecx=range
   edi=storage adr
 OUTPUT
   eax,ebx,ecx,edi modified
   edi points beyond last color char.
 NOTE
   color format.
   aafffbbb  aa-attr fff-foreground  bbb-background
    0-blk 1-red 2-grn 3-brwn 4-blu 5-purple 6-cyan 7-gry
    attributes 0-normal 1-bold 4-underscore 7-inverse

-----------------------------------------------------------------------
89 dcache_read_cursor - read current cursor position for next write
-----------------------------------------------------------------------
 INPUT
   none
 OUTPUT
   ah=row al=col

-----------------------------------------------------------------------
90 dcache_screen_cursor - set buffer cursor and display cursor
-----------------------------------------------------------------------
 INPUT
   al=column 1+  ah=row 1+
 OUTPUT

 NOTE

-----------------------------------------------------------------------
91 dcache_set_all_writes - set write all on next flush
-----------------------------------------------------------------------
 INPUT
   none
 OUTPUT
   none

-----------------------------------------------------------------------
92 dcache_set_color - set color for image write functons
-----------------------------------------------------------------------
 INPUT
   al=color
 OUTPUT
   all register unchanged
 NOTE
   color format.
   aafffbbb  aa-attr fff-foreground  bbb-background
    0-blk 1-red 2-grn 3-brwn 4-blu 5-purple 6-cyan 7-gry
    attributes 0-normal 1-bold 4-underscore 7-inverse

-----------------------------------------------------------------------
93 dcache_setup - setup for cached display
-----------------------------------------------------------------------
 INPUTS
   ;eax = size of buffer, the display size
          must be obtained from dcache_size. A
          larger size allows for resized windows
   ;ebx = buffer pointer for tables
   ;dl = blank screen color code
   ;dh = fd 0=use /dev/tty 1=stdout 2=stderr
    [display_size]
    [dcache_rows]
    [dcache_columns]
 OUTPUT
   ;js if error (buffer too small by neg about in eax)    
 NOTES
    source file: dcache_setup.asm

    The dcache keeps a image of display data and
    only updates the display when dcache_flush is
    called.  It is best to only use dcahe routines
    for display handling, or avoid all dcache functions.

    Typically the dcache is used as follows:
    1. call dcache_size to get suggested buffer size
    2. call dcache_setup with allocated buffer
    3. build windowed display using write calls
    4. after display is built, call dcache_flush.
    5. If display is resized (winch signal) start
       again at step 1.

    Using dcache provides very fast displays and
    provides a easy format to minipulate data.
    Dcache does not work well for non-windowed
    displays (text scrolling)

-----------------------------------------------------------------------
94 dcache_size - compute screen size in chars
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   if no carry
    ebx = screen size
    eax = suggested buffer size
   if carry, can't get tty 
 NOTES
    source file: dcache_size.asm

-----------------------------------------------------------------------
95 dcache_write_block - write block to cache
-----------------------------------------------------------------------
  write block and handle, tabs, line-feeds, truncate
  at edge of screen, stop at zero char or
  last line of screen.

 INPUT
    esi = block ptr
    ecx = block length
    color and cursor location already set

 OUTPUT
    ah=color al=char out
    dh=row   cl=column (next write positon)
    esi=ptr beyond last input char written
    edi=image index
    ebp=top of image buffer

-----------------------------------------------------------------------
96 dcache_write_fblock - write block to cache and fill
-----------------------------------------------------------------------
  same as dcache_write_block, with addition of fill
  from end of block to right edge of display.

 INPUT 
   esi = block ptr
   ecx = block length
   color and cursor location already set

 OUTPUT
   ah=color al=char out
   dh=row   cl=column (next write positon)
   esi=ptr beyond last input char written
   edi=image index
   ebp=top of image buffer

-----------------------------------------------------------------------
97 dcache_write_fline - write line to cache and fill
-----------------------------------------------------------------------
  same as dcache_write_line, with addition of fill
  from end of line to right edge of display.

 INPUT
   esi = line ptr
   color and cursor location already set

 OUTPUT
   ah=color al=char out
   dh=row   cl=column (next write positon)
   esi=ptr beyond last input char written
   edi=image index
   ebp=top of image buffer

-----------------------------------------------------------------------
98 dcache_write_fstring - write string to cache and fill
-----------------------------------------------------------------------
  same as dcache_write_string, with addition of fill
  from end of string to right edge of display.

 INPUT
   esi = string ptr
   color and cursor location already set

 OUTPUT
    ah=color al=char out
    dh=row   cl=column (next write positon)
    esi=ptr beyond last input char written
    edi=image index
    ebp=top of image buffer

-----------------------------------------------------------------------
99 dcache_write_line - write line to cache
-----------------------------------------------------------------------
  write line and handle, tabs, line-feeds, truncate
  at edge of screen, stop at zero char or
  last line of screen.

 INPUT
   esi = line ptr
   color and cursor location already set

 OUTPUT
   ah=color al=char out
   dh=row   cl=column (next write positon)
   esi=ptr beyond last input char written
   edi=image index
   ebp=top of image buffer

-----------------------------------------------------------------------
100 dcache_write_repeat - write repeat to cache
-----------------------------------------------------------------------
  stops at edge of screen

 INPUT
    al = repeat char
    ah = repeat flag, 0=horizontal 1=vertical
    ecx = repeat count
    color and cursor location already set

  OUTPUT
     buffer cursor at end of last write
     ah=repeat color al=repeat char
     ecx=0
     dh=row dl=column
     edi=image index
     edp=image buffer

-----------------------------------------------------------------------
101 dcache_write_string - write string to cache
-----------------------------------------------------------------------
  write string and handle, tabs, line-feeds, truncate
  at edge of screen, stop at zero char or
  last line of screen.

 INPUT
    esi = string ptr
    color and cursor location already set

 OUTPUT
     ah=color al=char out
     dh=row   cl=column (next write positon)
     esi=ptr beyond last input char written
     edi=image index
     ebp=top of image buffer

-----------------------------------------------------------------------
102 dir_access - check if file can be accessed
-----------------------------------------------------------------------
 INPUTS    ebx = ptr to dir path
           ecx = type of access wanted
                 0=path existence check
                 1=execute access
                 2=write access
                 4=read access


 OUTPUT    eax =  zero if access ok, else negative error

 NOTES:  Source file is file_acces.asm

-----------------------------------------------------------------------
103 dir_change - change current working directory
-----------------------------------------------------------------------
 INPUTS
    ebx = path of new dir
 OUTPUT
    eax = negative if error
 NOTES
   source file: file_dir.asm
   kernel: chdir (12)

-----------------------------------------------------------------------
104 dir_close - close a open directory and release memory
-----------------------------------------------------------------------

  INPUTS
     eax = dir_block ptr
     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;set by dir_sort
      dir_block_struc_size
     endstruc

  OUTPUT     eax = 0 if sucessful

  NOTE
     source file is dir_open.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close - release memory & file


-----------------------------------------------------------------------
105 dir_close_file - close a open directory, retain memory
-----------------------------------------------------------------------

  INPUTS
     eax = dir_block ptr
     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;set by dir_sort
      dir_block_struc_size
     endstruc

  OUTPUT     eax = 0 if sucessful

  NOTE
     source file is dir_open.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close - release memory & file


-----------------------------------------------------------------------
106 dir_close_memory - release memory allocated by dir_open
-----------------------------------------------------------------------

  INPUTS
     eax = dir_block ptr
     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;set by dir_sort
      dir_block_struc_size
     endstruc

  OUTPUT     eax = 0 if sucessful

  NOTE
     source file is dir_open.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close - release memory & file


-----------------------------------------------------------------------
107 dir_create - create a new directory
-----------------------------------------------------------------------
 INPUTS
    ebx = path of new directory
 OUTPUT
    eax = negative error# if problem
 NOTES
   source file: file_dir.asm
   kernel: mkdir(39)
   This function creates a user read/write directory
   if other directories are needed use kernel call

-----------------------------------------------------------------------
108 dir_current - get current working directory
-----------------------------------------------------------------------
 INPUTS    none

 OUTPUT    eax = size of path string or negative error#
           ebx = ptr to path if eax positive
           ecx - modified                     
          
 NOTES:  Source file is dir_current.asm
         Error returns from this function are
         possible, but almost never occur.

-----------------------------------------------------------------------
109 dir_delete - delete an empty directory
-----------------------------------------------------------------------
 INPUTS
    ebx = path of directory
 OUTPUT
    eax = negative error# if problem
 NOTES
   source file: file_dir.asm
   kernel: rmdir(40)

-----------------------------------------------------------------------
110 dir_index - index an open directory
-----------------------------------------------------------------------
     allocates memory for an index and fills with pointers
     to directory entries.  End of pointers is a zero ptr.
     The records_count of dir_block structure is set and
     so is .allocation_end.  index_ptr points to the index.
  INPUTS
     eax = ptr to dir_block (see following struc)    
     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;set by dir_sort
      dir_block_struc_size
     endstruc

  OUTPUT     eax = + if sucessful, else memory allocation error
             The the index entries point to file name within
             the dents structure.
  NOTE
     source file is dir_index.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close - release memory & file


-----------------------------------------------------------------------
111 dir_open - allocate memory and read directory
-----------------------------------------------------------------------
     A dir_block is created and returned
     to caller (see outputs)
  INPUTS
     eax = end of .bss section memory
           Used to allocate memory.  This section
           must be at end of program.
     ebx = directory path

     calling example:
           mov  eax,last_bss
           mov	 ebx,dir_path
           call dir_open
           or   eax,eax
           js   error 
           ( normal code here)
           [section .data]
           dir_path: db "/home/sam",0
           [section .bss]
           last_bss:
           


  OUTPUT     eax = negative if error, else it contains
                   a ptr to the following block.

     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records, + 8 zeros
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;set by dir_sort
      dir_block_struc_size
     endstruc

  NOTE
     source file is dir_open.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close_file - release file
                            dir_close_memory - release memory
                            dir_close - release file and memory


-----------------------------------------------------------------------
112 dir_open_indexed - open a directory and index
-----------------------------------------------------------------------

  INPUTS
     eax = end of .bss section memory
           Used to allocate memory.  This section
           must be at end of program.
     ebx = directory path

     calling example:
           mov  eax,last_bss
           mov	 ebx,dir_path
           call dir_open_indexed
           or   eax,eax
           js   error 
           ( normal code here)
           [section .data]
           dir_path: db "/home/sam",0
           [section .bss]
           last_bss:
           

  OUTPUT     eax = negative if error else dir_block ptr
     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;future use by dir_sort
      dir_block_struc_size
     endstruc

  NOTE
     source file is dir_open_indexed.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close - release memory & file


-----------------------------------------------------------------------
113 dir_open_sorted - open a directory, index, and sort
-----------------------------------------------------------------------

  INPUTS
     eax = end of .bss section memory
           Used to allocate memory.  This section
           must be at end of program.
     ebx = directory path

     calling example:
           mov  eax,last_bss
           mov	 ebx,dir_path
           call dir_open_sorted
           or   eax,eax
           js   error 
           ( normal code here)
           [section .data]
           dir_path: db "/home/sam",0
           [section .bss]
           last_bss:
           

  OUTPUT     eax = negative if error else dir_block ptr

     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;future use by dir_sort
      dir_block_struc_size
     endstruc

     The index_ptr entries point to a directory entry read
     by getdents.  The format of these entries are:

     struc dents
      .d_ino   resd 1  ;inode number
      .d_off   resd 1  ;offset to next dirent from top of file
      .d_reclen resw 1;length of this dirent
      .d_name  resb 1  ;directory name (variable length)
     endstruc

  NOTE
     source file is dir_open_indexed.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close - release memory & file
     The other sort calls (by name and type) do not use the
     dents structure format.

-----------------------------------------------------------------------
114 dir_read - open, read, close a directory structure
-----------------------------------------------------------------------
 INPUTS
     ebx = directory path
     edi = buffer to hold directory info
     ecx = size of buffer 
 OUTPUT
    eax = negative error# if problems, -1 = buffer too small
        = size of read if eax is positive
    ebx = dir size if eax=-1
 NOTES
   source file: file_dir.asm
   kernel open(5) getdents(141) close(6)

-----------------------------------------------------------------------
115 dir_read_grow - allocate memory and read directory
-----------------------------------------------------------------------
  INPUTS
     eax = end of .bss section memory
           Used to allocate memory.  This section
           must be at end of program.
     ebx = directory path

     calling example:
           mov  eax,last_bss
           mov	 ebx,dir_path
           call dir_read_grow
           or   eax,eax
           js   error 
           ( normal code here)
           [section .data]
           dir_path: db "/home/sam",0
           [section .bss]
           last_bss:
           


  OUTPUT     eax = negative if error, else it contains
                   length of read.
             if eax positive then 8 bytes of zeros are stuffed
                at end of buffer and   ecx=end of data ptr

  NOTE
     source file is dir_read_grow.asm

-----------------------------------------------------------------------
116 dir_sort - sort a opened and indexed directory
-----------------------------------------------------------------------
  INPUTS
     eax = ptr to dir_block with status of target dir

  OUTPUT     eax = negative if error, else it contains
                   a ptr to the following block.

     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;set by dir_sort
      dir_block_struc_size
     endstruc

  NOTE
     source file is dir_open.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close_file - release file
                            dir_close_memory - release memory
                            dir_close - release file and memory


-----------------------------------------------------------------------
117 dir_sort_by_name - sort a opened and indexed directory
-----------------------------------------------------------------------
  INPUTS
     esi = ptr to directory path matching dir_block.
           path ends with '/'
     eax = ptr to dir_block with status of target dir

  OUTPUT     eax = negative if error, else it contains
                   a ptr to the following block.

     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;set by dir_sort
      dir_block_struc_size
     endstruc

  NOTE
     source file is dir_open.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close_file - release file
                            dir_close_memory - release memory
                            dir_close - release file and memory


-----------------------------------------------------------------------
118 dir_sort_by_type - sort a opened and indexed directory
-----------------------------------------------------------------------
  INPUTS
     esi = ptr to directory path matching dir_block.
           path ends with '/'
     eax = ptr to dir_block with status of target dir

  OUTPUT     eax = negative if error, else it contains
                   a ptr to the following block.

     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;set by dir_sort
      dir_block_struc_size
     endstruc

  NOTE
     source file is dir_open.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close_file - release file
                            dir_close_memory - release memory
                            dir_close - release file and memory


-----------------------------------------------------------------------
119 dir_status - check if directory exists
-----------------------------------------------------------------------
 INPUTS
     ebx = path for directory
 OUTPUT
    eax = negative error if problems, js,jns flags
          set for conditonal jump
    ecx = fstat buffer ptr if success
          (see lstat kernel call)
 NOTES
   source file: file_dir.asm
   kernel: lstat (107)
   temp buffer lib_buf is used.

-----------------------------------------------------------------------
120 dir_type - Add type information to indexed directory
-----------------------------------------------------------------------
     dir_type is called by dir_sort_by_name and dir_sort_by_type.
     Normally it is not called as a standalone function.
  INPUTS
     esi = ptr to path of this directory (ends with '/')
     eax = ptr to open dir_block

     struc dir_block
      .handle			;set by dir_open
      .allocation_end		;end of allocated memory
      .dir_start_ptr		;ptr to start of dir records
      .dir_end_ptr		;ptr to end of dir records
      .index_ptr		;set by dir_index
      .record_count		;set by dir_index
      .work_buf_ptr		;set by dir_sort
      dir_block_struc_size
     endstruc

     Note: dir_type is usually called after dir_index
           or dir_open_indexed

  OUTPUT     eax = negative if error, else it contains
                   a ptr to the dir_block
     The index now points to a directory entries with
     the following structure:

     struc dtype
      .d_size	resd 1	;byte size for fstat .st_size
      .d_mode	resw 1	;type information from fstat .st_mode 
      .d_uid   resw 1  ;owner code
      .d_len   resb 1  ;length byte from dent structure
      .d_type  resb 1  ;type code 1=dir 2=symlink 3=file
      .d_nam resb 1	;directory name (variable length)
     endstruc

  NOTE
     source file is dir_type.asm
     related functions are: dir_open - allocate memory & read
                            dir_index - allocate memory & index
                            dir_open_indexed - dir_open + dir_index
                            dir_sort - allocate memory & sort
                            dir_open_sorted - open,index,sort
                            dir_close_file - release file
                            dir_close_memory - release memory
                            dir_close - release file and memory


-----------------------------------------------------------------------
121 dir_walk - traverse directory and return selected paths
-----------------------------------------------------------------------
 inputs: esi = ptr to starting path
         ebx = optional ptr to string with file mask:
                  *xxxx  or xxxx*
               The file mask is not applied to directories.
               if ebx=0 then all files match mask
         ecx = flags  ch - 01 return directories bit
                         - 02 return files if mask allows
                         - 04 return sym links
                         - 08 return all non file,dir,symlink
                      cl - max depth for recursion, 0=current level only
         edx = process to call when a match occurs, the return
               input to process is:
                           eax=ptr to path string
                           ecx=ptr to current match (also at end of path)
                           [lib_buf] has stat_struc (see structures)
               output from process is:
                           eax=0 continue
                           eax non-zero = abort directory walk and exit
               the return process is called each time a path matches
               the criteria (mask and flags).
         eax = ptr to buffer, get using memory_init or call kernel function 45

 output: eax = 0 (success) or negative error number

-----------------------------------------------------------------------
122 draw_box - use line drawing characters to draw a box
-----------------------------------------------------------------------
 inputs:
    esi = ptr to block of data as follows:
          dd <color>
          db row
          db column
          db vertical size
          db horizontal size
 outputs:
    none
 notes:
   source file  draw_box.asm


-----------------------------------------------------------------------
123 draw_off - disable line drawing characters
-----------------------------------------------------------------------
 inputs:
    none
 outputs:
    none
 notes:
   source file  draw_off.asm

-----------------------------------------------------------------------
124 draw_on - enable line drawing characters
-----------------------------------------------------------------------
 inputs:
    none
 outputs:
    none
 notes:
   source file  draw_on.asm

If draw_on is called, the character map changes as follows:

    ASCII      Special                  ASCII     Special
   graphic     graphic                 graphic    graphic
----------------------------------------------------------------------
     _         Blank                      o       Horiz Line - scan 1
     '         Diamond                    p       Horiz Line - scan 3
     a         Checkerboard               q       Horiz Line - scan 5
     b         Digraph: HT                r       Horiz Line - scan 7
     c         Digraph: FF                s       Horiz Line - scan 9
     d         Digraph: CR                t       Left "T" (|-)
     e         Digraph: LF                u       Right "T" (-|)
     f         Degree Symbol              v       Bottom "T" (|_)
     g         +/- Symbol                 w       Top "T" (T)
     h         Digraph: NL                x       Vertical Bar (|)
     i         Digraph: VT                y       Less/Equal (<_)
     j         Lower-right corner         z       Grtr/Egual (>_)
     k         Upper-right corner         {       Pi symbol
     l         Upper-left corner          |       Not equal (=/)
     m         Lower-left corner          }       UK pound symbol
     n         Crossing lines (+)         ~       Centered dot

 note: some terminals have not implemented all characters.
       This was noticed on Konsole (2005-4-9), but xterm 
       and rxvt were OK.

-----------------------------------------------------------------------
125 draw_table - draw using table of actions   
-----------------------------------------------------------------------
 inputs:
    esi = ptr to draw table
          draw table codes db 0                  = end of table
                           db 1 + dd cccc        = color change
                           db 2,row,col,char     = single char display
                           db 3,row,col,rep,char = repeat char. horiz
                           db 4,row,col,rep,char = repeat char, down
                           db 5                  = draw on
                           db 6                  = draw off

 outputs:
    none
 notes:
   source file  draw_table.asm

draw_on will change character map changes as follows:

    ASCII      Special                  ASCII     Special
   graphic     graphic                 graphic    graphic
----------------------------------------------------------------------
     _         Blank                      o       Horiz Line - scan 1
     '         Diamond                    p       Horiz Line - scan 3
     a         Checkerboard               q       Horiz Line - scan 5
     b         Digraph: HT                r       Horiz Line - scan 7
     c         Digraph: FF                s       Horiz Line - scan 9
     d         Digraph: CR                t       Left "T" (|-)
     e         Digraph: LF                u       Right "T" (-|)
     f         Degree Symbol              v       Bottom "T" (|_)
     g         +/- Symbol                 w       Top "T" (T)
     h         Digraph: NL                x       Vertical Bar (|)
     i         Digraph: VT                y       Less/Equal (<_)
     j         Lower-right corner         z       Grtr/Egual (>_)
     k         Upper-right corner         {       Pi symbol
     l         Upper-left corner          |       Not equal (=/)
     m         Lower-left corner          }       UK pound symbol
     n         Crossing lines (+)         ~       Centered dot

 note: some terminals have not implemented all characters.
       This was noticed on Konsole, but xterm & rxvt were OK.

-----------------------------------------------------------------------
126 env_exec - search executable path for program
-----------------------------------------------------------------------
 INPUTS
    ebx = pointer to envionmet pointer list
    ebp = pointer to program name to search for 
 OUTPUT
    if no-carry ebx = ptr to full path of executable
    if carry, file was not found.
 NOTES
    file env_exec.asm  (see also build_current_path)
    temp buffer "lib_buf" is used to pass executable path
    back to caller.

-----------------------------------------------------------------------
127 env_home - search the enviornment for $HOME
-----------------------------------------------------------------------
 INPUTS
     ebx = ptr to list of env pointers
     edi = buffer to store $HOME contents
 OUTPUT
    edi = ptr to zero at end of $HOME string
 NOTES
    file:  env_home.asm (see also build_homepath)

-----------------------------------------------------------------------
128 env_home2 - search /proc for $HOME
-----------------------------------------------------------------------
 INPUTS
     edi = buffer to store $HOME contents
 OUTPUT
    edi = ptr to zero at end of $HOME string or
          unchanged if $HOME not found.
          $HOME string has a '/' appended to
          the end.  Thus, it would look like
          this:   /home/tom/
 NOTES
    file:  env_home2.asm (see also build_homepath)
    See also: env_home
    This version of env_home uses the /proc system
    to find enviornment strings.

-----------------------------------------------------------------------
129 env_shell - search enviornment for SHELL=
-----------------------------------------------------------------------
 INPUTS
    edx = ptr to buffer (shell path storage)
 OUTPUT
    [edx] - contains SHELL= string or /bin/sh if
            not found
     edi - points to end of stored string
 NOTES
   source file: env_shell.asm

-----------------------------------------------------------------------
130 env_stack - find stack ptrs to enviornment
-----------------------------------------------------------------------
 INPUTS
    esp = stack ptr before any pops or pushes
 OUTPUT
    ebp = ptr to enviroment pointers
    [enviro_ptrs] set also
 NOTES
    source file:  env_stack.asm

-----------------------------------------------------------------------
131 find_env_variable - search enviornment for variable name
-----------------------------------------------------------------------
 INPUTS
    [enviro_ptrs] - setup by env_stack
    ecx = ptr to variable name (asciiz)
    edx = storage point for variable contents
 OUTPUT
    data stored at edx, if edi is preloaded with
    a zero it can be checked to see if variable found
    edi - if success, edi points to end of varaible stored
 NOTES
   source file:  find_env_variable.asm

-----------------------------------------------------------------------
132 lib_data - common data used by crt functions  
-----------------------------------------------------------------------
 INPUTS
    see env_stack, crt_open sets crt_rows & crt_columns
 OUTPUT
 NOTES
    file lib_data.asm
     
    crt_rows (byte) set by crt_open
    crt_columns (byte) set by crt_open
     
      scratch variables -------------------
    crt_left_column - used by many
    data_end_ptr - used by many
    win_columns - used by many
    lib_buf - 600 byte buffer
     
      default color definitions -----------
      norm_text_color dd 30003734h ;used for inactive window
      grey-foreground=7 blue-backgound=4 0=norm attr
     
      bold_edit_color dd 31003734h ; active window in edit mode
      grey-foreground=7 blue-backgound=4 0=bold attr
     
      bold_cmd_color dd 31003334h ; active window in command mode
      grey-foreground=7 blue-backgound=4 0=bold attr
     
      high_text_color dd 31003634h ;used for highlighting block
      grey-foreground=7 blue-backgound=4 0=inver attr
     
      asm_text_color dd 31003234h ;used to highlight comments ";"
      cyan-foreground=6 blue-backgound=4 0=norm attr
     
      status_color dd 30003036h ;used for status line
      status_color1 dd 31003336h ; special data on status line
      status_color2 dd 31003331h ; error messags or macro record
      exit_screen_color dd 31003334h ; error messags on status line

-----------------------------------------------------------------------
133 save_stack_ptrs - save information from stack
-----------------------------------------------------------------------
 INPUTS
    esp = stack ptr before any pops or pushes
 OUTPUT
    stack_args_ptr - global ptr to: number or args,
                     followed by arg ptrs.
    stack_env_ptr  - global ptr to enviornment ptrs
    stack_aux_ptr  - global ptr to aux data. Each entry
                     consists or "code" followed by "data"
                     (see codes)
    syscall        - kernel entery found in aux data area

 NOTES
    source file:  save_stack_ptrs.asm

    codes taken from /usr/include/elf.h 
       AT_NULL		0		/* End of vector */
       AT_IGNORE	1		/* Entry should be ignored */
       AT_EXECFD	2		/* File descriptor of program */
       AT_PHDR		3		/* Program headers for program */
       AT_PHENT	4		/* Size of program header entry */
       AT_PHNUM	5		/* Number of program headers */
       AT_PAGESZ	6		/* System page size */
       AT_BASE		7		/* Base address of interpreter */
       AT_FLAGS	8		/* Flags */
       AT_ENTRY	9		/* Entry point of program */
       AT_NOTELF	10		/* Program is not ELF */
       AT_UID		11		/* Real uid */
       AT_EUID		12		/* Effective uid */
       AT_GID		13		/* Real gid */
       AT_EGID		14		/* Effective gid */
       AT_CLKTCK	17		/* Frequency of times() */
       AT_PLATFORM	15		/* String identifying platform.  */
       AT_HWCAP	16		/* Machine dependent hints about
       AT_FPUCW	18		/* Used FPU control word.  */
       AT_DCACHEBSIZE	19		/* Data cache block size.  */
       AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
       AT_UCACHEBSIZE	21		/* Unified cache block size.  */
       AT_IGNOREPPC	22		/* Entry should be ignored.  */
      	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
       AT_SYSINFO	32
       AT_SYSINFO_EHDR	33
       AT_L1I_CACHESHAPE	34
       AT_L1D_CACHESHAPE	35
       AT_L2_CACHESHAPE	36
       AT_L3_CACHESHAPE	37

-----------------------------------------------------------------------
134 build_current_path - build path using current dir
-----------------------------------------------------------------------
 INPUTS
     ebx = ptr to buffer
     ebp = append string for path, or zero if no append 
 OUTPUT
     eax = negative if error
     eax = positive, then buffer has path.
 NOTES
    source file:  file_path.asm

-----------------------------------------------------------------------
135 build_file_open - build path and open file
-----------------------------------------------------------------------
 INPUTS
    ebp = ptr to file name
    ebx = ptr to enviornment pointers if bit 2 of al set
    al  = flags 
           bit 1 (0000 0001) = full path or local file
           bit 2 (0000 0010) = full path or file at $HOME/[base]
           (this register optional if full path is provided)
           (it is ok to set both bits, local path checked first)
 OUTPUT
    eax contains a negative error code or file handle
        flags set for js/jns jmp
    edx = file permissions if eax positive
 NOTES
   source file:  file_read.asm

-----------------------------------------------------------------------
136 build_homepath - build path using $HOME
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to enviornment pointers
    edi = buffer
    ebp = append string (filename or dir/filename)
          if ebp = 0 no append string is processed
 OUTPUT
    buffer (passed in edi) has path if eax positive
 NOTES
    source file: file_path.asm

-----------------------------------------------------------------------
137 build_write_open - build path and open write file
-----------------------------------------------------------------------
 INPUTS
    ebx = file name ptr           
    ebp = ptr to enviornment pointer if flag bit 0010 set
    edx = file attributes if flag bit 1000 set 
    esi = flags 0000 0001 write to local dir or full path if given
                0000 0010 write to $HOME or full path if given
                0000 0100 check for existing file and preserve attr
                0000 1000 file attr are in edx, ignore 0100 flag
                0001 0000 append to existing file if found
    Note: file name in ebx can be partial directory (dir/file.inc)
 OUTPUT
    eax = negative error number or positive identifier (handle)
 NOTES
    source file: file_write.asm

-----------------------------------------------------------------------
138 file_access - check if file can be accessed
-----------------------------------------------------------------------
 INPUTS    ebx = ptr to file path
           ecx = bit flag for type of access wanted
                 0=path existence check
                 1=execute access
                 2=write access
                 4=read access
                 example:  ecx=3 for execute & write check

 OUTPUT    eax =  zero if access ok, else negative error

 NOTES:  Source file is file_acces.asm

-----------------------------------------------------------------------
139 file_close - close opened file
-----------------------------------------------------------------------
 INPUTS
    ebx = file handle (file descriptor)
 OUTPUT
    eax = negative if error (error number)
          flag bits set for js jns jumps
 NOTES
    source file:  file_basics.asm

-----------------------------------------------------------------------
140 file_copy - copy one file
-----------------------------------------------------------------------
 INPUTS
    ch  = flags (these flags are for reading file)
           bit 1 (0000 0001) = full path or local file
           bit 2 (0000 0010) = full path or file at $HOME/[base]
           (this register optional if full path is provided)
           (it is ok to set both bits, local path checked first)
    ebx = ptr to (from) filename
    cl  = flags (write file flags)
                0000 0001 - write to local directory or full path if given
                0000 0010 - write to $HOME or full path if given
                0000 0100 - use existing write attributes
                0000 1000 - file attributes are from input file,
                -           (ignore 0100 flag)
                0001 0000 - append to existing file if found
    edx = ptr to (destination) filename
    ebp = ptr to enviornment pointer if any flag = 2
 OUTPUT
    eax = negative error code or success if positive
 NOTES
    source file: file_copy.asm

-----------------------------------------------------------------------
141 file_delete - delete file
-----------------------------------------------------------------------
 INPUTS
    ebx = path of file to delete
 OUTPUT
    eax = negative error# if problem
 NOTES
   source file: file_delete.asm
   kernel: unlink(10)

-----------------------------------------------------------------------
142 file_exec_path - build full path to executable
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to buffer with file name.  It will
          be replaced with full path name. If full
          path is entered, it will be checked for
          access rights.
 OUTPUT:
    carry set if error - file not executable
                         or env_stack call needed
    no carry = full path for executable in buffer

 NOTES
   source file: file_exec_path.asm
   The input buffer must be big enough to hold
   the full path to executable file.
   lib_buf is used as work buffer.
   Executable file may be on path or in current
   working directory.  

-----------------------------------------------------------------------
143 file_length_handle - get length of file using descriptor
-----------------------------------------------------------------------
 INPUTS
    ebx = file handle (file descriptor)
 OUTPUT
    eax = negative if error (error number)
          flag bits set for js jns jumps
          else (eax positive) file length
 NOTES
    source file:  file_basics.asm

-----------------------------------------------------------------------
144 file_length_name - get length of named file
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full path for file
 OUTPUT
    eax = negative if error (error number)
          flag bits set for js jns jumps
          else (eax positive) file length
 NOTES
    file:  file_basics.asm

-----------------------------------------------------------------------
145 file_list_copy - copy files on list
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to file list
          file list contains asciiz names
          example:  file_list: db <from flag>
                               db 'from_name1',0
                               db <to flag>
                               db 'to_name1',0
                               db 0  ;end of  table
         from flags
           bit 1 (0000 0001) = full path or local file
           bit 2 (0000 0010) = full path or file at $HOME/[base]
           (this register optional if full path is provided)
           (it is ok to set both bits, local path checked first)
          destination flags
                0000 0001 - write to local directory or full path if given
                0000 0010 - write to $HOME or full path if given
                0000 0100 - check for existing file and preserve attributes
                0000 1000 - file attributes from in-file, ignore 0100 flag
                0001 0000 - append to existing file if found
    ebp = env ptr if any flags have bit 2 set ($HOME paths)
 NOTES
    source file:  file_copy.asm

-----------------------------------------------------------------------
146 file_open - open named file
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full file path
    ecx = access flags
      O_RDONLY          00
      O_WRONLY          01
      O_RDWR            02

      O_CREAT           0100
      O_EXCL            0200
      O_NOCTTY          0400
      O_TRUNC           01000
      O_APPEND          02000
      O_NONBLOCK        04000
      O_NDELAY          O_NONBLOCK
      O_SYNC            010000 specific to ext2 fs and block devices
      FASYNC            020000 fcntl, for BSD compatibility
      O_DIRECT          040000 direct disk access hint-currently ignored
      O_LARGEFILE       0100000
      O_DIRECTORY       0200000 must be a directory
      O_NOFOLLOW        0400000 don't follow links;

    edx = permissions used if file created
      S_ISUID           04000 set user ID on execution
      S_ISGID           02000 set group ID on execution
      S_ISVTX           01000 sticky bit
      S_IRUSR           00400 read by owner(S_IREAD)
      S_IWUSR           00200 write by owner(S_IWRITE)
      S_IXUSR           00100 execute/search by owner(S_IEXEC)
      S_IRGRP           00040 read by group
      S_IWGRP           00020 write by group
      S_IXGRP           00010 execute/search by group
      S_IROTH           00004 read by others
      S_IWOTH           00002 write by others
      S_IXOTH           00001 execute/search by others
 OUTPUT
    eax = negative if error (error number)
    eax = positive file handle if success
          flags are set for js jns jump
 NOTES
    source file:  file_basics.asm

-----------------------------------------------------------------------
147 file_open_rd - open named file
-----------------------------------------------------------------------
 INPUTS
     ebx = ptr to full path for file.
 OUTPUT
     eax = negative err# if file can not be accessed
           flags set for js jns jump
           else eax = file handle of open file
     dx  = file permissions if eax positive
     [lib_buf + 200] contains stat_struc (see file_status_*)
 NOTES
    file:  file_basics.asm

-----------------------------------------------------------------------
148 file_read - read n bytes from open file
-----------------------------------------------------------------------
 INPUTS
    ebx = file descriptor (handle)
    edx = buffer  size
    ecx = buffer ptr
 OUTPUT
    eax contains a negative error code or
        a positive count of bytes read.
 NOTES
   source file: file_basics.asm

-----------------------------------------------------------------------
149 file_read_all - open,read entire file,close
-----------------------------------------------------------------------
 INPUTS
    ebp = ptr to file name
    edx = buffer size
    ecx = buffer ptr
    ebx = ptr to enviornment pointers if bit 2 of al set
    al  = flags 
           bit 1 (0000 0001) = full path or local file
           bit 2 (0000 0010) = full path or file at $HOME/[base]
           (this register optional if full path is provided)
           (it is ok to set both bits, local path checked first)
 OUTPUT
    eax = negative error (sign bit set for js,jns jump)
          buffer too small returns error code -2
    ebp = file permissions if eax positive
    eax= lenght of read
    ecx= buffer pointer if eax positive
    edx= reported file size (save as read)
 NOTES
   source file: file_read.asm
   If file does not fit into buffer provided an error is
   returned.

-----------------------------------------------------------------------
150 file_read_grow - open and read entire file, expand buffer if necessary
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to enviornment pointers if bit 2 of al set
    ebp = ptr to file name
    ecx = ptr to buffer
    edi = ptr to segment end (needed for expand kernel call)
    edx = ptr to end of current file
    al  = flags  (0000 0000) = full path provided
           bit 1 (0000 0001) = full path or local file
           bit 2 (0000 0010) = full path or file at $HOME/[base]
           bit 5 (0001 0000) = insert file
 OUTPUT
    eax = either negative error or positive file length
    ebp = file permissions if eax positive
    ecx = buffer pointer for read
 NOTES
    source file: file_read.asm

-----------------------------------------------------------------------
151 file_rename - rename a file 
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to old file path
    ecx - ptr to new file path
 OUTPUT
    eax = negative if error
 NOTES
   source file: file_rename.asm
   kernel: rename(38)

-----------------------------------------------------------------------
152 file_simple_read - open & read file to buffer, then close
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full path for file.
    edx = buffer  size
    ecx = buffer ptr
 OUTPUT
    eax contains a negative error code or
        a positive count of bytes read
        the sign bit is set for js/jns 
 NOTES
   source file: file_basics.asm

-----------------------------------------------------------------------
153 file_status_handle - check filename exists and get status
-----------------------------------------------------------------------
 INPUTS
    ebx = file descriptor (handle)
 OUTPUT
    eax = result if negative file does not exist and sign
                   bit is set for js jns jump
                 if eax positive then dx = permissions
                 if eax positive ecx = ptr to stat struct (below)
      
     struc	stat_struc
     .st_dev: resd 1           ;device
     .st_ino: resd 1           ;inode
     .st_mode: resw 1          ;see below
     .st_nlink: resw 1 	;number of hard links
     .st_uid: resw 1		;user ID of owner
     .st_gid: resw 1		;group ID of owner
     .st_rdev: resd 1  	;device type (if inode device)
     .st_size: resd 1  	;total size in bytes
     .st_blksize: resd 1	;blocksize for filesystem I/O
     .st_blocks: resd 1	;number of blocks allocated
     .st_atime: resd 1	        ;time of last access
     .__unused1: resd 1	
     .st_mtime: resd 1  	;time of last modification
     .__unused2: resd 1
     .st_ctime: resd 1	        ;time of last change
     .__unused3: resd 1
     .__unused4: resd 1
     .__unused5: resd 1
     ;  ---  stat_struc_size
     endstruc
      
     The following "octal" flags are defined for the st_mode field
      
              0170000 bitmask for the file type bitfields

     S_IFSOCK 0140000 socket
     S_IFLNK  0120000 symbolic link
     S_IFREG  0100000 regular file
     S_IFBLK  0060000 block device
     S_IFDIR  0040000 directory
     S_IFCHR  0020000 character device
     S_IFIFO  0010000 fifo
     S_ISUID  0004000 set UID bit
     S_ISGID  0002000 set GID bit (see below)
     S_ISVTX  0001000 sticky bit (see below)

              00700   mask for file owner permissions

     S_IRUSR  00400   owner has read permission
     S_IWUSR  00200   owner has write permission
     S_IXUSR  00100   owner has execute permission

              00070   mask for group permissions

     S_IRGRP  00040   group has read permission
     S_IWGRP  00020   group has write permission
     S_IXGRP  00010   group has execute permission

              00007   mask for permissions for others (not in group)

     S_IROTH  00004   others have read permission
     S_IWOTH  00002   others have write permisson
     S_IXOTH  00001   others have execute permission
 NOTES
    file: file_basics.asm
    stat_struc is held in temporary buffer and may be overwritten
    by next library call.

-----------------------------------------------------------------------
154 file_status_name - check filename exists and get status
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full path name.
 OUTPUT
    eax = result if negative file does not exist and sign
                 bit is set for js jns jump
                 if eax positive then dx = permissions
                 if eax positive ecx = ptr to stat struct (below)
      
     struc	stat_struc
     .st_dev: resd 1        ;device
     .st_ino: resd 1        ;inode
     .st_mode: resw 1       ;see below
     .st_nlink: resw 1      ;number of hard links
     .st_uid: resw 1        ;user ID of owner
     .st_gid: resw 1        ;group ID of owner
     .st_rdev: resd 1       ;device type (if inode device)
     .st_size: resd 1       ;total size in bytes
     .st_blksize: resd 1    ;blocksize for filesystem I/O
     .st_blocks: resd 1     ;number of blocks allocated
     .st_atime: resd 1      ;time of last access
     .__unused1: resd 1	
     .st_mtime: resd 1      ;time of last modification
     .__unused2: resd 1
     .st_ctime: resd 1      ;time of last change
     .__unused3: resd 1
     .__unused4: resd 1
     .__unused5: resd 1
     ;  ---  stat_struc_size
     endstruc
      
     The following "octal" flags are defined for the st_mode field
      
              0170000 bitmask for the file type bitfields

     S_IFSOCK 0140000 socket
     S_IFLNK  0120000 symbolic link
     S_IFREG  0100000 regular file
     S_IFBLK  0060000 block device
     S_IFDIR  0040000 directory
     S_IFCHR  0020000 character device
     S_IFIFO  0010000 fifo
     S_ISUID  0004000 set UID bit
     S_ISGID  0002000 set GID bit (see below)
     S_ISVTX  0001000 sticky bit (see below)

              00700   mask for file owner permissions

     S_IRUSR  00400   owner has read permission
     S_IWUSR  00200   owner has write permission
     S_IXUSR  00100   owner has execute permission

              00070   mask for group permissions

     S_IRGRP  00040   group has read permission
     S_IWGRP  00020   group has write permission
     S_IXGRP  00010   group has execute permission

              00007   mask for permissions for others (not in group)

     S_IROTH  00004   others have read permission
     S_IWOTH  00002   others have write permisson
     S_IXOTH  00001   others have execute permission
 NOTES
    file: file_basics.asm
    stat_struc is held in temporary buffer and may be overwritten
     by next library call.

-----------------------------------------------------------------------
155 file_write - write n bytes to open file
-----------------------------------------------------------------------
 INPUTS
    ebx = file descriptor (handle)
    edx = number of bytes to write
    ecx = buffer ptr
 OUTPUT
    eax contains a negative error code or
        a positive count of bytes written
 NOTES
   source file: file_basics.asm

-----------------------------------------------------------------------
156 file_write_close - open,write, and close file
-----------------------------------------------------------------------
 INPUTS
    ebx = file name ptr           
    eax = buffer
    ecx = lenght of write
    ebp = ptr to enviornment pointer if flag bit 0010 set
    edx = file attributes if flag bit 1000 set 
    esi = flags 0000 0001 write to local dir or full path if given
                0000 0010 write to $HOME or full path if given
                0000 0100 check for existing file and preserve attr
                0000 1000 file attr are in edx, ignore 0100 flag
                0001 0000 append to existing file if found
    Note: file name in ebx can include partial dir  (dir/file.inc)
 OUTPUT
    eax = 0 or + normal
        = -x error occured
 NOTES
    source file: file_write.asm

-----------------------------------------------------------------------
157 filename_extract - extract filename from full path
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to buffer for filename
    edi = ptr to full path
 OUTPUT
    esi points to end of full path
    edi points to end end of extracted filename 
 NOTES
    source file: file_name.asm

-----------------------------------------------------------------------
158 filepath_extract - extract path from path + name
-----------------------------------------------------------------------
 INPUTS
    edi = ptr to full path
    esi = buffer for path storage
 OUTPUT
    edi = ptr to end of extracted path
    esi = ptr to end of full path
    ebx = ptr inside full path to filename
 NOTES
    source file: file_name.asm

-----------------------------------------------------------------------
159 get_current_path - get default (current) dir
-----------------------------------------------------------------------
 INPUTS
     ebx = ptr to buffer
     ecx = buffer size
 OUTPUT
     eax = negative if error
     eax = positive, then buffer has path.
 NOTES
    source file:  file_path.asm

-----------------------------------------------------------------------
160 mmap_close - close memory mapped file and release memory
-----------------------------------------------------------------------
 INPUTS
    eax = mmap fd (file descriptor)
    ebx = ptr to file data
 OUTPUT
    eax - pointer to file contents
    (sign bit set if error)
    ebx and ecx are destroyed
 NOTES
   source file: mmap_close.asm
   see mmap_open_rw.asm and mmap_open_ro for opening files

   The mmap functions should be used for files that
   do not change length.  To append data or truncate
   files the non-mmap routines are prefered.  The
   advantage of mmap is speed and freedom from buffer
   handling.  The mmap functions are:
    mmap_open_rw - open for read and write
    mmap_open_ro - open read only
    mmap_close   - close file and felease buffer

  mmap data may not be written to disk immediatly, if
  that is desired the kernel msync function can be used.
   

-----------------------------------------------------------------------
161 mmap_open_ro - returns a read only pointer to file data
-----------------------------------------------------------------------
 INPUTS
    ebx = poiter to asciiz filename
    ecx = optional buffer size
          set to zero to read complete file
    lib_buf - temporary library buffer utilized        
 OUTPUT
    eax - read length (file length if fits in buffer)
          if error eax will have negative error code.
    ebx - fd (file descriptor)
    ecx - pointer to file contents
 NOTES
   source file: mmap_open_ro.asm
    
   notes: the lib_buf buffer is used to hold fstat status
   of file.  see man fstat for format.
    
   The mmap functions should be used for files that
   do not change length.  To append data or truncate
   files the non-mmap routines are prefered.  The
   advantage of mmap is speed and freedom from buffer
   handling.  The mmap functions are:
    mmap_open_rw - open for read and write
    mmap_open_ro - open read only
    mmap_close   - close file and felease buffer

  mmap data may not be written to disk immediatly, if
  that is desired the kernel msync function can be used.

-----------------------------------------------------------------------
162 mmap_open_rw - map file into memory for read/write
-----------------------------------------------------------------------
 INPUTS
    ebx = pointer to file path (asciiz filename)
          (full path to file or local file)
    ecx = size of memory area to allocate for file
          (small memory usage encouraged)
 OUTPUT
    eax - either positive length of file or
                 negative error code
    ebx - file descriptor (fd)
    ecx - ptr to file contents         
 NOTES
   source file: mmap_open_rw.asm
   see also: mmapfile.asm for read only version
   see mmap_close.asm for writing mmap_open_rw data out

   The mmap functions should be used for files that
   do not change length.  To append data or truncate
   files the non-mmap routines are prefered.  The
   advantage of mmap is speed and freedom from buffer
   handling.  The mmap functions are:
    mmap_open_rw - open for read and write
    mmap_open_ro - open read only
    mmap_close   - close file and felease buffer

  mmap data may not be written to disk immediatly, if
  that is desired the kernel msync function can be used.
    

-----------------------------------------------------------------------
163 block_close - close file
-----------------------------------------------------------------------
 INPUTS
    ebx = file handle (identifier)
 
 OUTPUT
    eax = negative if error (error number)
    eax = positive file handle if success
          flags are set for js jns jump
 NOTES
    source file:  block_close.asm
    The block_close function releases files
    and is part of the normal file hanling
    sequence of:  block_open...
                  block_read...
                  block_write...
                  block_close

-----------------------------------------------------------------------
164 block_open_append - open file for appended writes
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full file path or local file.
          full path is indicated by a '/' at start of name.
    edx = optional file permissions.
          can be set to zero for default permissions
 
 OUTPUT
    eax = negative if error (error number)
        = positive file handle if success
          flags are set for js jns jump
    ebx = file handle if eax positive

 PROCESSING
    If file does not exist it will be created.
    If file exists it will be opened at end of data.
       Existing files will be checked for symlinks and
       the target file opened.  If permissions are
       provided they will be applied to file
    Writes append data to end of existing file data.
 NOTES
    source file:  block_open.asm

-----------------------------------------------------------------------
165 block_open_home_append - open file at $HOME for appended writes
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full file path or local file.
          full path is indicated by a '/' at start of name.
    edx = optional file permissions.
          can be set to zero for default permissions
 
 OUTPUT
    eax = negative if error (error number)
        = positive file handle if success
          flags are set for js jns jump
    ebx = file handle if eax positive

 PROCESSING
    If file does not exist it will be created.
    If file exists it will be opened at end of data.
       Existing files will be checked for symlinks and
       the target file opened.  If permissions are
       provided they will be applied to file
    Writes append data to end of existing file data.
 NOTES
    source file:  block_open.asm

-----------------------------------------------------------------------
166 block_open_home_read - open existing file as read-only
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to partial path to append to $HOME directory
 
 OUTPUT
    eax = negative if error (error number)
        = positive file handle if success
          flags are set for js jns jump
    ebx = file handle if eax positive
 NOTES
    source file:  block_open_read.asm

-----------------------------------------------------------------------
167 block_open_home_update - open file at $HOME for reading/writing records
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full file path or local file.
          full path is indicated by a '/' at start of name.
    edx = optional file permissions.
          can be set to zero for default permissions
 
 OUTPUT
    eax = negative if error (error number)
        = positive file handle if success
          flags are set for js jns jump
    ebx = file handle if eax positive

 PROCESSING
    If file does not exist it will be created.
    If file exists it will be opened with pointer at end
       Existing files will be checked for symlinks and
       the target file opened.  If permissions are
       provided they will be applied to file
    Data can be read or written to file and positons for reading
    or writing selected by block_seek 
 NOTES
    source file:  block_open.asm

-----------------------------------------------------------------------
168 block_open_home_write - open truncated file in $HOME dir for read/write
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to path for append to %HOME/
    edx = optional file permissions.
          can be set to zero for default permissions
 
 OUTPUT
    eax = negative if error (error number)
        = positive file handle if success
          flags are set for js jns jump
    ebx = file handle if eax positive

 PROCESSING
    If file does not exist it will be created.
    If file exists it will be truncated.
       Existing files will be checked for symlinks and
       the target file opened.  If permissions are
       provided they will be applied to file
    Origional data in file can not be read, but subsquent
    data written can be read back.     
 NOTES
    source file:  block_open.asm

-----------------------------------------------------------------------
169 block_open_read - open existing file as read-only
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full file path or local file.
          full path is indicated by a '/' at start of name.
 
 OUTPUT
    eax = negative if error (error number)
        = positive file handle if success
          flags are set for js jns jump
    ebx = file handle if eax positive
 NOTES
    source file:  block_open_read.asm

-----------------------------------------------------------------------
170 block_open_update - open file for reading/writing records
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full file path or local file.
          full path is indicated by a '/' at start of name.
    edx = optional file permissions.
          can be set to zero for default permissions
 
 OUTPUT
    eax = negative if error (error number)
        = positive file handle if success
          flags are set for js jns jump
    ebx = file handle if eax positive

 PROCESSING
    If file does not exist it will be created.
    If file exists it will be opened with pointer at start of data
       Existing files will be checked for symlinks and
       the target file opened.  If permissions are
       provided they will be applied to file
    Data can be read or written to file and positons for reading
    or writing selected by block_seek 
 NOTES
    source file:  block_open.asm

-----------------------------------------------------------------------
171 block_open_write - open truncated file for read/write
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full file path or local file.
          full path is indicated by a '/' at start of name.
    edx = optional file permissions.
          can be set to zero for default permissions
 
 OUTPUT
    eax = negative if error (error number)
        = positive file handle if success
          flags are set for js jns jump
    ebx = file handle if eax positive

 PROCESSING
    If file does not exist it will be created.
    If file exists it will be truncated.
       Existing files will be checked for symlinks and
       the target file opened.  If permissions are
       provided they will be applied to file
    Origional data in file can not be read, but subsquent
    data written can be read back.     
 NOTES
    source file:  block_open.asm

-----------------------------------------------------------------------
172 block_read - read file
-----------------------------------------------------------------------
 INPUTS
    ebx = file handle (identifier)
    ecx = buffer pointer
    edx = buffer max size
 
 OUTPUT
    eax = negative if error (error number)
          positive return is number of bytes read
          flags are set for js jns jump
 NOTES
    source file:  block_read.asm

-----------------------------------------------------------------------
173 block_read_all - read file and close it
-----------------------------------------------------------------------
 INPUTS
    ebx = pointer to file name
          filename can be full path if first character is '/'
          filename can be local if first char. is non '/' alpha 
    ecx = buffer pointer
    edx = max buffer size
 OUTPUT
    eax = negative if error (error number)
    eax = positive number of bytes read
          flags are set for js jns jump.
          If buffer is too small the read count will
          match max buffer size. no error will be given.
 NOTES
    source file:  block_read_all.asm

-----------------------------------------------------------------------
174 block_read_home_all - read file and close it
-----------------------------------------------------------------------
 INPUTS
    ebx = pointer to file name
    ecx = buffer pointer
    edx = buffer max size
 OUTPUT
    eax = negative if error (error number)
    eax = positive file handle if success
          flags are set for js jns jump
 NOTES
    source file:  block_read_all.asm

-----------------------------------------------------------------------
175 block_seek - seek to location in file
-----------------------------------------------------------------------
 INPUTS
    ebx = file handle (identifier)
    ecx = if positive seek point (byte location within file)
          if negative seek forward from current pos ~ecx
           
 OUTPUT
    eax = negative if error (error number)
    eax = positive file handle if success
          flags are set for js jns jump
 NOTES
    source file:  block_seek.asm
    The block_seek routine is normally used with
    block_open_update and block_open_home_update to
    position the file pointer for reading and writing
    records.

-----------------------------------------------------------------------
176 block_write - write file
-----------------------------------------------------------------------
 INPUTS
    ebx = file handle (identifier)
    ecx = buffer pointer
    edx = number of bytes to write
 
 OUTPUT
    eax = negative if error (error number)
          positive return is number of bytes written
          flags are set for js jns jump
 NOTES
    source file:  block_write.asm

-----------------------------------------------------------------------
177 block_write_all - write file and close it
-----------------------------------------------------------------------
 INPUTS
    ebx = pointer to file name
          filename can be full path if first character is '/'
          filename can be local if first char. is non '/' alpha
    edx = file permissions or zero to use default 
    ecx = buffer pointer
    esi = buffer size
 OUTPUT
    eax = negative if error (error number)
    eax = positive number of bytes read
          flags are set for js jns jump.
 NOTES
    source file:  block_write_all.asm

-----------------------------------------------------------------------
178 block_write_home_all - write file to $HOME and close it
-----------------------------------------------------------------------
 INPUTS
    ebx = pointer to file name
    edx = file permissions or zero to use default
    ecx = buffer pointer
    esi = number of bytes to write
 
 OUTPUT
    eax = negative if error (error number)
    eax = positive file handle if success
          flags are set for js jns jump
 NOTES
    source file:  block_read_all.asm

-----------------------------------------------------------------------
179 hash_add - add entries to hash table
-----------------------------------------------------------------------
 INPUTS
  esi = ptr to data entry.
  note: function hash_setup must be called before
        using this function.         
 OUTPUT
    eax = positive if success
    eax = -1 if out of room
          
 OPERATION
    The size of this entry is found and the buffer checked
    to see if room is available.  If space is available
    the hash chain is found and the entry added to chain.

 NOTES
    source file: hash_add.asm
                     

-----------------------------------------------------------------------
180 hash_lookup - search data entries for match
-----------------------------------------------------------------------
 INPUTS
   edi = ptr to search string
   ecx = search match size
         if string set ecx negative (checks for zero termination)
   edx = search offset into table entry.
         note: The hash is computed for byte zero of each
         table entry.  if edx is non zero we can not
         use the computed hash, and a non-hash lookup
         is used.  This will be slower because every
         entry will be searched, starting at top of table.          
 OUTPUT
   eax=0 if success, -1 if failure to match
   esi=ptr to match entry if eax=0
          
 OPERATION

 NOTES
    source file: hash_lookup.asm
                     

-----------------------------------------------------------------------
181 hash_lookup_next - search for another match
-----------------------------------------------------------------------
 INPUTS
   esi = ptr to last match          
 OUTPUT
   eax=0 if success, -1 if failure to match
   esi=ptr to match entry if eax=0
          
 OPERATION
   The hash chains are not sorted, so to find duplicate
   entries this functions is used.
 NOTES
    source file: hash_lookup.asm
                     

-----------------------------------------------------------------------
182 hash_remove - remove one entry from data set
-----------------------------------------------------------------------
 INPUTS
   edi = ptr to search string
   ecx = search match size
         set ecx negative if string (zero termination checked)
   edx = search offset into entry (0=first byte compared)
         note: if edx is non zero a non-hash lookup
         is used.  This will be slower because every
         entry will be searched, starting at top of table.          
         
 OUTPUT
    eax = 0 if successful
 OPERATION
    hash_remove does not reclaim memory and should not
    be used if numerous deletes are needed.  If the data
    is written to disk it will retain the hole left
    by removed entries.

 NOTES
    source file: hash_remove.asm
                     

-----------------------------------------------------------------------
183 hash_setup - prepare hash table for use
-----------------------------------------------------------------------
    Hash tables are used for fast access to data.
    Tables of symbols or other ascii strings can
    be hashed or other data groups.
    hash_setup is called once at the beginning
    of a program.

 INPUTS
    edi = ptr to start of buffer area. (holds data and hash)
    ecx = end of buffer ptr (beyond last available location)
     al = hash mask 01h,03h,07h,0fh,1fh,3fh,7fh,0ffh
    ebx = minimum hash entry size, search for
          zero at end of entry begins at start+ebx

    note: It is possible to hash complex records or fixed
          or variable length.  The only constraints are
          that variable data be at the end and not contain
          any zeros.  To include data with zero bytes, put
          it at the front of a entry and set -ebx- to skip
          over it.  Another constraint is that the first
          byte is used as a hash key.  This works for
          symbol tables where the address is first but may
          not work with other data sets.          
 OUTPUT
    global variables [hash_table_ptr] used internally
                     [hash_buffer_end] used internally
          
 OPERATION
    The hash pointers are set to zero and table pointer
    saved for other functions.  Only one hash table can
    be in use so only one pointer is kept.  The hash table
    is followed by data entries and they must be
    included in the buffer size.  The entries are assumed
    to be terminated by a zero byte.  The search for an
    entry end begins at the minimum entry size and continues
    until a zero byte is found.

    A typical symbol table entry could be constructed
    as:
        dd <adr>  ;address of symbol
        db <string> ;ascii label
        db 0        ;end of label

    The hash functions add a chain dword to front of
    each entry, but this isn't usually of interest to
    users.  Internally, a hash pointer table is built
    which points to chains of data entries.

    The first byte of a hash entry is used as the
    hash key.  A hash ponter table will require 2
    dwords if a mask of 01h is used. (see table below)

    To avoid huge hash tables it is a good idea to choose
    a mask with few bits set.  The legal mask values are:
    0ffh,07fh,03fh,01fh,0fh,07h,03h,01h

    The buffer size provided to hash functions needs to
    hold the hash table and all the data entries.  Each
    data entry has an additional 4 bytes added for the
    chain.  The hash table size can be found from the
    following table:

    hash      table-size  
    mask      (bytes)     
    -------   ------------
      01h      8          
      03h      16         
      07h      32         
      0fh      64         
      1fh      128        
      3fh      256        
      7fh      512        
      ffh      1024       

   To  create a in memory hash database use:
        hash_setup - create structures
        hash_add   - add entries
        hash_remove - remove entries
        hash_lookup - find entries

   To  write a in memory hash database to file:
        hash_archive -  write data to file

   To  read a hash file into memory use:
        hash_restore - open,read,setup hash,close

 NOTES
    source file: hash_setup.asm
                     

-----------------------------------------------------------------------
184 hashfile_archive - write current hash data to open file
-----------------------------------------------------------------------
 INPUTS
    ebx = hashfile name path
    [hash_table_ptr] - set by hashfile_setup or
                       hashfile_restore
 OUTPUT
    eax=0 if success, else negative error code
          
 OPERATION
    First the hash file internal pointers are converted
    to offsets relative to top of hash table.  The file
    is then written to disk as a relocatable data file.
    Finally, the in memory hash file is modfied and the
    offsets changed back to pointers

 NOTES
    source file: hashfile_archive.asm
                     

-----------------------------------------------------------------------
185 hashfile_restore - read open hash file into buffer
-----------------------------------------------------------------------
 INPUTS
  ebx = hash file path
  ecx = buffer
  edx = buffer length
 OUTPUT
    eax = bytes read if success, else negative error code
    [hash_table_ptr] - initialized by hashfile_restore
          
 OPERATION

 NOTES
    source file: hashfile_restore.asm
                     

-----------------------------------------------------------------------
186 record_add - add entries to record table
-----------------------------------------------------------------------
 INPUTS
  eax = dword key (unique value to identify record,
        low four bits are used for hash.
  esi = ptr to record
  note: function record_setup must be called before
        using this function.         
 OUTPUT
    sign bit set for "jns" if near end of buffer
                      js if buffer has over 100 bytes free 
          
 NOTES
    source file: record.asm
                     

-----------------------------------------------------------------------
187 record_archive - write current hash data to open file
-----------------------------------------------------------------------
 INPUTS
    ebx = hashfile name path
    [record_base_ptr] - set by record_setup or
                       record_restore
 OUTPUT
    eax=0 if success, else negative error code
          
 NOTES
    source file: record.asm
                     

-----------------------------------------------------------------------
188 record_lookup - search records for key
-----------------------------------------------------------------------
 INPUTS
   eax = key
 OUTPUT
   ecx=0 if failure
   esi=ptr to record if key matches
   registers ebx,ecx modified

 OPERATION

 NOTES
    source file: record.asm
                     

-----------------------------------------------------------------------
189 record_restore - read open hash file into buffer
-----------------------------------------------------------------------
 INPUTS
  ebx = hash file path
  ecx = buffer
  edx = buffer length
 OUTPUT
    eax = bytes read if success, else negative error code
    [record_base_ptr] - initialized by hashfile_restore
          
 OPERATION

 NOTES
    source file: record.asm
                     

-----------------------------------------------------------------------
190 record_setup - prepare record table for use
-----------------------------------------------------------------------
    Hash tables are used for fast access to data.
    record_setup is called once at the beginning
    of a program.

 INPUTS
    edi = ptr to start of buffer area. (holds data and record)
    ecx = buffer size
    eax = record size

 OUTPUT
    global variables [record_base_ptr] same as input (edi)
                     [free_record_offset] used internally
                     [buffer_end_offset] same as input (ecx)
    registers eax,ecx,edi modified
          
 OPERATION
    The hash pointers are set to zero and table pointer
    saved for other functions.  Only one hash table can
    be in use so only one pointer is kept.  The hash table
    is followed records.  record entries are assumed to
    be terminated by a zero byte.

    The record functions add a chain dword to front of
    each entry, but this isn't usually of interest to
    users.  Internally, a hash pointer table is built
    which points to chains of data entries.

    A record record consists of:
           1. dword chain (offset)
           2. dword key
           3. record

    The buffer size provided to record functions needs to
    hold the hash table and all the data entries.  Each
    data entry has an additional 4 bytes added for the
    chain.

   To  create a in memory record database use:
        record_setup - create structures
        record_add   - add entries
        record_lookup - find entries

   To  write the database to file:
        record_archive -  write data to file

   To  read the database into memory use:
        record_restore - open,read,setup hash,close

 NOTES
    source file: records.asm
                     

-----------------------------------------------------------------------
191 string_add - add entries to string table
-----------------------------------------------------------------------
 INPUTS
  eax = dword key (unique value to identify string,
        low four bits are used for hash.
  esi = ptr to string
  note: function string_setup must be called before
        using this function.         
 OUTPUT
    sign bit set for "jns" if near end of buffer
                      js if buffer has over 100 bytes free
    esi = ptr to end of string 
          
 NOTES
    source file: string.asm
                     

-----------------------------------------------------------------------
192 string_archive - write current hash data to open file
-----------------------------------------------------------------------
 INPUTS
    ebx = hashfile name path
    [hash_base_ptr] - set by string_setup or
                       string_restore
 OUTPUT
    eax=0 if success, else negative error code
          
 NOTES
    source file: string.asm
                     

-----------------------------------------------------------------------
193 string_lookup - search strings for key
-----------------------------------------------------------------------
 INPUTS
   eax = key
 OUTPUT
   ecx=0 if failure
   esi=ptr to string if key matches
   registers ebx,ecx modified

 OPERATION

 NOTES
    source file: string.asm
                     

-----------------------------------------------------------------------
194 string_restore - read open hash file into buffer
-----------------------------------------------------------------------
 INPUTS
  ebx = hash file path
  ecx = buffer
  edx = buffer length
 OUTPUT
    eax = bytes read if success, else negative error code
    [hash_base_ptr] - initialized by hashfile_restore
          
 OPERATION

 NOTES
    source file: string.asm
                     

-----------------------------------------------------------------------
195 string_setup - prepare string table for use
-----------------------------------------------------------------------
    Hash tables are used for fast access to data.
    string_setup is called once at the beginning
    of a program.

 INPUTS
    edi = ptr to start of buffer area. (holds data and string)
    ecx = buffer size

 OUTPUT
    global variables [hash_base_ptr] same as input (edi)
                     [free_packet_offset] used internally
                     [buf_end_offset] same as input (ecx)
    registers eax,ecx,edi modified
          
 OPERATION
    The hash pointers are set to zero and table pointer
    saved for other functions.  Only one hash table can
    be in use so only one pointer is kept.  The hash table
    is followed strings.  String entries are assumed to
    be terminated by a zero byte.

    The string functions add a chain dword to front of
    each entry, but this isn't usually of interest to
    users.  Internally, a hash pointer table is built
    which points to chains of data entries.

    A string record consists of:
           1. dword chain (offset)
           2. dword key
           3. string

    The buffer size provided to string functions needs to
    hold the hash table and all the data entries.  Each
    data entry has an additional 4 bytes added for the
    chain.

   To  create a in memory string database use:
        string_setup - create structures
        string_add   - add entries
        string_lookup - find entries

   To  write a in memory hash database to file:
        string_archive -  write data to file

   To  read a hash file into memory use:
        string_restore - open,read,setup hash,close

 NOTES
    source file: strings.asm
                     

-----------------------------------------------------------------------
196 event_close - close program events
-----------------------------------------------------------------------
 INPUT
   none
 OUTPUT
   none
 NOTE
   source file = event_close.asm

-----------------------------------------------------------------------
197 event_setup - set program events
-----------------------------------------------------------------------
 INPUT
  eax = signal_mask, signals to setup.  If set to -1
        all possible signals will be set up.  It will
        still be necessary to call routines that attach
        to signals, such as key_setup and signal_attach.
  dl = keyboard flag, if set=1 then SIGIO handles keyboard
  ebp = abort signal code ptr to handle cleanup and exit.
        This value is stored at [abort_signal_jmp]
        Set ebp=0 to avoid calling our program (the kernels
        default handler will abort the program).  The abort
        signals are listed next, plus SIGPWR.
    abort signals (signal_flag+0)
        00 00 00 01 bit 0 SIGFPE math error
        00 00 00 02     1 SIGPIPE pipe error
        00 00 00 04     2 SIGTERM user terminate request
        00 00 00 08     3 SIGILL illegal instruction
        00 00 00 10     4 SIGBUS illegal memory address
        00 00 00 20     5 SIGSEGV segment (memory) fault
        00 00 00 40     6 SIGXCPU cpu time limit expire
        00 00 00 80     7 SIGXFSZ file size too big
    ignore sigals (signal_flag+1)
        00 00 01 00 bit 8  SIGQUIT keyboard quit key
        00 00 02 00     9  SIGTSTP keyboard syspend key
        00 00 04 00     10 SIGTTIN background process reading
        00 00 08 00     11 SIGTTOU background process writing
        00 00 10 00     12 SIGABORT abort key (ctrl-a?)
    info signals (signal_flag+2)
        00 01 00 00 bit 16 SIGCHLD child died
        00 02 00 00     17 SIGWINCH terminal resize
        00 04 00 00     18 SIGTRAP breakpoint/trap occured
        00 08 00 00     19 SIGUSR1 event #1, user assigned
        00 10 00 00     20 SIGUSR2 event #2, user assigned
        00 20 00 00     21 SIGALRM alarm/timer event
        00 40 00 00     22 SIGURG urgent socket event
        00 80 00 00     23 SIGIO key available
    other signals (signal_flag+3)
        01 00 00 00 bit 24 SIGINT control c typed
        02 00 00 00     25 SIGHUP termnal not available
        04 00 00 00     26 VTALRM virtual alarm
        08 00 00 00     27 SIGPROF profile timer
        10 00 00 00     28 SIGPWR power fail (abort signal)
 
 OUTPUT
   eax = results of request
         0 = success
       -22 = EINVAL An invalid signal was specified.
       -14 = EFAULT memory error
       -4  = EINTR  System call was interrupted.

 NOTE
   source file = event_setup.asm

-----------------------------------------------------------------------
198 key_check - check if key available, but do not read it
-----------------------------------------------------------------------
 INPUT
   we must be in raw mode
 OUTPUT
   ecx=zero if no keys
   ecx=ptr to key string if key avail.
 NOTE
    source file key_check.asm
    he "key" routines work together and other keyboard
    functions should be avoided.  The "key" family is:
    key_fread - flush and read
    key_read - read key
    key_check - check if key avail.
    key_put - push a key back to buffer

-----------------------------------------------------------------------
199 key_decode - decode key and return handler
-----------------------------------------------------------------------
 INPUT
   ecx = key string ptr
   esi = decode table
 OUTPUT
   eax = process pointer, or zero if key not found
 NOTE 
   source file key_decode.asm

-----------------------------------------------------------------------
200 key_flush - flush any pending keys
-----------------------------------------------------------------------
 INPUT
   event_setup must be called first to set
   keyboard in raw mode to flush keys
 OUTPUT
   none
 NOTE 
   source file key_read.asm
   The "key" routines work together and other keyboard
   functions should be avoided.  The "key" family is:
   key_fread - flush and read
   key_read - read key
   key_check - check if key avail.
   key_put - push a key back to buffer

-----------------------------------------------------------------------
201 key_put - insert key back into buffer
-----------------------------------------------------------------------
  we can put a max of two key strings, each a max of 13 bytes
  Strings are pushed on top of key stack. 
 INPUT
   eax=ptr to key string (zero terminated)
 OUTPUT
   none
 NOTE
   source file key_put.asm

-----------------------------------------------------------------------
202 key_remove - delete key in ks1 buffer
-----------------------------------------------------------------------
 INPUT
   keyboard must be in raw mode to read individual
   keys.  See key_raw and key_unraw funtions.
 OUTPUT
   ecx=ptr to key string or zero if no keys avail
     if mouse press, key string format is:
        ff,bb,cc,rr (flag,button,column,row)
        where: ff =   -1 (byte)
               bb =   (byte) 0=left but  1=middle 2=right 3=release
               cc =   binary column (byte)
               rr =   binary row (byte)
 NOTE
      source file key_read.asm

-----------------------------------------------------------------------
203 key_setup - setup signal driven key handling
-----------------------------------------------------------------------
 INPUT
   none
 OUTPUT
   none
 NOTE
   source file key_setup.asm
   The "key" routines work together and other keyboard
   functions should be avoided.  The "key" family is:
   key_fread - flush and read
   key_read - read key
   key_check - check if key avail.
   key_put - push a key back to buffer

-----------------------------------------------------------------------
204 signal_attach - set action for signal
-----------------------------------------------------------------------
 INPUT
  eax = signal# to attach
        SIGIO used by key_setup, other choices
        are SIGURG,SIGUSR1,SIGUSR2
  ebx = fd to attach
  ecx = signal mask in signal_mask format (see signal.inc)
   dl = 0 if not SIGIO or keyborad handling not wanted, 1=keyboard sigio
 OUTPUT
   al = results of request, jns=success js=error
         0 = success
       -22 = EINVAL An invalid signal was specified.
       -14 = EFAULT memory error
       -4  = EINTR  System call was interrupted.

 NOTE
   source file = signal_attach.asm


-----------------------------------------------------------------------
205 list_check_end - check list end, do not remove
-----------------------------------------------------------------------
 INPUTS
    edx = llst control block
      struc list
      .list_buf_top_ptr resd 1
      .list_buf_end_ptr resd 1
      .list_entry_size resd 1
      .list_start_ptr resd 1
      .list_tail_ptr resd 1
      endstruc

 OUTPUT:
    flag set (jns) if entry found
      esi = ptr to data
      eax = 0
      edx,ebp unchanged
    flag set (js) if no data on list
      esi,edx,ebp  unchanged
      eax = -1 
        
 NOTES
   source file: list_check_end.asm
   A full list will have a one entry gap
   between the list_start_ptr and list_tail_ptr.
   The list pointers cycle around the buffer
   and entries can be removed from start or
   end of list.

   see also: list_put_at_front
             list_put_at_end
             list_first_out

-----------------------------------------------------------------------
206 list_check_front - check list top, do not remove entry
-----------------------------------------------------------------------
 INPUTS
    edx = list control block
      struc list
      .list_buf_top_ptr resd 1
      .list_buf_end_ptr resd 1
      .list_entry_size resd 1
      .list_start_ptr resd 1
      .list_tail_ptr resd 1
      endstruc

 OUTPUT:
    flag set (jns) if success
      esi = ptr to data
      eax = 0
      edx,ebp unchanged
    flag set (js) if no data on list
      eax=-1
      edx,ebp  unchanged 
        
 NOTES
   source file: list_check_front.asm
   A full list will have a one entry gap
   between the list_start_ptr and list_tail_ptr.
   The list pointers cycle around the buffer
   and entries can be removed from start or
   end of list.

-----------------------------------------------------------------------
207 list_get_from_end - return last list entry
-----------------------------------------------------------------------
 INPUTS
    edx = llst control block
      struc list
      .list_buf_top_ptr resd 1
      .list_buf_end_ptr resd 1
      .list_entry_size resd 1
      .list_start_ptr resd 1
      .list_tail_ptr resd 1
      endstruc

    Initially a empty list could be created
    as follows by caller:
       dd buffer     ;top of buffer
       dd buffer_end ;end of buffer
       dd x          ;each entry x bytes long
       dd buffer     ;first entry ptr
       dd buffer     ;last entry ptr


 OUTPUT:
    flag set (jns) if success
      esi = ptr to data
      edx,ebp unchanged
    flag set (js) if no data on list
      esi,edx,ebp  unchanged 
        
 NOTES
   source file: list_get_from_end.asm
   A full list will have a one entry gap
   between the list_start_ptr and list_tail_ptr.
   The list pointers cycle around the buffer
   and entries can be removed from start or
   end of list.

   see also: list_put_at_front
             list_put_at_end
             list_first_out

-----------------------------------------------------------------------
208 list_get_from_front - return entry from top of list
-----------------------------------------------------------------------
 INPUTS
    edx = list control block
      struc list
      .list_buf_top_ptr resd 1
      .list_buf_end_ptr resd 1
      .list_entry_size resd 1
      .list_start_ptr resd 1
      .list_tail_ptr resd 1
      endstruc

 OUTPUT:
    flag set (jns) if success
      esi = ptr to data
      edx,ebp unchanged
    flag set (js) if no data on list
      edx,ebp  unchanged 
        
 NOTES
   source file: list_get_from_front.asm
   A full list will have a one entry gap
   between the list_start_ptr and list_tail_ptr.
   The list pointers cycle around the buffer
   and entries can be removed from start or
   end of list.

-----------------------------------------------------------------------
209 list_put_at_end - add entry to end of list
-----------------------------------------------------------------------
 INPUTS
    edx = list control block
      struc list
      .list_buf_top_ptr resd 1
      .list_buf_end_ptr resd 1
      .list_entry_size resd 1
      .list_start_ptr resd 1
      .list_tail_ptr resd 1
      endstruc

    Initially the control block for a empty
    list could be set as follows by caller:
       dd buffer     ;top of buffer
       dd buffer_end ;end of buffer
       dd x          ;each entry x bytes long
       dd buffer     ;first entry ptr
       dd buffer     ;last entry ptr

    esi = ptr to data of length
          liss_entry_size

 OUTPUT:
    flag set (jns) if success
      esi = will be advanced by size of entry
      edx,ebp unchanged
    flag set (js) if no room
      esi,edx,ebp  unchanged 

    if data wraps in buffer, the global
    [last_buf_put_at_end_adr] will be set        
 NOTES
   source file: list_put_at_end.asm
   A full list will have a one entry gap
   between the list_start_ptr and list_tail_ptr.
   The list pointers cycle around the buffer
   and entries can be removed from start or
   end of list.

-----------------------------------------------------------------------
210 list_put_at_front - add entry to front of list
-----------------------------------------------------------------------
 INPUTS
    edx = list control block
      struc list
      .list_buf_top_ptr resd 1
      .list_buf_end_ptr resd 1
      .list_entry_size resd 1
      .list_start_ptr resd 1
      .list_tail_ptr resd 1
      endstruc

    Initially the control block for a empty
    list could be set as follows by caller:
       dd buffer     ;top of buffer
       dd buffer_end ;end of buffer
       dd x          ;each entry x bytes long
       dd buffer     ;first entry ptr
       dd buffer     ;last entry ptr

    esi = ptr to data of length
          liss_entry_size

 OUTPUT:
    flag set (jns) if success
      esi = will be advanced by size of entry
      edx,ebp unchanged
    flag set (js) if no room
      esi,edx,ebp  unchanged 

    if data wraps in buffer, the global
    [last_buf_put_adr] will be set        
 NOTES
   source file: list_put_at_front.asm
   A full list will have a one entry gap
   between the list_start_ptr and list_tail_ptr.
   The list pointers cycle around the buffer
   and entries can be removed from start or
   end of list.

-----------------------------------------------------------------------
211 pop_dword - remove dwort from top of list
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    if no carry, eax = popped value
    if    carry, at top of list
 NOTES
   source file: put_pop_dword.asm
   this function works with:
      put_pop_dword_setup - defines list
      put_dword  - adds dword to list top
      pop_dword  - returns dword from top

-----------------------------------------------------------------------
212 pop_string - return string at top of list
-----------------------------------------------------------------------
 INPUTS
    edi = buffer to hold string
 OUTPUT
    if no-carry edi points at end of string (zero byte)
    if    carry (at top of list, no string available)
 NOTES
   source file: put_pop_string.asm
   This function works with:
     put_pop_string_setup  - defines list
     put_string - adds string to top of list
     pop_string - extracts string from top

-----------------------------------------------------------------------
213 put_dword - add dword to top of list
-----------------------------------------------------------------------
 INPUTS
    eax = dword value added to list
 OUTPUT
    none (no  registers changed)
 NOTES
   source file: put_pop_dword.asm
   this function works with:
      put_pop_dword_setup - defines list
      put_dword  - adds dword to list top
      pop_dword  - returns dword from top

-----------------------------------------------------------------------
214 put_pop_dword_setup - setup dword list
-----------------------------------------------------------------------
 INPUTS
    eax = buffer ptr (will hold list)
 OUTPUT
    none (no  registers changed)
 NOTES
   source file: put_pop_dword.asm
   this function works with:
      put_pop_dword_setup - defines list
      put_dword  - adds dword to list top
      pop_dword  - returns dword from top

-----------------------------------------------------------------------
215 put_pop_string_setup - setup string list
-----------------------------------------------------------------------
 INPUTS
    eax = buffer ptr (will hold list)
 OUTPUT
    none (no  registers changed)
 NOTES
   source file: put_pop_string.asm
   This function works with:
     put_pop_string_setup  - defines list
     put_string - adds string to top of list
     pop_string - extracts string from top

-----------------------------------------------------------------------
216 put_string - add string to top of list
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to string
 OUTPUT
    esi points to end of string (past zero)
 NOTES
   source file: put_pop_string.asm
   This function works with:
     put_pop_string_setup  - defines list
     put_string - adds string to top of list
     pop_string - extracts string from top

-----------------------------------------------------------------------
217 buffer_hex - build hex line plus ascii in buffer
-----------------------------------------------------------------------
 INPUTS
    ecx = dump length (reduced by 16 each call)
    esi = ptr to binary data 
    edi = output buffer ptr
 OUTPUT:
    edi = advanced to 0ah at end of buffer
    esi = advanced by 16
    ecx = decreased by 16
    flags = state after ecx decremented by 16
 NOTES
   source file: buffer_hex.asm

-----------------------------------------------------------------------
218 buffer_hex_line - dump hex line to buffer
-----------------------------------------------------------------------
 INPUTS
    ecx = dump length
    esi = ptr to binary data
    edi = buffer ptr
    edx = flag 0=no ascii append 1=ascii append
 OUTPUT:
 NOTES
   source file: buffer_hex_line.asm

-----------------------------------------------------------------------
219 err_msg - display error messages
-----------------------------------------------------------------------
 INPUTS
     eax = error number (binary + or -)
 OUTPUT
    dipplay is cleared and message displayed
 NOTES
    file: /err/err_msg.asm
    operation: clears screen, displays message, waits for key

-----------------------------------------------------------------------
220 err_number - display error number
-----------------------------------------------------------------------
 INPUTS
    eax = error number (either + or -)
 OUTPUT
    none
 NOTES
    clear screen, displays error number, waits for any key

-----------------------------------------------------------------------
221 hex_dump_file - dump hex to file
-----------------------------------------------------------------------
 INPUTS
    ecx = dump length
    ebx = open file descriptor (fd)
    esi = ptr to binary data
 OUTPUT:
 NOTES
   source file: hex_dump.asm

-----------------------------------------------------------------------
222 hex_dump_stdout - dump hex to stdout
-----------------------------------------------------------------------
 INPUTS
    ecx = dump length
    esi = ptr to binary data
 OUTPUT:
 NOTES
   source file: hex_dump.asm

-----------------------------------------------------------------------
223 install_signals - install signals
-----------------------------------------------------------------------
 INPUTS
     ebp = pointer to  table describing each signal to install.
     The table is terminated with a zero byte in the signal number
     field.
       Sanple table entry for to install the SIGILL signal.
     db 4			;signal illegal action SIGILL
     dd handleIll		;handler for signal
     dd 0
     dd 4			;set siginfo telling kernel to pass status data to handler
     dd 0			;always zero
   
 NOTES
    See file /err/install_signals for more documentation.

-----------------------------------------------------------------------
224 log_eol - write eol (end of line) to "log"
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    none (all registers unchaged)
    file "log" will have eol (0ah) appended to end
 NOTES
    source file: log.asm

-----------------------------------------------------------------------
225 log_fd - log status of file descriptor
-----------------------------------------------------------------------
 INPUTS
    eax = fd (file descriptor)
 NOTES
    source file: log_fd.asm

-----------------------------------------------------------------------
226 log_hex - write hex to file called "log"
-----------------------------------------------------------------------
 INPUTS
    eax = binary number for log file
          (converted to hex ascii then written)
 OUTPUT
    none (all registers unchanged)
    file "log" will have <space>number<space> appended.
 NOTES
    source file: log.asm

-----------------------------------------------------------------------
227 log_num - write number to file called "log"
-----------------------------------------------------------------------
 INPUTS
    eax = binary number for log file
          (convert to decimal ascii then written)
 OUTPUT
    none (all registers unchanged)
    file "log" will have <space>number<space> appended.
 NOTES
    source file: log.asm

-----------------------------------------------------------------------
228 log_process_info - log process pid,ppid,gid,pgid
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    none
 NOTES
    source file: log_process_info.asm

-----------------------------------------------------------------------
229 log_regtxt - write string in -eax- to file called "log"
-----------------------------------------------------------------------
 INPUTS
    eax = 4 character ascii string
 OUTPUT
    none (all registers unchanged)
    file "log" will have string appended to end
 NOTES
    source file: log.asm

-----------------------------------------------------------------------
230 log_signals - install signal logging
-----------------------------------------------------------------------
 INPUTS
    eax = 1 to enable logging messages to file "log"
        = 0 to disable logging messages to file "log"
    ebx = optional pointer to local signal handler.  It
          is called each time a non-fatal signal occurs.
          Set ebx=0 if no handler is needed.
 OUTPUT
    handler called if provided and enabled (see below)
    global dword [signal_flag] is set to indicate signal
    occured.  Bits are "or"ed into signal_flag each time a
    signal occurs.  The flag can be cleared by user.  The
    library function does not check signal_flag.
     
    If the caller provided handler is called the following
    registers are set:
      eax = signal number
      esi = pointer to signal name string
     
      signal actions are as follows:
     
      name - number logged  handler called            signal_flag bit
    -------  ------ ------  --------------            ---------------
     SIGHUP     1    yes    yes                            0x00000001
     SIGINT     2    yes    yes                            0x00000002
     SIGQUIT    3    yes    yes                            0x00000004
     SIGILL     4    yes    no (log_signal aborts program) -
     SIGTRAP    5    yes    yes                            0x00000010
     SIGABRT    6    yes    no (log_signal aborts program) 0x00000020
     SIGIOT     6    yes    no (log_signal aborts program) 0x00000020
     SIGBUS     7    yes    yes                            0x00000040
     SIGFPE     8    yes    no (log_signal aborts program) 0x00000080
     SIGKILL    9     no    no                             -
     SIGUSR1    10   yes    yes                            0x00000200
     SIGSEGV    11   yes    no (log_signal aborts program) 0x00000400
     SIGUSR2    12   yes    yes                            0x00000800
     SIGPIPE    13   yes    yes                            0x00001000
     SIGALRM    14   yes    yes                            0x00002000
     SIGTERM    15   yes    no (log_signal aborts program) 0x00004000
     SIGSTKFLT  16   yes    yes                            0x00008000
     SIGCHLD    17   yes    yes                            0x00010000
     SIGCONT    18   yes    yes                            0x00020000
     SIGSTOP    19    no    no                             -
     SIGTSTP    20   yes    yes                            0x00080000
     SIGTTIN    21   yes    yes                            0x00100000
     SIGTTOU    22   yes    yes                            0x00200000
     SIGURG     23   yes    yes                            0x00400000
     SIGXCPU    24   yes    yes                            0x00800000
     SIGXFSZ    25   yes    yes                            0x01000000
     SIGVTALRM  26   yes    yes                            0x02000000
     SIGPROF    27   yes    yes                            0x04000000
     SIGWINCH   28   yes    yes                            0x08000000
     SIGIO      29   yes    yes                            0x10000000
 NOTES
    source file: log_signals.asm
     
    This function can be used for testing or as a
    signal handler.  Function "err_signal_install"
    is also available and allows more flexability.

-----------------------------------------------------------------------
231 log_str - write string to file called "log"
-----------------------------------------------------------------------
 INPUTS
    esi = string ptr for log file
 OUTPUT
    none (all registers unchaged)
    file "log" will have string appended to end
 NOTES
    source file: log.asm

-----------------------------------------------------------------------
232 log_terminal_0 - log termios and win size for stdin
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   none
 NOTES
   source file log_terminal.asm

-----------------------------------------------------------------------
233 log_terminal_x - log termios and win size for stdin
-----------------------------------------------------------------------
 INPUTS
    ebx = fd (file descriptor)
 OUTPUT
   none
 NOTES
    source file log_terminal.asm

-----------------------------------------------------------------------
234 show_hex - display assorted hex numbers using control table
-----------------------------------------------------------------------
 INPUTS
    eax = fd (1=stdout) 
    esi = control  table

    The control table is normal ascii with embedded
    codes to indicate where numbers are needed.  Numbers
    are shown in hex.
    Embedded codes: -1 = ptr to byte follows
                    -2 = ptr to word follows
                    -3 = ptr to dword follows
                    -4 = actual byte follows
                    -5 = actual word follows
                    -6 = actual dword follows
                    -7 = dmp byte block  | dd count, dd ptr
                    -8 = dmp word block  | dd count, dd ptr
                    -9 = dmp dword block | dd count, dd ptr
                   -10 = ptr to string follows
                     0 = end of string or end of table if
                         not processng string

 OUTPUT
   uses current color, see crt_set_color, crt_clear
 EXAMPLE TABLE
   db 'hex byte =',0
   db -1	;ptr to hex byte follows
   dd hex_here ;ptr to hex data
   db 'hex word =',0
   db -2	;ptr to hex word follows
   dd word_here ;ptr to hex data
   db 0 ;end of table
 NOTES
   source  file show_hex.asm

-----------------------------------------------------------------------
235 write_char_to_file - write byte to open fd
-----------------------------------------------------------------------
 INPUTS
    al = byte to write
    ebx = open fd
 OUTPUT:
    all registers preserved
 NOTES
   source file: write_char.asm

-----------------------------------------------------------------------
236 write_char_to_stdout - display ascii char
-----------------------------------------------------------------------
 INPUTS
    al = ascii char
 OUTPUT:
    ebx set to 1 for stdout
 NOTES
   source file: write_char.asm

-----------------------------------------------------------------------
237 write_hex_byte_stdout - display hex char
-----------------------------------------------------------------------
 INPUTS
    al = binary for conversion to hex
 OUTPUT:
    ebx = 1 for stdout
 NOTES
   source file: write_hex.asm

-----------------------------------------------------------------------
238 write_hex_byte_to_file - write hex for byte to file
-----------------------------------------------------------------------
 INPUTS
    al = binary for conversion to hex char
    ebx = open file fd
 OUTPUT:
 NOTES
   source file: write_hex.asm

-----------------------------------------------------------------------
239 write_hex_line_stdout - dump hex line to stdout
-----------------------------------------------------------------------
 INPUTS
    ecx = dump length
    esi = ptr to binary data
 OUTPUT:
 NOTES
   source file: write_hex_line.asm

-----------------------------------------------------------------------
240 write_hex_line_to_file - dump hex line to file
-----------------------------------------------------------------------
 INPUTS
    ebx = open file fd
    ecx = dump length
    esi = ptr to binary data
 OUTPUT:
 NOTES
   source file: write_hex_line.asm

-----------------------------------------------------------------------
241 dword_divide - divide 32 bit values
-----------------------------------------------------------------------
 INPUTS
   edx,eax divided by ebx;
 OUTPUT:
   eax = result
   edx = remainder
 NOTES
   source file: dword_divide.asm
   this routine avoids the div error signal

-----------------------------------------------------------------------
242 quad_add - add 64 bit values
-----------------------------------------------------------------------
 INPUTS
    edx,eax = value 1
    ecx,ebx = value 2
 OUTPUT:
    edx,eax = result
           carry set if overflow
 NOTES
   source file: quad_add.asm

-----------------------------------------------------------------------
243 quad_compare - unsigned 64 bit compare
-----------------------------------------------------------------------
 INPUTS
          ax,bx = first number
          cx,dx = second number
 OUTPUT:
           zf (zero flag) = 1 if equal
           if 1 greater than 2  zf=0 and carry=0
           if 1 less than 2     zf=0 and carry=1
           registers are unchanged
 NOTES
   source file: quad_compare.asm

-----------------------------------------------------------------------
244 quad_divide - divide 64 bit values
-----------------------------------------------------------------------
 INPUTS
   edx,eax divided by ebx;
 OUTPUT:
   edx,eax = result
 NOTES
   source file: quad_divide.asm

-----------------------------------------------------------------------
245 quad_multiply - multiply 64 bit values
-----------------------------------------------------------------------
 INPUTS
   edx,eax = value 1
   ecx,ebx = value 2
 OUTPUT:
   edx,ecx,ebx,eax = result
 NOTES
   source file: quad_multiply.asm

-----------------------------------------------------------------------
246 quad_negate - negate 64 bit values
-----------------------------------------------------------------------
 INPUTS
   edx,eax = number
 OUTPUT:
   edx,eax negated
 NOTES
   source file: quad_negate.asm

-----------------------------------------------------------------------
247 quad_subtract - subtract 64 bit values
-----------------------------------------------------------------------
 INPUTS
   edx,eax = value 1
   ecx,ebx = value 2
 OUTPUT:
   edx,eax = dx,ax - cx,bx
   carry set if overflow
 NOTES
   source file: quad_subtract.asm

-----------------------------------------------------------------------
248 chain_double - chain (add) to doubly linked list
-----------------------------------------------------------------------
             each link has two dwords at top, the forward
             pointer and back pointer.
  INPUTS     eax = ptr to new link
             ebx = ptr to insert point, any illegal value inserts
                   at end of chain. Typically -1 is insert at end.
                   Setting ebx to chain start will not create a new
                   start link, instead the link is placed after the
                   header link.  For this reason the header link is
                   usually a dummy pointer that is the start of chain.
             To start a new chain, create a dummy link and set
             it chain pointers (first dword) to zero and the second
             dword to zero.  The first dword is forward ptr and the
             second is back pointer
  OUTPUT
             no registers are changed.

             complete chain consists of a start link
             followed by a succession of pointers ending
             with a zero pointer.  Each link points to the
             next link.  A null chain has a start link of
             zero.  The last link has a forward pointer of
             zero.

  NOTE       source file is chain_double.asm
             Doubly linked lists are much faster to access
             but take more memory.


-----------------------------------------------------------------------
249 chain_single - chain (add) link to singly linked list
-----------------------------------------------------------------------
  INPUTS     eax = ptr to new link
             esi = ptr to chain start, used if edi=0
             ebx = ptr to insert point, any illegal value inserts
                   at end of chain. Typically -1 is insert at end.
                   Setting ebx to chain start will not create a new
                   start link, instead the link is placed after the
                   header link.  For this reason the header link is
                   usually a dummy pointer that is the start of chain.
             edi = ptr link preceeding the insert point if
                   known, else zero
             To start a new chain, create  initial link and set
             it chain pointer (first dword) to zero.  Insert the
             first link at the chain start and following links
             at normal insert point.
             zero and use it as chain start point
  OUTPUT
             eax,esi,edi  changed
             ebx          unchanged

             complete chain consists of a start link
             followed by a succession of pointers ending
             with a zero pointer.  Each link points to the
             next link.  A null chain has a start link of
             zero.  The last link has a forward pointer of
             zero.

  NOTE       source file is chain_single.asm
             Typical usage is to define a packet of information
             with the chain dword at top of each packet.  These
             packets can then be sorted or collected by inserting
             packets at the desired location.


-----------------------------------------------------------------------
250 m_allocate - provide memory to caller
-----------------------------------------------------------------------
             This function may be called after calling
             the m_setup function
  INPUTS     eax = size of allocation request in bytes

  OUTPUT     eax = positive memory address if successful
             eax = negative error code as following:
                   -1 can not allocate memory
                   -2 memory corrupted by caller.  This is
                      usually a memory leak that clobbered
                      the memory manager data area.
                 sign flag set for "js" or "jns"
  DESIGN     Each allocated area of memory requires overhead
             of 12 bytes for record keeping.  This data is
             placed in a header infront of each allocated
             memory block.  It can be accessed by programs
             but should not be modified.

             Memory managers are often blamed for program bugs
             and become corrupted if thier record keeping is hit
             my memory leaks.  To avoid these problems all headers
             are checksumed and if any corruption occurs the
             memory manager returns an error.

             This design favors reliability and security over
             speed, but is moderatly fast and frees the programmer
             from buffer management and overlap/fragmentation
             problems.

             The format of the header is:  struc header
                                           .prev_block_ptr  resd 1
                                           .block_size      resd 1
                                           .checksum        resd 1
                                           .memory ; (memory block start)
                                           endstruc

  NOTE       source file is memory.asm


-----------------------------------------------------------------------
251 m_close - release memory and disable memory manager
-----------------------------------------------------------------------
             This function also occurs if a program exits
             with a kernel exit function.
  INPUTS     eax = none

  OUTPUT     none

  NOTE       source file is memory.asm


-----------------------------------------------------------------------
252 m_release - release previously allocated memory
-----------------------------------------------------------------------
             This function may be called after calling
             the m_setup, and mem_allocate functions.
  INPUTS     eax = pointer to memory for release

  OUTPUT     eax = 0 if success
             eax = negative error code as following:
                   -1 can not release memory or
                      memory not found, this can be
                      caused by a bad input pointer (eax)
                      or by a memory leak that modified
                      a header used by memory manager.
                      See mem_allocate for a discusson
                      of headers.
                   -2 memory block already released and
                      available
             flags set for "js" or "jns"

  NOTE       source file is memory.asm


-----------------------------------------------------------------------
253 m_setup  - setup for memory manager use
-----------------------------------------------------------------------
             This function must be called before using
             any memory manager functions
  INPUTS     none 

  OUTPUT     none

  NOTE       source file is memory.asm
             calls memory_init to find start of memory

-----------------------------------------------------------------------
254 memory_init - get top of allocated memory
-----------------------------------------------------------------------
 INPUTS
  none
 OUTPUT
    eax = start adr for next allocation using brk
    ebx = first start address found by call to
          memory_init or zero if this is first
          call to memory_init
 NOTES
    source file: memory_init.asm
    This function returns the top of allocated
    memory.  Once the top is known, the brk kernel call
    can be used to allocate pieces of memory.

-----------------------------------------------------------------------
255 set_memory - adjust memory end point
-----------------------------------------------------------------------
             set_memory is a simple way of  managing memory for
             a program.  It uses the kernel "brk" call to extend
             or contract the .bss section end.
  INPUTS     ebx = new end point for executing program

  OUTPUT     eax = new end point if sucessful, or negative error

  NOTE       source file is set_memory.asm


-----------------------------------------------------------------------
256 shared_attach - attach to a shared memory segment
-----------------------------------------------------------------------
  INPUTS     ecx = "shmid" key returned from shared_open

  OUTPUT     eax = "address" needed to access memory or error
                   if failure.

  NOTE       source file:  shared_attach.asm

             This function is part of a family of functions
             that work together, including:
               shared_open   - open shared memory area
               shared_attach - connect to shared memory area
               shared_close - detach from shared memory
           
             The kernel selects address of shared memory and
             sets it to read/write.


-----------------------------------------------------------------------
257 shared_close - close a shared memory segment
-----------------------------------------------------------------------
  INPUTS     ecx = "shmid" key returned from shared_allocate

  OUTPUT     eax = zero if success, else -1 if failure.

  NOTE       source file:  shared_close.asm

             This function is part of a family of functions
             that work together, including:
               shared_open   - open shared memory area
               shared_attach - connect to shared memory area
               shared_close - detach from shared memory
           
             Each user of shared memory must execute this call.
             When the last user releases memory, it will be
             destroyed.


-----------------------------------------------------------------------
258 shared_open - open a shared memory segment
-----------------------------------------------------------------------

  INPUTS    ecx = A unique key used by all processes
                  to access shared memory, or if set to
                  zero (IPC_PRIVATE) this is a private
                  allocation, available to child after fork.
                  Warning, only first level children see
                  IPC_PRIVATE memory.  
            edx = number of bytes to allocate 
            esi = mode.
                  The first user of shared memory sets the
                  create bit and succeeding users leave the
                  create bit off.  The bits are:

                  IPC_CREAT=00001000q   - create initial segment
                  IPC_EXCL=00002000q    - give error if segment exists
                  owner read=00000400q 
                  owner write=00000200q
                  group read=00000040q
                  group write=00000020q
                  other read=00000004q
                  other write=00000002q

  OUTPUT     eax = "shmid key" needed to access memory or -1 if
                   failure.  key is called "shmid" in docs

  NOTE       source file:  shared_open.asm

             This function is part of a family of functions
             that work together, including:
               shared_open - open shared memory area
               shared_attach - connect to shared memory area
               shared_close - detach from shared memory
           
             The kernel selects address of shared memory and
             sets it to read/write.

             This function is used to create shared memory and
             by other processes to get the "shmid key" needed
             to access shared memory.  A typical operation:
               call shared_open ;create or ask for access to memory
               call shared_attach ;attach to shared memory
               (access memory here)
               call shared_close ;our process is done with memory

-----------------------------------------------------------------------
259 unchain_double - unchain (remove) link from doubly link list
-----------------------------------------------------------------------
             each link has two dwords at top, the forward
             pointer and back pointer.
  INPUTS     eax = ptr to link for removal

  OUTPUT
             no registers are changed.

             complete chain consists of a start link
             followed by a succession of pointers ending
             with a zero pointer.  Each link points to the
             next link.  A null chain has a start link of
             zero.  The last link has a forward pointer of
             zero.

  NOTE       source file is unchain_double.asm
             Doubly linked lists are much faster to access
             but take more memory.


-----------------------------------------------------------------------
260 unchain_single - unchain (remove) link from singly linked list
-----------------------------------------------------------------------
  INPUTS     esi = chain start, used if edi=0
             ebx = link to remove
             edi = link preceeding the removal point if
                   known, else zero
  OUTPUT     carry set = link was not found in chain
             if no carry then success
             ebx     = unchanged
             esi,edi = modified

             complete chain consists of a start link
             followed by a succession of pointers ending
             with a zero pointer.  Each link points to the
             next link.  A null chain has a start link of
             zero.

  NOTE       source file is unchain_single.asm


-----------------------------------------------------------------------
261 crt_mouse_line - display line in mouse_decode format
-----------------------------------------------------------------------
 INPUTS
    esi = menu line to display (see notes)
    ah = display row 1+
    (menu line always starts at column 1)
    ecx = color for spaces between buttons
    edx = color for buttons
     
    hex color def: aaxxffbb  aa-attr ff-foreground  bb-background
    30-blk 31-red 32-grn 33-brown 34-blue 35-purple 36-cyan 37-grey
    attributes 30-normal 31-bold 34-underscore 37-inverse
 OUTPUT
    menu line displayed
 NOTES
   file:  crt_mouse_line.asm  (see also mouse_line_decode.asm)
   The menu line has buttons separated by a number from 0-8.
   the number represents a count of spaces between buttons.
    example:
    line:  db "button1",2,"button2",3,"button3",0
    (zero  indicates end of line, 2=2 spaces)
   Colors are in standard format (see crt_color.asm)

-----------------------------------------------------------------------
262 key_decode1 - decode non-aplha key strings and get process
-----------------------------------------------------------------------
 INPUTS
    kbuf - global library buffer with key string
    esi = table of key strings and processes
          first table entry is alpha key process
          middle entries are non alpha keys
          final process is called if no match
    example
    dd	gs_normal_char ;alpha key process
    db 1bh,5bh,48h,0  ; pad_home
    dd gs_home        ; home process 
    db 1bh,5bh,44h,0  ; pad_left
    dd gs_left        ; left arrow process
    db 7fh,0          ; backspace
    dd gs_backspace   ; backspace process
    db 0              ;end of table
    dd no_match       ;no-match process
     
 OUTPUT
    eax = process pointer
 NOTES
   source file: key_decode.asm
   see also crt_open, mouse_enable

-----------------------------------------------------------------------
263 key_decode2 - decode aplha key strings and get process
-----------------------------------------------------------------------
 INPUTS
    esi = table of key strings and processes
    kbuf - global library buffer with alpha key
    example
    db "a"            ; a key
    dd a_process      ;
    db 'b'            ; b key
    dd b_process      ;
    db 0              ; end of table 
     
 OUTPUT
    eax = process pointer if no carry
          carry = key not found
 NOTES
   source file: key_decode.asm
   see also crt_open, mouse_enable

-----------------------------------------------------------------------
264 key_decode3 - decode non-aplha key strings and get process
-----------------------------------------------------------------------
 INPUTS
    kbuf - global library buffer with key string
    esi = table of key strings and processes
    example
    db 1bh,5bh,48h,0  ; pad_home
    dd gs_home        ; home process 
    db 1bh,5bh,44h,0  ; pad_left
    dd gs_left        ; left arrow process
    db 7fh,0          ; backspace
    dd gs_backspace   ; backspace process
    db 0              ;end of table
     
 OUTPUT
    eax = process pointer, or zero if key not found
 NOTES
   source file: key_decode3.asm
   see also crt_open, mouse_enable

-----------------------------------------------------------------------
265 menu_decode - decode menu key/mouse event
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to menu structure (see below)
    [kbuf] has key/mouse
     if kbuf starts with byte of -1 then
     it is a mouse click and following bytes are:
      button(0-3), column(1-x), row(1-x)
      button = 0=left 1=middle 2=right 3=release
 OUTPUT
    eax = process or negative if no match
          js/jns flag set
 OPERATION
    The event in "kbuf" is compared to each menu line
    line description.  If a match is found the specified
    process is returned.

    The normal sequence of events is:

      mov	esi,menu_line_ptrs
      call	menu_display		;display menu
      call	read_stdin		;wait for event, ->kbuf
      mov	esi,menu_line_ptrs
      call	menu_decode		;menu button pressed?
      call	eax

    The menu_line_ptrs point to a data structure which
    describes the menu display, all mouse areas, and key
    board actions.  An example follows:

 menu defiition - define a 2 line button menu

 -----
    menu_line_ptrs:
      dd	menu_line1_ptrs	;pointer to menu line 1 definition
      dd	menu_line2_ptrs ;pointer to menu line 2 definition
      dd	0		;end of pointers
-------
    menu_line1_ptrs:
      db	1		;display at line number
      db	1		;color number for space between buttons
      dd	color_table	;color definitions
      dd	menu1_text	;menu text line
      dd	menu1_process	;process's to call for each button
      dd	menu1_colors	;colors associated with each button
      dd	menu1_keys	;keys associated with each button

    menu_line2_ptrs:
      db	2		;line number
      db	1		;space color number
      dd	color_table
      dd	menu2_text
      dd	menu2_process
      dd	menu2_colors
      dd	menu2_keys
------
      hex color def: aaxxffbb  aa-attr ff-foreground  bb-background
      30-blk 31-red 32-grn 33-brown 34-blue 35-purple 36-cyan 37-grey
      attributes 30-normal 31-bold 34-underscore 37-inverse
    color_table:
    ct1:   	dd	30003730h	;color 1 grey on black - spaces, page color
    ct2:   	dd	30003037h	;color 2 black on grey - button text color
    ct3:    dd	30003437h	;color 3 blue on grey - highlight bar color
------
     menu text consists of 'space-counts' and text.  space-counts
     are encoded as numbers from 1-8.  the end of text line has 'zero' char
     The following  lines describe two button sets.  Each button set uses
     two display lines.
    menu1_text:
     db 1,'raw(r)',1,'src(s)',1,'code(t)',1,'data(i)',,0
    menu2_text:                                                                       
     db 1,' mode ',1,' mode ',1,' area  ',1,' area  ',',0

    menu1_process:
    menu2_process:
     dd set_raw, set_src, set_code, set_data
-------
    colors for each button on line.  See color table above
    menu1_colors:
    menu2_colors:
     db 2,2,2,2
-------
    menu1_keys:
    menu2_keys:
     db	'r',0	;raw mode key
     db	's',0	;src mode key
     db	't',0	;code section
     db	'i',0	;data section
     db	0 ;end of keys
 ---

 NOTES
    source file: menu_decode.asm
                     

-----------------------------------------------------------------------
266 menu_display - display menu specified by structure
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to menu structure (see below)
 OUTPUT
    none
 OPERATION
    The normal sequence of events is:

      mov	esi,menu_line_ptrs
      call	menu_display		;display menu
      call	read_stdin		;wait for event, ->kbuf
      mov	esi,menu_line_ptrs
      call	menu_decode		;menu button pressed?
      call	eax

    The menu_line_ptrs point to a data structure which
    describes the menu display, all mouse areas, and key
    board actions.  An example follows:

 menu defiition - define a 2 line button menu

 -----
    menu_line_ptrs:
      dd	menu_line1_ptrs	;pointer to menu line 1 definition
      dd	menu_line2_ptrs ;pointer to menu line 2 definition
      dd	0		;end of pointers
-------
    menu_line1_ptrs:
      db	1		;display at line number
      db	1		;color number for space between buttons
      dd	color_table	;color definitions
      dd	menu1_text	;menu text line
      dd	menu1_process	;process's to call for each button
      dd	menu1_colors	;colors associated with each button
      dd	menu1_keys	;keys associated with each button

    menu_line2_ptrs:
      db	2		;line number
      db	1		;space color number
      dd	color_table
      dd	menu2_text
      dd	menu2_process
      dd	menu2_colors
      dd	menu2_keys
------
      hex color def: aaxxffbb  aa-attr ff-foreground  bb-background
      30-blk 31-red 32-grn 33-brown 34-blue 35-purple 36-cyan 37-grey
      attributes 30-normal 31-bold 34-underscore 37-inverse
    color_table:
    ct1:   	dd	30003730h	;color 1 grey on black - spaces, page color
    ct2:   	dd	30003037h	;color 2 black on grey - button text color
    ct3:    dd	30003437h	;color 3 blue on grey - highlight bar color
------
     menu text consists of 'space-counts' and text.  space-counts
     are encoded as numbers from 1-8.  the end of text line has 'zero' char
     The following  lines describe two button sets.  Each button set uses
     two display lines.
    menu1_text:
     db 1,'raw(r)',1,'src(s)',1,'code(t)',1,'data(i)',,0
    menu2_text:                                                                       
     db 1,' mode ',1,' mode ',1,' area  ',1,' area  ',',0

    menu1_process:
    menu2_process:
     dd set_raw, set_src, set_code, set_data
-------
    colors for each button on line.  See color table above
    menu1_colors:  ;first color is for space infront of button
    menu2_colors:  ;button1 color is at menu1_colors+1
     db 2,2,2,2,2
-------
    menu1_keys:
    menu2_keys:
     db	'r',0	;raw mode key
     db	's',0	;src mode key
     db	't',0	;code section
     db	'i',0	;data section
     db	0 ;end of keys
 ---

 NOTES
    source file: menu_decode.asm
                     

-----------------------------------------------------------------------
267 mouse_line_decode - find mouse process from display line text
-----------------------------------------------------------------------
 INPUTS
    esi = display line text ptr
    edi = process list matching display line buttons, ending with zero
    bl = column mouse click occured on
    example:
     menu_line1
      db 1,' New-proj ',1,' Del-proj ',1,' Add-todo ',1,' Fwd ',0
     process_names
      dd  new_proj,  del_proj,   add_todo,   page_fwd, 0
 OUTPUT
    ecx = process match or zero if no match
 NOTES
   file:  mouse_line_decode.asm
   assumes click occured on button line matching input tables
   assumes menu line uses numbers 1-6 to indicate spaces between buttons
   assumes menu line text is terminated by a zero

-----------------------------------------------------------------------
268 change_tty_group - assign tty to new group
-----------------------------------------------------------------------
  the group controlling a tty is said to be in foreground
  all others are in background.
 INPUTS
    eax = new group id
    ebx = terminal fd (usually 0)
 OUTPUT
    eax = zero if success else error code
 NOTES
    calls tcsetpgrp
    uses lib_buf to hold new group
    If current process moves stdin to another group the
    signal SIGTTOU occurs.
    source file: change_tty_group.asm

-----------------------------------------------------------------------
269 check_process - get process status from /proc
-----------------------------------------------------------------------
 INPUTS
    ebx = pid (process id)
 OUTPUT
    al = "U" unknown pid
    al = "S" sleeping
    al = "R" running
    al = "T" stopped
    al = "Z" zombie
    al = "D" uninterruptable wait
 NOTES
    source file: check_process.asm

-----------------------------------------------------------------------
270 create_group - make our process a new group leader
-----------------------------------------------------------------------
 INPUTS
    ebx = our pid (becomes group gpid)
          if ebx = 0 the current pid is used
 OUTPUT
    eax = zero if success
          a negative value is error code
 NOTES
    calls setpgid
    The new group becomes a group leader and it pid=gid
    for the group.
    source file: create_group.asm

-----------------------------------------------------------------------
271 get_group - get group id for process (x)
-----------------------------------------------------------------------
 INPUTS
    ebx = process id
 OUTPUT
    eax = group id for process passed in eax
          if error a negative error code in eax
 NOTES
    calls kernel function getpgid(x)
    source file: get_group.asm

-----------------------------------------------------------------------
272 get_our_group - get group id for our process
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    eax = group or negative error
 NOTES
    calls kernel function getpgrp
    source file: get_our_group.asm

-----------------------------------------------------------------------
273 get_our_process_id - get our process id
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    eax = our pid
 NOTES
    calls kernel function getpid
    source file: get_our_process_id.asm

-----------------------------------------------------------------------
274 get_parent_process_id - get our process id
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    eax = parent pid
 NOTES
    calls kernel function getppid
    source file: get_parent_process_id.asm

-----------------------------------------------------------------------
275 get_proc_info - extract info from kernel /proc/./stat
-----------------------------------------------------------------------
 INPUTS
    eax = pid of process to get status entry from
    ebx = index to item (see below and "man proc")
          if index is positive eax=ptr to ascii string
          if index is negative eax= bin value of item
    some common indexs are:
          0-pid              7-tpgid
          1-process name    17-priority 
          2-state           27-stack
          3-ppid            28-current esp
          4-group           29-current eip
          5-session         31-blocked signals
          6-tty             32-ignored signals
                            33-caught signals
                            37-exit signal
 OUTPUT
    eax = return status, negative if error
    ebx = ptr to string (terminated by space) or
          binary value of item requested.
    [lib_buf] contains /stat dir until next lib
          call.  See "man proc" for format.
    possible error is: bad pid
 NOTES
    source file: get_proc_info.asm

-----------------------------------------------------------------------
276 get_tty_group - get group controling the tty
-----------------------------------------------------------------------
 INPUTS
    ebx = fd for tty
 OUTPUT
    eax = tpgid (terminal group) or error if negative
 NOTES
    calls TIOCGPGRP ioctl
    source file: get_tty_group.asm

-----------------------------------------------------------------------
277 join_group - join a process to (existing) group
-----------------------------------------------------------------------
 INPUTS
    ebx = pid joining group (usually current pid)
          0 = use current pid
    ecx = gpid to join
 OUTPUT
    eax = 0 if success
          a negative value is error code
 NOTES
    calls setpgid.
    only groups in same scession can be joined, so
    check session first.
    source file: join_group.asm

-----------------------------------------------------------------------
278 kill_process - send kill signal to process
-----------------------------------------------------------------------
 INPUTS
    ebx = pid to kill
          0 = kill all processes in group
 OUTPUT
    eax = 0 if success
          a negative value is error code
 NOTES
    source file: kill_process.asm

-----------------------------------------------------------------------
279 process_info_pid - get information for process (x)
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to asciiz pid string
 OUTPUT
    eax = number of bytes of data in buffer lib_buf
          (if eax negative an error occured)
    ecx = pointer to data in lib_buf (see below)
         Name:	init
         State:	S (sleeping)
         SleepAVG:	90%
         Tgid:	1
         Pid:	1
         PPid:	0
         TracerPid:	0
         Uid:	0	0	0	0
         Gid:	0	0	0	0
         FDSize:	32
         Groups:	
         VmSize:	    1408 kB
         VmLck:	       0 kB
         VmRSS:	     496 kB
         VmData:	     148 kB
         VmStk:	       4 kB
         VmExe:	      28 kB
         VmLib:	    1204 kB
         Threads:	1
         SigPnd:	0000000000000000
         ShdPnd:	0000000000000000
         SigBlk:	0000000000000000
         SigIgn:	ffffffff57f0d8fc
         SigCgt:	00000000280b2603
         CapInh:	0000000000000000
         CapPrm:	00000000ffffffff
         CapEff:	00000000fffffeff
    The above data is held in a temporary buffer (lib_buf) and
    may be destroyed by other library functions.  All entries of
    form xxxx: begin at left edge and are followed by a <tab>.  The\
    end of each entry is a <0ah> end of line character.  No binary
    data is in lib_buf buffer.

    The "state:" entry may contain:
         "U" unknown pid
         "S" sleeping
         "R" running
         "T" stopped
         "Z" zombie
         "D" uninteruptable wait

 NOTES
    source file: process_info_pid.asm

-----------------------------------------------------------------------
280 process_info_pidn - get information for process (x)
-----------------------------------------------------------------------
 INPUTS
    eax = process id
 OUTPUT
    eax = number of bytes of data in buffer lib_buf
          (if eax negative an error occured)
    ecx = pointer to data in lib_buf (see below)
         Name:	init
         State:	S (sleeping)
         SleepAVG:	90%
         Tgid:	1
         Pid:	1
         PPid:	0
         TracerPid:	0
         Uid:	0	0	0	0
         Gid:	0	0	0	0
         FDSize:	32
         Groups:	
         VmSize:	    1408 kB
         VmLck:	       0 kB
         VmRSS:	     496 kB
         VmData:	     148 kB
         VmStk:	       4 kB
         VmExe:	      28 kB
         VmLib:	    1204 kB
         Threads:	1
         SigPnd:	0000000000000000
         ShdPnd:	0000000000000000
         SigBlk:	0000000000000000
         SigIgn:	ffffffff57f0d8fc
         SigCgt:	00000000280b2603
         CapInh:	0000000000000000
         CapPrm:	00000000ffffffff
         CapEff:	00000000fffffeff
    The above data is held in a temporary buffer (lib_buf) and
    may be destroyed by other library functions.  All entries of
    form xxxx: begin at left edge and are followed by a <tab>.  The\
    end of each entry is a <0ah> end of line character.  No binary
    data is in lib_buf buffer.

    The "state:" entry may contain:
         "U" unknown pid
         "S" sleeping
         "R" running
         "T" stopped
         "Z" zombie
         "D" uninterruptable wait

 NOTES
    source file: process_info_pidn.asm

-----------------------------------------------------------------------
281 process_info_us - get our process information
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    eax = number of bytes of data in buffer lib_buf
          (if eax negative an error occured)
    ebx = our process id (binary)
    ecx = pointer to data in lib_buf (see below)
         Name:	init
         State:	S (sleeping)
         SleepAVG:	90%
         Tgid:	1
         Pid:	1
         PPid:	0
         TracerPid:	0
         Uid:	0	0	0	0
         Gid:	0	0	0	0
         FDSize:	32
         Groups:	
         VmSize:	    1408 kB
         VmLck:	       0 kB
         VmRSS:	     496 kB
         VmData:	     148 kB
         VmStk:	       4 kB
         VmExe:	      28 kB
         VmLib:	    1204 kB
         Threads:	1
         SigPnd:	0000000000000000
         ShdPnd:	0000000000000000
         SigBlk:	0000000000000000
         SigIgn:	ffffffff57f0d8fc
         SigCgt:	00000000280b2603
         CapInh:	0000000000000000
         CapPrm:	00000000ffffffff
         CapEff:	00000000fffffeff
    The above data is held in a temporary buffer (lib_buf) and
    may be destroyed by other library functions.  All entries of
    form xxxx: begin at left edge and are followed by a <tab>.  The\
    end of each entry is a <0ah> end of line character.  No binary
    data is in lib_buf buffer.
 NOTES
    source file: process_info_us.asm

-----------------------------------------------------------------------
282 process_search - search names of active process's
-----------------------------------------------------------------------
 INPUTS
    eax = either buffer pointer or continue flag
          if eax = buffer ptr then this is first call
          -  and searching will begin
          if eax = 0 this is a continuation call and
          -  we will search to next match
    ebx = buffer size if ptr in eax
    ecx = match string (asciiz process name)
 OUTPUT
    eax = (if eax negative an error occured)
          (if eax = 0 then no match found)
          (if eax positive = ptr to process data (see below)
         Name:	init
         State:	S (sleeping)
         SleepAVG:	90%
         Tgid:	1
         Pid:	1
         PPid:	0
         TracerPid:	0
         Uid:	0	0	0	0
         Gid:	0	0	0	0
         FDSize:	32
         Groups:	
         VmSize:	    1408 kB
         VmLck:	       0 kB
         VmRSS:	     496 kB
         VmData:	     148 kB
         VmStk:	       4 kB
         VmExe:	      28 kB
         VmLib:	    1204 kB
         Threads:	1
         SigPnd:	0000000000000000
         ShdPnd:	0000000000000000
         SigBlk:	0000000000000000
         SigIgn:	ffffffff57f0d8fc
         SigCgt:	00000000280b2603
         CapInh:	0000000000000000
         CapPrm:	00000000ffffffff
         CapEff:	00000000fffffeff
    The above data is held in a temporary buffer (lib_buf) and
    may be destroyed by other library functions.  All entries of
    form xxxx: begin at left edge and are followed by a <tab>.  The\
    end of each entry is a <0ah> end of line character.  No binary
    data is in lib_buf buffer.
    After using this function call process_walk_cleanup to close
    all open files.
 NOTES
    source file: process_search.asm

-----------------------------------------------------------------------
283 process_walk - walk through active process's
-----------------------------------------------------------------------
 INPUTS
    eax = either buffer pointer or continue flag
          if eax = buffer ptr then this is first call
          -  and walking will begin
          if eax = 0 this is a continuation call and
          -  we will walk to next process
    ebx = buffer size if ptr in eax
          For most systems a good size is 8096 bytes.
 OUTPUT
    eax = number of bytes of data in buffer lib_buf
        - (if eax negative an error occured)
        - (if eax =  zero we are done walking)
    ecx = pointer to data in lib_buf (example below)
         Name:	init
         State:	S (sleeping)
         SleepAVG:	90%
         Tgid:	1
         Pid:	1
         PPid:	0
         TracerPid:	0
         Uid:	0	0	0	0
         Gid:	0	0	0	0
         FDSize:	32
         Groups:	
         VmSize:	    1408 kB
         VmLck:	       0 kB
         VmRSS:	     496 kB
         VmData:	     148 kB
         VmStk:	       4 kB
         VmExe:	      28 kB
         VmLib:	    1204 kB
         Threads:	1
         SigPnd:	0000000000000000
         ShdPnd:	0000000000000000
         SigBlk:	0000000000000000
         SigIgn:	ffffffff57f0d8fc
         SigCgt:	00000000280b2603
         CapInh:	0000000000000000
         CapPrm:	00000000ffffffff
         CapEff:	00000000fffffeff
    The above data is held in a temporary buffer (lib_buf) and
    may be destroyed by other library functions.  All entries of
    form xxxx: begin at left edge and are followed by a <tab>.  The
    end of each entry is a <0ah> end of line character.  No binary
    data is in lib_buf buffer.
    Open files are closed when end of process data is signaled by
    no more data.  If walk does not reach the end, the open file
    handle "proc_handle" should be closed by caller.  A good
    way to do this is by calling "process_walk_cleanup" after
    using process_walk. 
 NOTES
    source file: process_walk.asm

-----------------------------------------------------------------------
284 process_walk_cleanup - close all walk files 
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    none
 NOTES
    source file: process_walk.asm
    Use this call after all calls to process walk are
    finished.

-----------------------------------------------------------------------
285 random_dword - generate random dword
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    eax = random value
 NOTES
   source file: random2.asm

-----------------------------------------------------------------------
286 random_seed - get low clock bits to use as random number
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   eax = microseconds counter,
 NOTES
  source file random3.asm

-----------------------------------------------------------------------
287 scale_dword - adjust random number to fit in range
-----------------------------------------------------------------------
 INPUTS
    ebx = low value of range
    ebp = high value of range
    eax = number to scale
 OUTPUT
    eax = scalled number
 NOTES
   source file: random1.asm

         The number is scaled using the formula
    
          input value              x
          ----------- =  -----------------------
           0ffffh        (high range - low range)
    
           scaled number = x + low range

-----------------------------------------------------------------------
288 signal_handler_default - set default handler for signal
-----------------------------------------------------------------------
 INPUTS  ebx = signal number
 OUTPUT  eax = error or
               old signal handler address
 NOTES
    See file /err/install_signals for more documentation.
    This function uses kernel call sigaction to set
    handler state of SIG_DFL

-----------------------------------------------------------------------
289 signal_handler_none - set no handler for signal
-----------------------------------------------------------------------
 INPUTS  ebx = signal number
 OUTPUT  eax = error of
               old signal handler address
 NOTES
    See file /err/install_signals for more documentation.
    This function uses kernel call sigaction to set
    handler state of SIG_IGN

-----------------------------------------------------------------------
290 signal_handler_status - check if our signal handler installed
-----------------------------------------------------------------------
 INPUTS  ebx = signal number
 OUTPUT  eax = (0) success
         edx = ptr to   dd handler or ptr to SIG_DFL,SIG_IGN
                        dd mask
                        dd flag
                        dd unused
         initial status after load returned - 0,0,0,bfef0468
         after handler installed   returned - handler,mask,flag,0
         after handler removed returned     - pointer,0,0,ccc53fbc
                                              (pointer) -> dd 0 or 1
 NOTES
    See file /err/install_signals for more documentation.

-----------------------------------------------------------------------
291 signal_install - install signal
-----------------------------------------------------------------------
 INPUTS  ebx = signal number
         ecx = ptr to data block as follows:
               dd handler
               dd mask (signals to ignore while handling this sig)
               dd flags 04h =  3 arguments -> handler instead of 1
               dd 0 (dummy unused field)
 OUTPUT eax (0) success
            EINVAL (-22) not catchable
            EFAULT (-14) memory error
            EINTR  (-4)  sys call interrupted
   
 NOTES
    See file /err/install_signals for more documentation.

-----------------------------------------------------------------------
292 signal_install_list - install signals
-----------------------------------------------------------------------
 INPUTS
     ebp = pointer to  table describing each signal to install.
     The table is terminated with a zero byte in the signal number
     field.
       Sanple table entry for to install the SIGILL signal.
     db 4			;signal number = illegal action SIGILL
     dd handleIll		;handler for signal
     dd 0                      ;mask (signals to ignore while handling this sig)
     dd 4			;set siginfo telling kernel to pass status data to handler
     dd 0			;always zero
     db 0                      ;end of table or next signal number
 OUTPUT eax (0) success
            EINVAL (-22) not catchable
            EFAULT (-14) memory error
            EINTR  (-4)  sys call interrupted
            ebp = bad signal table entry ptr if error   
 NOTES
    See file /err/install_signals for more documentation.

-----------------------------------------------------------------------
293 signal_mask_block - block signal handler (OR) into mask
-----------------------------------------------------------------------
 INPUTS  ecx = ptr to dword with signal bits
               0000 0001 = signal 1
               0001 0000 = signal 17
 OUTPUT  eax (0) success
             (-1) error   
 NOTES
    Source file: signal_mask.asm
    Masked bit only apply to installed signals, not to default
       handlers.
    See file /err/install_signals for more documentation.

-----------------------------------------------------------------------
294 signal_mask_get - get current signal mask
-----------------------------------------------------------------------
 INPUTS  none
 OUTPUT  eax (0) success
             (-1) error 
         ebx mask bits if eax=0
 NOTES
    Source file: signal_mask.asm
    Masked bit only apply to installed signals, not to default
       handlers.
    See file /err/install_signals for more documentation.

-----------------------------------------------------------------------
295 signal_mask_set - set signal mask (store) bits
-----------------------------------------------------------------------
 INPUTS  ecx = ptr to dword with signal bits
               0000 0001 = signal 1
               0001 0000 = signal 17
 OUTPUT  eax (0) success
             (-1) error   
 NOTES
    Source file: signal_mask.asm
    Masked bit only apply to installed signals, not to default
       handlers.
    See file /err/install_signals for more documentation.

-----------------------------------------------------------------------
296 signal_mask_unblock - unblock signal handler (AND) with mask
-----------------------------------------------------------------------
 INPUTS  ecx = ptr to dword with signal bits
               0000 0001 = signal 1
               0001 0000 = signal 17
 OUTPUT  eax (0) success
             (-1) error   
 NOTES
    Source file: signal_mask.asm
    Masked bit only apply to installed signals, not to default
       handlers.
    See file /err/install_signals for more documentation.

-----------------------------------------------------------------------
297 signal_send - send signal
-----------------------------------------------------------------------
 INPUTS  ebx = process id (pid) to recieve signal
         ecx = signal number, or zero
               A zero does not send a signal, but does
               do error checking.  This may be useful
               to determine if a process exists or
               a signal can be sent to process.
 OUTPUT  success (0)
         EINVAL (-22) invalid signal
         ESRCH  (-3)  pid not found
         EPERM  (-1)  insufficient permissions
   
 NOTES
    See file /err/install_signals for more documentation.

-----------------------------------------------------------------------
298 signal_wait - wait for signals
-----------------------------------------------------------------------
 INPUTS  none
 OUTPUT  eax = signal mask indicating which signals occured.
               After signal has been handled we resume execution.
               Multiple bits can be set as follows:
               00000001h = signal#1 SIGHUP
               00000004h = signal#3 SIGQUIT
 -------          ---       ----    -----------------------------------------------------------
 SIGHUP	     1	     Term    Hangup detected on controlling terminal
				     or death of controlling process
 SIGINT	     2	     Term    Interrupt from keyboard
 SIGQUIT	     3	     Core    Quit from keyboard
 SIGILL	     4	     Core    Illegal Instruction
 SIGTRAP	     5       Core    Trace/breakpoint trap
 SIGABRT	     6	     Core    Abort signal from abort(3)
 SIGIOT	     6       Core    IOT trap. A synonym for SIGABRT
 SIGBUS	     7       Core    Bus error (bad memory access)
 SIGFPE	     8	     Core    Floating point exception
 SIGKILL	     9	     Term    Kill signal
 SIGUSR1	    10       Term    User-defined signal 1
 SIGSEGV	    11	     Core    Invalid memory reference
 SIGUSR2	    12       Term    User-defined signal 2
 SIGPIPE	    13	     Term    Broken pipe: write to pipe with no readers
 SIGALRM	    14	     Term    Timer signal from alarm(2)
 SIGTERM	    15	     Term    Termination signal
 SIGSTKFLT         16       Term    Stack fault on coprocessor (unused)
 SIGCHLD	    17       Ign     Child stopped or terminated
 SIGCONT	    18   	     Continue if stopped
 SIGSTOP	    19       Stop    Stop process
 SIGTSTP	    20       Stop    Stop typed at tty
 SIGTTIN	    21       Stop    tty input for background process
 SIGTTOU	    22       Stop    tty output for background process
 SIGURG	    23       Ign     Urgent condition on socket (4.2 BSD)
 SIGXCPU	    24       Core    CPU time limit exceeded (4.2 BSD)
 SIGXFSZ	    25       Core    File size limit exceeded (4.2 BSD)
 SIGVTALRM         26       Term    Virtual alarm clock (4.2 BSD)
 SIGPROF	    27       Term    Profiling timer expired
 SIGWINCH	    28       Ign     Window resize signal (4.3 BSD, Sun)
 SIGIO	            29       Term    I/O now possible (4.2 BSD)
 SIGPWR	    30       Term    Power failure (System V)
 SIGINFO	    30  	       A synonym for SIGPWR
 SIGUNUSED         31       Term    Unused signal (will be SIGSYS)

 Term   Default action is to terminate the process.
 Ign    Default action is to ignore the signal.
 Core   Default action is to terminate the process and dump core.
 Stop   Default action is to stop the process.

 NOTES
    When first entered signal_wait installs signal handlers
    for all signals and then watches them.  Any signal handlers
    installed before signal_wait will not be active.

    The caller can install signal handlers after this but
    signal_wait will no longer be able to determine the type
    of signal for callers handler.  Instead it will return a
    zero status bit when signal occurs.
    Source file is: sgnal_wait.asm

-----------------------------------------------------------------------
299 signal_wait_blind - wait for any signal that is handled.
-----------------------------------------------------------------------
 INPUTS  none
 OUTPUT  none

 NOTES: returns to caller after the signal handler exits.
        The type of signal is not known.

-----------------------------------------------------------------------
300 signal_wait_child - wait for child termination signal
-----------------------------------------------------------------------
 INPUTS  ebx = child pid (process id)
 OUTPUT
         We resume execution before signal is handled
         with registers set as follows:
         eax= pid if signal, and status is in ecx
              0 if child terminated, no status in ecx
         cl = status byte 7fh = ptrace stop
         ch = possibly a signal number
         
 NOTES:  see man page for "waitpid" for information
         on status byte and options.
         This function uses the kernel waitpid(7) call.
         Source file is: signal_wait.asm       

-----------------------------------------------------------------------
301 signal_wait_setup - optional setup for signal_wait function
-----------------------------------------------------------------------
 INPUTS  none
 OUTPUT  none

 NOTES: Use this function to avoid race conditions.  It sets
        up signal handlers for the signal_wait function call.
        It is needed if signals can occur before the signal_wait
        function is ready for them.  If this setup is done at top
        of a program it will detect any signals that occur and
        the signal_wait can be called at any time, even if the
        signal has already occured.
        If race conditions do not exist, then this function can
        be ignored and signal_wait will set up when called.

-----------------------------------------------------------------------
302 signals_ending - get mask for pending signals
-----------------------------------------------------------------------
 INPUTS  none
 OUTPUT  bits in ebx
              (dword) 0000 0001 = signal 1
                      0001 0000 = signal 17
         [ebx] data is accessed as dword not bytes?
 NOTES
    See file /err/install_signals for more documentation.

-----------------------------------------------------------------------
303 sort_bubble - bubble sort a list of ptr to text blocks
-----------------------------------------------------------------------
 INPUTS
    ebp = ptr to list of record pointers, terminated by zero ptr
 OUTPUT
    pointer list reordered
 NOTES
   source file: sort_bubble.asm

-----------------------------------------------------------------------
304 sort_dword_array - use bubble sort on array of dwords
-----------------------------------------------------------------------
    array is sorted in place and must be in
    a .bss or .text section that is writable.
    negative numbers are assumed to be smaller and will be
    at top of sort.
 INPUTS
   edi = pointer to array
   edx = number of array items

 output:
    ecx,ebx=0 if more than 2 items in array
    esi=ptr to last array entry if more than 2 items in array
    all other registers unchanged.
    array entries are reordered in acending order
 destroys:
   eax, esi, ecx
   eflags
 NOTES
   source file: sort_dword_array.asm

-----------------------------------------------------------------------
305 sort_dword_array2 - use selection sort on array of dwords
-----------------------------------------------------------------------
    array is sorted in place and must be in
    a .bss or .text section that is writable.
    negative numbers are assumed to be smaller and will be
    at top of sort.
 INPUTS
   edi = pointer to array
   ecx = number of array items

 output:
    all registers destroyed
    array entries are reordered in acending order
 NOTES
   source file: sort_dword_array2.asm
   The selection sort is fairly fast for arrays in
   random order.  The bubble sort is slow for most
   jobs, but is fast on arrays that are partially
   sorted.

-----------------------------------------------------------------------
306 sort_dword_array3 - use selection sort with ptr list
-----------------------------------------------------------------------
    This routine expects to find a dword sort key in data
 INPUTS
    ebp - pointer to pointers for each record
          last pointer equals zero
    edx = column in data with dword sort key
          0=first column
 OUTPUT
    pointers ordered by decending  records 
 NOTES
   source file: sort_dword_array3.asm
   The index must have at least one entry.

-----------------------------------------------------------------------
307 sort_merge - merge sort buffer using index
-----------------------------------------------------------------------
 inputs:    ebp = address of dword ptr list (index) 
                  pointing at records in a buffer.  The
                  pointer list must be writable and have
                  extra space at end.  The size of index
                  and extra space is:
                   ((8 * number-of-records) + 16)
                  The extra area is used by sort_merge.
            ebx = length of sort key (how many bytes in record
                  to compare)
            ecx = number of records in buffer
            edx = starting column for sort, 0=first 1=second
                  note: tabs are not expanded, so column is
                        byte index into record.
 
 output:
            all registers are destroyed
            The index has been reordered in acending sort
            order.
 NOTES:
            merge sort is very fast but uses more memory
            than the bubble or selection sorts.  Generally
            large sorting jobs should use the merge sort,
            and small (2-100 records) can use the other
            sorts.
            This is a binary sort and does not recognize
            end of line characters.  This can cause problems
            with variable length records, beware.  
            memory usage is about 200 bytes of code and a
            buffer of (record_count * 8) bytes

-----------------------------------------------------------------------
308 sort_merge_lines - merge sort buffer using index
-----------------------------------------------------------------------
 inputs:    ebp = address of dword ptr list (index) 
                  pointing at records in a buffer.  The
                  pointer list must be writable and have
                  extra space at end.  The size of index
                  and extra space is:
                   ((8 * number-of-records) + 16)
                  The extra area is used by sort_merge.
            ebx = length of sort key (how many bytes in record
                  to compare)
            ecx = number of records in buffer
            edx = starting column for sort, 0=first 1=second
                  note: tabs are not expanded, so column is
                        byte index into record.
 
 output:
            all registers are destroyed
            The index has been reordered in acending sort
            order.
 NOTES:
            merge sort is very fast but uses more memory
            than the bubble or selection sorts.  Generally
            large sorting jobs should use the merge sort,
            and small (2-100 records) can use the other
            sorts.
            This is a text sort that recognizes
            end of line characters.
            memory usage is about 200 bytes of code and a
            buffer of (record_count * 8) bytes

-----------------------------------------------------------------------
309 sort_selection - use selection sort with ptr list
-----------------------------------------------------------------------
 INPUTS
    ebp - pointer to pointers for each record
          last pointer equals zero
    edx = column to use as sort data
          0=first column
    ecx = length of sort
 OUTPUT
    pointers ordered by decending  records 
 NOTES
   source file: sort_selection.asm
   The index must have at least one entry.

-----------------------------------------------------------------------
310 close_sound_device - close /dev/dsp
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT:
    eax = negative kernel error if failure
 NOTES
   source file: close_sound_device.asm

-----------------------------------------------------------------------
311 compute_samples_per_wave - compute samples per wave
-----------------------------------------------------------------------
 INPUT  ebx = frequency
        eax = samples per second
 OUTPUT  eax = samples per wave or negative error
 NOTES
   source file: compute_samples_per_wave

-----------------------------------------------------------------------
312 compute_wave_count - compute number of waves
-----------------------------------------------------------------------
 INPUTS
    eax = duration in ms
    ebx = frequency of sound
 OUTPUT:
    eax = number of waves
          negative if error
 NOTES
   source file: compute_wave_count.asm

-----------------------------------------------------------------------
313 flush_sound_device - write remaining bytes
-----------------------------------------------------------------------
 INPUTS
    [total_written] - dword of buffer write count
    [gss_buf_size] - size of device buffer
 OUTPUT:
    eax = number of bytes written
        = negative kernel error if failure
 NOTES
   source file: flush_sound_device.asm
   This function is normally part of the following
   series of functions:
     open_sound_device
     set_sound_device
     compute_samples_per_wave
     write_sound_device
     flush_sound_device
     close_sound_device

-----------------------------------------------------------------------
314 make_sound - play square wave
-----------------------------------------------------------------------
 INPUTS
    eax = duration in ms
    ebx = frequency of sound
 OUTPUT:
    eax = negative if parameter error
 NOTES
   source file: get_sound_status.asm
   This function calls:
     compute_wave_count
     open_sound_device
     set_sound_device
     compute_samples_per_wave
     write_sound_device
     flush_sound_device
     close_sound_device
   The sound device feeds a DAC (digital to analog
   converter) and has several formats.  The data
   sent to DAC forms a wave and the wave frequency
   is determined by data amptitude.  For byte format,
   80h is the wave center point, and the two extreems
   are 00h and 0ffh
   make_sound sets the byte format.

-----------------------------------------------------------------------
315 metronome - repeat tone until done or key press
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to control block
       dd tone frequency
       dd tone length in ms
       dd repeat every xx ms
       dd repeat xx times
 OUTPUT:
    eax = negative if parameter error
 NOTES
   source file: metronome.asm

-----------------------------------------------------------------------
316 open_sound_device - open /dev/dsp
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT:
    eax = handle if success
        = negative kernel error if failure
 NOTES
   source file: open_sound_device.asm
   This function is normally part of the following
   series of functions:
     open_sound_device
     set_sound_device
     compute_samples_per_wave
     write_sound_device
     flush_sound_device
     close_sound_device
   The sound device feeds a DAC (digital to analog
   converter) and has several formats.  The data
   sent to DAC forms a wave and the wave frequency
   is determined by data amptitude.  For byte format,
   80h is the wave center point, and the two extreems
   are 00h and 0ffh

-----------------------------------------------------------------------
317 set_sound_device - mono mode, byte data, samp rate 22050
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT:
    eax = device buffer size
          also in global [gss_buf_size]
 NOTES
   source file: set_sound_device.asm

-----------------------------------------------------------------------
318 write_sound_device - write to /dev/dsp
-----------------------------------------------------------------------
 INPUTS
    ecx = sample buffer ptr
    edx = number of bytes to write
    global [gss_buf_size]
 OUTPUT:
    eax = number of bytes written
        = negative kernel error if failure
 NOTES
   source file: write_sound_device.asm

-----------------------------------------------------------------------
319 str_end - scan to end of string
-----------------------------------------------------------------------
 INPUTS
    esi = pointer to string
 OUTPUT
    esi points at zero byte (end of string)
 NOTES
    file str_end.asm

-----------------------------------------------------------------------
320 str_index - index into list of asciiz string
-----------------------------------------------------------------------
 INPUTS
    ecx = string number to find, 0=first string
    esi = pointer to buffer with strings ending
          with a zero byte.  The end of all strings
          is another zero byte, thus the table ends
          with 0,0
 OUTPUT
    esi points at string found or 0 if not found
 NOTES
    file str_index.asm

-----------------------------------------------------------------------
321 str_insert - inserts string into string
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to string1
    edi = ptr to string 2
    eax = ptr to insert point in string2
 OUTPUT
    string1 is inserted into string2
 NOTES
   source file: srt_insert.asm

-----------------------------------------------------------------------
322 str_join - join two strings
-----------------------------------------------------------------------
 INPUTS
    edi = string1
    ebx = string1 length
    esi = string2
    edx = string2 length
 OUTPUT
    edi points at new string
    ecx is lenght of new string
 NOTES
   source file: str_join.asm

-----------------------------------------------------------------------
323 str_len - find length of asciiz string
-----------------------------------------------------------------------
 INPUTS
    esi = input string ptr (asciiz)
 OUTPUT
    ecx = string length
    all other registers unchanged.
 NOTES
  source file: str_len.asm

-----------------------------------------------------------------------
324 str_move - move asciiz string
-----------------------------------------------------------------------
 INPUTS
    esi = input string ptr (asciiz)
    edi = destination ptr
 OUTPUT
    edi points at zero (end of moved asciiz string)
 NOTES
    file str_move.asm

-----------------------------------------------------------------------
325 strlen1 - get lenght of esi string
-----------------------------------------------------------------------
 INPUTS
    esi = pointer to asciiz string
 OUTPUT
    ecx = lenght of string
    all registers restored except for ecx
 NOTES
   source file: srt_insert.asm

-----------------------------------------------------------------------
326 strlen2 - get lenght of edi string
-----------------------------------------------------------------------
 INPUTS
    edi = pointer to asciiz string
 OUTPUT
    ecx = lenght of string
    all registers restored except ecx
 NOTES
   source file: srt_insert.asm

-----------------------------------------------------------------------
327 compare_mask - compare string to masked template
-----------------------------------------------------------------------
 inputs: esi = mask ptr
             mask can be *xxx or xxx*
         edi = data ptr
 output: the flags je,jne are set.

-----------------------------------------------------------------------
328 scan_buf - fast scan of sequential buffers for string
-----------------------------------------------------------------------

  INPUT      esi = points at block of data to be scanned
             ecx = block length (byte count)

  output:    esi = points at remaining data to be scanned
             edi = pointer to match in buffer
             ecx = number of bytes remaining to be scanned
             eax = 0 for match found (may be match split between two blocks)
                   1 for end of block, no match.

  note:  scan_buf can find multiple matches in a buffer, and
         automatically sets up inputs to be re-entered.  Matches split
         across two buffers (blocks) are also handled.

         The scan_buf uses Boyer-Moore for high speed scan

         scan_buf can be called repeatedly as long as the compare
         string is not changed.  If the compare string changes, then
         scan_buf_open should be called..

         Some benchmarks from a DOS system shows how scan_buf compares
         to other search methods:
                            code size   time (small numbers best)
                            ---------   -------------------------
         SCAN_BLOCK_TINY1    46 bytes    2.36 (small is faster)
         SCAN_BLOCK_TINY2    69 bytes   13.35 (matches ether case)
         SCAN_BLOCK1         43 bytes    2.36
         SCAN_BLOCK2        152 bytes    6.37 (matches either case)
         scan_buf           466 bytes    1.42 


  Example:     
                mov   esi, offset pattern
                mov   dl, 20h
                call  scan_buf_open
                test  ax, ax
                jnz   error

        read_loop:
                 mov   esi, target
                 (setup esi,ecx here for scan_buf call)
                 (if last buffer then goto to done)
        search_loop:
                 call  scan_buf
                 test  eax, eax
                 jz    read_loop
                 (process match found here, esi points at end of match)
                 jecxz  read_loop
                 jmp   search_loop

          done:

 Credits:  This code origionally provided by Mike Levis and modified
           by Jeff Owens

-----------------------------------------------------------------------
329 scan_buf_open - setup for scan buffer for string
-----------------------------------------------------------------------

  INPUTS     esi = points at string to search for (max length 254)
             dl = 0 for match case, 20h for match either case

  OUTPUT     eax = 0 if sucessful
             possible errors are: - string length too long or zero bytes.
                                  - insufficient memory

  Note:  The fast block scan functions need to be called as follows:
            scan_buf_open  - allocate memory, initialize tables for scan
            scan_buf       - actual scan operation, call repeatedly
         The scan_buf uses Boyer-Moore for high speed scan


-----------------------------------------------------------------------
330 str_compare - compare two strings, use case
-----------------------------------------------------------------------
 INPUTS
    esi = string1
    edi = string2
    assumes direction flag set to -cld- forward state
 OUTPUT
    flags set for je or jne
    esi & edi point at end of strings if match
 NOTES
   source file: str_compare.asm

-----------------------------------------------------------------------
331 str_match - compare asciiz string to buffer data, use case
-----------------------------------------------------------------------
 INPUTS
    esi = string1 (asciiz string)
    edi = string2 buffer
    assumes direction flag set to -cld- forward state
 OUTPUT
    flags set for je or jne
    esi & edi point at end of strings if match
 NOTES
   source file: str_match.asm

-----------------------------------------------------------------------
332 str_replace - replace first occurance of str1 in str2
-----------------------------------------------------------------------
 INPUTS
    eax = str1 -asciiz string ending with any char 0h-6h
          replacement string
    esi = match string to search for
    edi = str2 -asciiz string ending with any char 0h-6h
 OUTPUT
    carry set if replacement occured
    if no carry - ebp = new str2 end point
    if no carry - edi = ptr to end of inserted string
 NOTES
    source file: /str_cmp/str_replace.asm

-----------------------------------------------------------------------
333 str_replace_all - replace all occurances of str1 in str2
-----------------------------------------------------------------------
 INPUTS
    esi = str1 -asciiz string ending with any char 0h-6h
    edi = str2 -asciiz string ending with any char 0h-6h
    eax = ptr to replacement string
 OUTPUT
    carry set if replacement occured
    if no carry - ebp = new str2 end point
    if no carry - edi = ptr to end of inserted string
 NOTES
    source file: /str_cmp/str_replace_all.asm

-----------------------------------------------------------------------
334 str_search - search string for match
-----------------------------------------------------------------------
 INPUTS
    esi = input asciiz string terminated with 0-9h
    edi = string to search, terminated with 0-9h
 OUTPUT
    carry set if no match
    no carry if match and registers =
      esi - points to end of matching string
      edi - points to end of matched string
      edx - points to start of matching string
      ebx - points to start of matched string 
 NOTES
   source file:  str_search.asm

-----------------------------------------------------------------------
335 ascii_to_dword - convert decimal ascii string to binary
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to ascii string
 OUTPUT
    ecx = binary value
    esi = ptr past end of ascii string
 NOTES
    source file: ascii_to_dword.asm

-----------------------------------------------------------------------
336 byte2ascii - convert binary 1-255 to 3 ascii chars 
-----------------------------------------------------------------------
 INPUTS
     al  = binary value
     edi = start of storage area
 OUTPUT
    edi = ptr to end of stored string
    eax,edx destroyed
 NOTES
    source file: byte2ascii.asm
    If input (al) equals zero, nothing is stored.

-----------------------------------------------------------------------
337 byte2hexascii - convert one byte to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     ebx = byte of data
     edi = storage point for ascii +1 
      example: to store byte  sequentially
      mov   bl,hexbyte
      mov   edi,buffer + 1
      call  byte2hexascii
      add   edi,3 
 OUTPUT
    two ascii characters stored at [edi]
      edi decremented by two
      ebx is shifted right 
 NOTES
    source file: hex2ascii.asm
    See also: byte2hexstr

-----------------------------------------------------------------------
338 byte2hexstr - convert one byte to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     ebx = byte of data
     edi = storage point for hex ascii
 OUTPUT
    six ascii characters stored at [edi]
      edi points beyond last stored char.
      ebx unchanged, eax,ecx modified
 NOTES
    source file: hex2str.asm
    The input word must be in a cleared ebx register.
    See also: word2hexascii

-----------------------------------------------------------------------
339 byte2octalascii - convert one byte to octal ascii and store
-----------------------------------------------------------------------
 INPUTS
     ebx = byte of data
     edi = storage point for octal ascii
 OUTPUT
    six ascii characters stored at [edi]
      edi points beyond last stored char.
      ebx unchanged, eax,ecx modified
 NOTES
    source file: octal2ascii.asm
    The input word must be in a cleared ebx register.

-----------------------------------------------------------------------
340 byte_to_ascii - convert binary byte to left justified ascii string
-----------------------------------------------------------------------
 INPUTS
     al  = binary value
     edi = start of storage area
 OUTPUT
    edi = ptr to end of stored string
    eax,ebx,ecx destroyed
 NOTES
    source file: dword_to_ascii.asm

-----------------------------------------------------------------------
341 byte_to_hexascii - binary byte to hex ascii
-----------------------------------------------------------------------
 INPUTS
    al = binary hex byte
 OUTPUT
    ax = hex ascii
 NOTES
    source file: byte_to_hexascii.asm

-----------------------------------------------------------------------
342 byteto_hexascii - convert one byte to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     eax = byte of data
     edi = storage point for hex ascii
 OUTPUT
    two ascii characters stored at [edi]
      edi points beyond last stored char.
      eax modified
 NOTES
    source file: hex2str.asm
    The input word must be in a cleared ebx register.
    See also: word2hexascii
    The library has numerous hex converstions, this one is
    very compact and moderatly fast, It is the prefered choice.

-----------------------------------------------------------------------
343 dword2hexascii - convert dword to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     ebx = dword
     edi = storage point for ascii +7
      example: to store dwords sequentially
      mov   ebx,hexdword
      mov   edi,buffer + 7
      call  dword2hexascii
      add   edi,9 
 OUTPUT
    eight ascii character stored at [edi]
      edi decremented by eight
      ebx is shifted right 
 NOTES
    source file: hex2ascii.asm
    See also: dword2hexstr

-----------------------------------------------------------------------
344 dword2hexstr - convert one dword to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     ebx = dword of data
     edi = storage point for hex ascii
 OUTPUT
    eleven ascii characters stored at [edi]
      edi points beyond last stored char.
      ebx unchanged, eax,ecx modified
 NOTES
    source file: hex2str.asm
    See also: dword2hexascii

-----------------------------------------------------------------------
345 dword2octalascii - convert one dword to octal ascii and store
-----------------------------------------------------------------------
 INPUTS
     ebx = dword of data
     edi = storage point for octal ascii
 OUTPUT
    eleven ascii characters stored at [edi]
      edi points beyond last stored char.
      ebx unchanged, eax,ecx modified
 NOTES
    source file: octal2ascii.asm

-----------------------------------------------------------------------
346 dword_to_ascii - convert binary dword to left justified ascii string
-----------------------------------------------------------------------
 INPUTS
     eax = binary value
     edi = start of storage area
 OUTPUT
    edi = ptr to end of stored string
    eax,ebx,ecx destroyed
 NOTES
    source file: dword_to_ascii.asm

-----------------------------------------------------------------------
347 dword_to_hexascii - binary byte to hex ascii
-----------------------------------------------------------------------
 INPUTS
    ecx = binary hex dword
    edi = ptr to storage area
 OUTPUT
    edi = ptr to end of stored string
    (string always contains 8 ascii characters)
 NOTES
    source file: dword_to_hexascii.asm

-----------------------------------------------------------------------
348 dword_to_l_ascii - convert binary dword to left justified ascii string
-----------------------------------------------------------------------
 INPUTS
     eax = binary value
     edi = start of storage area
     esi = number of digets to store
 OUTPUT
    edi = ptr to end of stored string
    eax,ebx,ecx destroyed
 NOTES
    source file: dword_to_l_ascii.asm

-----------------------------------------------------------------------
349 dword_to_lpadded_ascii - binary dword to left justified ascii string
-----------------------------------------------------------------------
     any zeros at start of string are replaced with pad char.
 INPUTS
     eax = binary value
     edi = start of storage area
     cl  = number of bytes to store
           pad front to force cl bytes.
     ch  = pad character
 OUTPUT
    edi = ptr to end of stored string
    eax,ebx,ecx destroyed
 NOTES
    source file: dword_to_lpadded_ascii.asm

-----------------------------------------------------------------------
350 dword_to_r_ascii - convert bin dword to right just ascii str
-----------------------------------------------------------------------
 INPUTS
     eax = binary valuel
     edi = end of storage area for ascii (decremented)
 OUTPUT
     edi = ptr to start of ascii string
     eax,ebx,ecx destroyed
 NOTES
    source file: dword_to_r_ascii.asm

-----------------------------------------------------------------------
351 dwordto_hexascii - convert one dword to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     eax = dword of data
     edi = storage point for hex ascii
 OUTPUT
    eight ascii characters stored at [edi]
      edi points beyond last stored char.
      eax modified
 NOTES
    source file: hex2str.asm
    See also: dword2hexascii
    The library has numerous hex converstions, this one is
    very compact and moderatly fast, It is the prefered choice.

-----------------------------------------------------------------------
352 fdword_to_ascii - convert dword float to ascii string
-----------------------------------------------------------------------
 INPUTS
    eax = ptr to dword float value
    ebx = precision (output mantissa chars 1-10)
    edi = storage buffer for ascii
 OUTPUT
    edi = ptr beyond last ascii char in buf
    st(x) all floating registers are cleared
          using the finit instruction at exit
 NOTES
    file float_to_ascii.asm

-----------------------------------------------------------------------
353 fqword_to_ascii - convert qword float to ascii string
-----------------------------------------------------------------------
 INPUTS
    eax = ptr to dword float value
    ebx = precision (output mantissa chars 1-10)
    edi = storage buffer for ascii
 OUTPUT
    edi = ptr beyond last ascii char in buf
    st(x) all floating registers are cleared
          using the finit instruction at exit
 NOTES
    file float_to_ascii.asm

-----------------------------------------------------------------------
354 fst0_to_ascii - convert fst0 to ascii string
-----------------------------------------------------------------------
 INPUTS
    ebx = precision (output mantissa chars 1-10)
    edi = storage buffer for ascii
 OUTPUT
    edi = ptr beyond last ascii char in buf
    st(x) all floating registers are cleared
          using the finit instruction at exit
 NOTES
    file float_to_ascii.asm

-----------------------------------------------------------------------
355 ftword_to_ascii - convert tword float to ascii string
-----------------------------------------------------------------------
 INPUTS
    eax = ptr to dword float value
    ebx = precision (output mantissa chars 1-10)
    edi = storage buffer for ascii
 OUTPUT
    edi = ptr beyond last ascii char in buf
    st(x) all floating registers are cleared
          using the finit instruction at exit
 NOTES
    file float_to_ascii.asm

-----------------------------------------------------------------------
356 hexascii2byte - convert two hex ascii char to byte
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to hex ascii data
    ebx = zero or previous sum
 OUTPUT
    ebx = contains hex , the previous contents
          are shifted left
 NOTES
   source file: ascii2hex.asm

-----------------------------------------------------------------------
357 hexascii2dword - convert eight hex ascii char to dword
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to hex ascii data
    ebx = zero or previous sum
 OUTPUT
    ebx = contains hex , the previous contents
          are shifted left
 NOTES
   source file: ascii2hex.asm

-----------------------------------------------------------------------
358 hexascii2nibble - convert one hex ascii char to nibble
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to hex ascii data
    ebx = zero or previous sum
 OUTPUT
    ebx = contains hex in low 4 bits, the previous contents
          are shifted left by 4
 NOTES
   source file: ascii2hex.asm

-----------------------------------------------------------------------
359 hexascii2word - convert four hex ascii char to word
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to hex ascii data
    ebx = zero or previous sum
 OUTPUT
    ebx = contains hex , the previous contents
          are shifted left
 NOTES
   source file: ascii2hex.asm

-----------------------------------------------------------------------
360 hexascii_to_byte - convert up to 2 hexascii to bin
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to hex asciiz string
    (max string length is 2)
 OUTPUT
    al = binary value of hex string if no carry flag
    if carry flag set the input data is bad
 NOTES
    source file: hexascii_to_bin.asm

-----------------------------------------------------------------------
361 hexascii_to_dword - convert up to 8 hexascii to bin
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to hex asciiz string
    (max string length is 8)
 OUTPUT
    ecx = binary value of hex string
 NOTES
    source file: hexascii_to_bin.asm

-----------------------------------------------------------------------
362 hexascii_to_nibble - convert hexascii char to bin
-----------------------------------------------------------------------
 INPUTS
    al = contains one hexascii char
    ch = (accumulator for hex, will be shifted left)
 OUTPUT
    ch = hex nibble in lower 4 bits
    if carry flag set the input data is bad
 NOTES
    source file: hexascii_to_bin.asm

-----------------------------------------------------------------------
363 nibble2ascii - convert binary 1-99 to 2 ascii chars 
-----------------------------------------------------------------------
 INPUTS
     al  = binary value
     edi = start of storage area
 OUTPUT
    edi = ptr to end of stored string
    eax,edx destroyed
 NOTES
    source file: nibble2ascii.asm
    If input (al) equals zero, nothing is stored.

-----------------------------------------------------------------------
364 nibble2hexascii - convert one nibble to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     ebx = nibble
     edi = storage point for ascii
       example: to store nibbles sequentially
       mov bl,nibble
       mov edi,storage
       call nibble2hexascii
       add edi,2		;move to next store location 
 OUTPUT
    one ascii character stored at [edi]
      edi decremented by one
      ebx is shifted right
 NOTES
    source file: hex2ascii.asm
    See also: nibble2hexstr

-----------------------------------------------------------------------
365 nibble2hexstr - convert 4-bits to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     al  = hex value
     edi = storage point for ascii
 OUTPUT
    one ascii character stored at [edi]
      edi incremented by one
      eax is shifted right 3 bits
 NOTES
    source file: hex2str.asm
    See also: nibble2hexascii

-----------------------------------------------------------------------
366 nibble2octalascii - convert 3-bits to octal ascii and store
-----------------------------------------------------------------------
 INPUTS
     eax = octal value
     edi = storage point for ascii
 OUTPUT
    one ascii character stored at [edi]
      edi incremented by one
      eax is shifted right 3 bits
 NOTES
    source file: octal2ascii.asm

-----------------------------------------------------------------------
367 nibbleto_hexascii - convert 4-bits to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     al  = hex value
     edi = storage point for ascii
 OUTPUT
    one ascii character stored at [edi]
      edi incremented by one
      eax is shifted right 3 bits
 NOTES
    source file: hex2str.asm
    See also: nibble2hexascii
    The library has numerous hex converstions, this one is
    very compact and moderatly fast, It is the prefered choice.

-----------------------------------------------------------------------
368 octalascii2dword - convert asciiz octal string to dword
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to octal ascii data
 OUTPUT
    ebx = contains octal value
 NOTES
   source file: octalascii2dword.asm
   This routine is also used to convert a string
   to a byte or word  value.

-----------------------------------------------------------------------
369 word2hexascii - convert one word to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     ebx = word
     edi = storage point for ascii +3
      example: to store word  sequentially
      mov   bx,hexword
      mov   edi,buffer + 3
      call  word2hexascii
      add   edi,5 
 OUTPUT
    four ascii characters stored at [edi]
      edi decremented by four
      ebx is shifted right 
 NOTES
    source file: hex2ascii.asm
    See Also: word2hexstr

-----------------------------------------------------------------------
370 word2hexstr - convert one word to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     ebx = word of data
     edi = storage point for hex ascii
 OUTPUT
    six ascii characters stored at [edi]
      edi points beyond last stored char.
      ebx unchanged, eax,ecx modified
 NOTES
    source file: hex2str.asm
    The input word must be in a cleared ebx register
    See also: word2hexascii

-----------------------------------------------------------------------
371 word2octalascii - convert one word to octal ascii and store
-----------------------------------------------------------------------
 INPUTS
     ebx = word of data
     edi = storage point for octal ascii
 OUTPUT
    six ascii characters stored at [edi]
      edi points beyond last stored char.
      ebx unchanged, eax,ecx modified
 NOTES
    source file: octal2ascii.asm

-----------------------------------------------------------------------
372 word_to_ascii - convert binary word to left justified ascii string
-----------------------------------------------------------------------
 INPUTS
      ax = binary value
     edi = start of storage area
 OUTPUT
    edi = ptr to end of stored string
    eax,ebx,ecx destroyed
 NOTES
    source file: dword_to_ascii.asm

-----------------------------------------------------------------------
373 wordto_hexascii - convert one word to hex ascii and store
-----------------------------------------------------------------------
 INPUTS
     eax = word of data
     edi = storage point for hex ascii
 OUTPUT
    four ascii characters stored at [edi]
      edi points beyond last stored char.
      eax modified
 NOTES
    source file: hex2str.asm
    The input word must be in a cleared ebx register
    See also: word2hexascii
    The library has numerous hex converstions, this one is
    very compact and moderatly fast, It is the prefered choice.

-----------------------------------------------------------------------
374 lookup_token - check if token on list
-----------------------------------------------------------------------
 INPUTS
    esi = pointer to token (string)
    edi = pointer to list of legal tokens
          Token list is terminated with
          zero char after last string.

 OUTPUT
    if flag <eq> set, ecx=token index.  First
                 token is index 0
       flag <ne> set, token not on list, ecx
                 set to number of tokens on list
 NOTES
   source file: lookup_token.asm

-----------------------------------------------------------------------
375 parse_token - scan buffer for next token
-----------------------------------------------------------------------
 INPUTS
    eax = pointer to writable input block

    input block definition
      dd <pointer to scan buffer start>
      dd <pointer to scan buffer end>
      db <separator character list>
         eol (0ah) is assumed separator and
         should not be on list.  List appears
         as:  db " ","x",0  Last zero byte terminates
      db 0 ;end of separator list

 OUTPUT
    if <zero flag> token parsed and lib_buf holds token.
                   The token is terminated with zero char.
                   The input block scan start is updated
                   to point at token end (separator char).
       <carry flag> the end of line was reached at
                   last parse, or no tokens on this line.
       <sign flag> The end of scan buffer has been reached,
                   no more tokens available.

    all registers are unchanged

 NOTES
   source file: parse_token.asm

-----------------------------------------------------------------------
376 read_setup - read config file and move data
-----------------------------------------------------------------------
 INPUTS
    ebp = file name ptr, use $HOME as base
    edi = buffer to read file into, must be big enoug
          to hold data
    esi = table with data move information.
    ebx = ptr to enviornment pointers
       table format (esi):
       ptr to name,  ptr to destination, grouping code (4 ascii chars)
       zero ptr to name indicates end of table
       names terminated by space or any char 0-9h
       grouping code is used to destinguish between two identical names,
       this is useful when one name has multiple possible destinations.
     
       input file format (edi):
       <ascii name>=<"string"> space <grouping code>
       ascii name - variable length string without any spaces inside,
          ends with "=" char.
       string - any ascii data enclosed in quotes, space after last quote
       grouping code - any 4 ascii characters matching table grouping code
 OUTPUT
    if name and grouping match table then the "string" is
      moved using table destination ptr.
    stored string is terminated with spaces unitl
    any char 0-9h encountered
     
    if file not found read_setup returns sign bit set
    for js instruction.
    if file found and processed, then jns flag bit set
 NOTES
   source file:  read_setup.asm

-----------------------------------------------------------------------
377 write_setup - write config file
-----------------------------------------------------------------------
 INPUTS
    ebp = file name ptr, use $HOME as base
    edi = buffer to build file
    ebx = table with data move information.
    eax = enviornment ptr to ptrs
       table format:
       ptr to name,  ptr to destination, grouping code
       zero indicates end of table pairs.
       names terminated by space or any char 0-9h
       grouping code is 4 ascii digits used too
         destinguish between identical names.
   
 OUTPUT
    the file name in ebp is written to $HOME dir
    with: <name>=<destination data><space><grouping code><0ah>
 NOTES
   source file: write_setup.asm
   see file read_setup.asm

-----------------------------------------------------------------------
378 delay - delay microseconds or seconds
-----------------------------------------------------------------------
 INPUTS
    eax = if positive it is micoseconds to delay
          if negative it is seconds to delay
 OUTPUT
    none
 NOTES
    source file delay.asm

-----------------------------------------------------------------------
379 is_executable_on_path - check if executable available
-----------------------------------------------------------------------
 INPUTS
         esi = ptr to executable file name
         note: executable filename can be full path, local file
               else the $PATH is searched for file.
         note: call env_stack to setup enviro_ptrs at start of
               program.           
 OUTPUT
         al=0  if executable on path, esi=ptr to full path (in lib_buf+200)
            1  if executable is local,esi=ptr to full path (in lib_buf+200)
         al=-1 if file not executable, not found, or enviro_ptrs not setup
 NOTES
    file /sys/executable_on_path.asm
    lib_buf is used as work buffer.

-----------------------------------------------------------------------
380 launch_app - wrap app and setup for feed with launch_feed
-----------------------------------------------------------------------
 INPUTS
    eax = ptr to command (see below)
    The command is a series of strings with an extra zero
              at end of last string.
    examples: db "/bin/ls",0,0                 ;no parameters, full path
              db "myprogram,0,"parameter1",0,0 ;local executable, one parameter
              db "/bin/bash",0,'-c',0,"myprogram",0,0 ;shell program

    ebx = 0 - normal launch
          1 - tracme launch

    [enviro_ptrs] - is a global library variable needed to find enviornment
                    must be initialized by env_stack call at start
                    of program.
                    If full path is provided or file is local, then
                    enviro_ptrs is not needed.
 OUTPUT
    eax if negative, error
        if positive then it is child process id

 NOTES
    source file is launch.asm     

-----------------------------------------------------------------------
381 launch_feed - feed data to process started by launch_app
-----------------------------------------------------------------------
 INPUT:
        ecx = buffer with key
        edx = amount of data to write
 OUTPUT: error       - eax negative
         done        - eax=write count
 NOTES: see also launch_app, launch_kill

-----------------------------------------------------------------------
382 launch_kill - kill a process started by launch_app 
-----------------------------------------------------------------------
 INPUT:  none
 OUTPUT: none
 NOTES: see also launch_feed, launch_app

-----------------------------------------------------------------------
383 poll_fd - check if data avail.
-----------------------------------------------------------------------
 INPUTS
    eax = fd (file descriptor)
    edx = milliscond wait count,
          -1=forever, 0=immediate return
 OUTPUT
    flags set "js" - error (check before jnz)
              "jz" - no event waiting, or timeout
              "jnz" - event ready
    global variable [poll_rtn2] (word value) has status of poll 
 NOTES
    source file: poll_fd.asm

-----------------------------------------------------------------------
384 sys_fork_run - fork and execute program
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to command line as follows:
       name - executable name terminated with zero byte
       separator - zero byte if end of all parameters, else next parameter appears here
       paramaterx - any string terminated with zero byte
       end - a zero byte.

    examples: db "/bin/dir",0               ;no parameters, full path
              db "myprog,0,"parameter1",0,0 ;local executable, one parameter
              db "dir",0,"*",0,0            ;executable on path, one parameter

    [enviro_ptrs] - must be initialized by env_stack call at start
                    of program.
    buffer "lib_buf" is used to build path
 OUTPUT
    eax = -1 if error
        = launched PID if success
 NOTES
   source file: sys_run.asm

-----------------------------------------------------------------------
385 sys_pipe_capture - launch program and capture its stdout
-----------------------------------------------------------------------
    (the sys_wrap function is a better choice, this function
     is becoming obsolete)
 INPUTS
    [enviro_ptrs] - global set by calling env_stack
    eax = ptr to program string
          this is normal shell command string
    ebx = buffer to hold output from program
    ecx = size of buffer
 OUTPUT
    eax = shell program exit status (in -al-)
          (if eax negative an error occured)
    ebx = updated buffer ptr after data stored.
 NOTES
    source file: sys_pipe_capture.asm

-----------------------------------------------------------------------
386 sys_pipe_feed - launch program and pipe to it's STDIN
-----------------------------------------------------------------------
 INPUTS
    eax = ptr to program string
          this is an ELF executable.
          Not all programs accept a pipe for STDIN
    ebx = pointer to function that will feed characters
          to ELF executable in eax
          The feed program recieves child pid in eax
          and write pipe (fd) in ebx.
    a simple feed program to watch for ESC key:
      feed_keys:
        mov	[fk_pid],eax		;save child pid
        mov	[fk_pipe],ebx		;save output pipe
      key_loop:
        call	key_mouse2
      
        or	al,al
        jz	feed_keys		;jmp if zero read
      
        cmp	word [kbuf],001bh
        je	fk_done			;if esc pressed exit
      
        mov	ebx,[child_pid]
        call	check_pid
        cmp	al,'Z'		;zombie?
        je	fk_done
        cmp	al,'T'		;stopped?
        je	fk_done
      
        mov	ebx,[fk_pipe]
        mov	ecx,kbuf
      ; now pipe (feed) key to our child
      char_loop:
        mov	edx,1
        mov	eax,4
        int	80h
      
        or	eax,eax
        js	fk_done
        inc	ecx
        cmp	byte [ecx],0
        jne	char_loop
        jmp	key_loop
      fk_done:
        ret
      ;--------------
        [section .data]
      fk_pid:	dd	0
      fk_pipe: dd	0
        [section .text]
 OUTPUT
    eax = shell program exit status (in -al-)
          (if eax negative an error occured)
 NOTES
    source file: sys_pipe_feed.asm

-----------------------------------------------------------------------
387 sys_run_die - launches executable then dies
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to command line as follows:
       name - executable name terminated with zero byte
       separator - zero byte if end of all parameters, else next parameter appears here
       paramaterx - any string terminated with zero byte
       end - a zero byte.

    examples: db "/bin/ls",0,0                 ;no parameters, full path
              db "myprogram,0,"parameter1",0,0 ;local executable, one parameter
              db "dir",0,"*",0,0               ;executable on path, one parameter

    [enviro_ptrs] - must be initialized by env_stack call at start
                    of program.
    buffer "lib_buf" is used to build path
 OUTPUT
    al = byte two of execve_status if error occured, else
         no return occurs.
    [execve_status] - contains results from execve
      al = 0 success
      al = 11 could not launch child
      al = 12 name not found on path
      al = negative (system error code)
           -1=enviro_ptrs not setup
      flags set for jz,js,jnz,jns jumps
 NOTES
    source file: sys_run.asm
     
    sys_run_die begins by checking if the full path is provided, if
    not it looks in the local directory, if not found it searchs
    the path.  When found the file is executed

-----------------------------------------------------------------------
388 sys_run_wait - execute program and wait for completiion
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to command line as follows:
       name - executable name terminated with zero byte
       separator - zero byte if end of all parameters, else next parameter appears here
       paramaterx - any string terminated with zero byte
       end - a zero byte.

    examples: db "/bin/dir",0               ;no parameters, full path
              db "myprog,0,"parameter1",0,0 ;local executable, one parameter
              db "dir",0,"*",0,0            ;executable on path, one parameter

    [enviro_ptrs] - must be initialized by env_stack call at start
                    of program.
    buffer "lib_buf" is used to build path
 OUTPUT
    failure - eax= negative error code

    possible
    success - eax=pid of completed process
              
              if bl=0 then bh=process exit code
              if bl=1-7e then bh=signal that killed process
              if bl=7f then bh=signal that stopped process
              if bl=ff then bh=signal that continued process
    flags set for "js" and "jns" on eax state
 NOTES
   source file: sys_run.asm

-----------------------------------------------------------------------
389 sys_shell - launches local shell
-----------------------------------------------------------------------
 INPUTS
    [enviro_ptrs] - global var set by function env_stack
    the global buffer "lib_buf" is used to build path
 OUTPUT
    The enviornment varialbe SHELL is used to find shell
    and it is launched.  The screen is not cleared and
    the shell inherits the path of parent.
     
    al = byte two of execve_status
    [execve_status] - contains results from execve
      al = 0 success
      al = 11 could not launch child
      al = negative (system error code)
      flags set for jz,js,jnz,jns jumps
 NOTES
    source file: sys_shell.asm

-----------------------------------------------------------------------
390 sys_shell_alt - launches local shell in alternate window
-----------------------------------------------------------------------
 INPUTS
    [enviro_ptrs] - global var set by function env_stack
    the global buffer "lib_buf" is used to build path
 OUTPUT
    The enviornment varialbe SHELL is used to find shell
    and it is launched.  The screen is not cleared and
    the shell inherits the path of parent.
     
    al = byte two of execve_status
    [execve_status] - contains results from execve
      al = 0 success
      al = 11 could not launch child
      al = negative (system error code)
      flags set for jz,js,jnz,jns jumps
 NOTES
    source file: sys_shell_alt.asm

-----------------------------------------------------------------------
391 sys_shell_cmd - launches local shell
-----------------------------------------------------------------------
 INPUTS
    [enviro_ptrs] - global var set by function env_stack
    esi = ptr to shell commands
          example: db  "ls -a;ls",0
    the global buffer "lib_buf" is used to build path
 OUTPUT
    The enviornment varialbe SHELL is used to find shell
    and it is launched.  The screen is not cleared and
    the shell inherits the path of parent.
     
    failure - eax= negative error code

    possible
    success - eax=pid of completed process
              
              if bl=0 then bh=process exit code
              if bl=1-7e then bh=signal that killed process
              if bl=7f then bh=signal that stopped process
              if bl=ff then bh=signal that continued process
    flags set for "js" and "jns" on eax state
 NOTES
    source file: sys_shell_cmd.asm

-----------------------------------------------------------------------
392 sys_shell_plus - execute shell and restore terminal state
-----------------------------------------------------------------------
 INPUTS
    eax = shell command string ptr
     bl = flags   01h = crt_open has been called 
                  02h = use alternate screen
 OUTPUT
   eax = negative if error
 NOTES
    source file sys_shell_plus

-----------------------------------------------------------------------
393 sys_win_alt - switches to Vt100 alt windows
-----------------------------------------------------------------------
 INPUTS
    check if in console before using this function
 OUTPUT
    alternate terminal window selected
 NOTES
    source file: sys_shell_alt.asm

-----------------------------------------------------------------------
394 sys_win_normal - selects normal Vt100 windows
-----------------------------------------------------------------------
 INPUTS
  check if in console before calling
 OUTPUT
  normal terminal window selected
 NOTES
  source file: sys_shell_alt.asm

-----------------------------------------------------------------------
395 sys_wrap - wrap around an executable and capture in/out
-----------------------------------------------------------------------
 INPUTS
    eax = ptr to command (see below)
    ebx = ptr to optional input (feed) process (see notes) 
    ecx = ptr to optional output capture process (see notes)

    The command is a series of strings with an extra zero
              at end of last string.

    examples: db "/bin/ls",0,0                 ;no parameters, full path
              db "myprogram,0,"parameter1",0,0 ;local executable, one parameter
              db "/bin/bash",0,'-c',0,"myprogram",0,0 ;shell program

    [enviro_ptrs] - is a global library variable needed to find enviornment
                    must be initialized by env_stack call at start
                    of program.

 OUTPUT
    XX......h     abort_flag -1(normal) 0(in wait) 1(abort)
    ..XX....h     last_kernel_rtn
    ....XX..h     parent_err_flag, 10h+, code location
    ......XXh     harvested_child_status

    [child_pid] - the global variable child_pid is available at
                  sys_wrap executes for possible abort of the child.
                  This might be possible if a program hangs up and
                  somehow keyboard intercept or signal detected the
                  problem.
    [master_fd] - child terminal fd
 
 NOTES
    source file sys_wrap.asm
     
    The optional feed process can be set to zero if not needed.
    If a feed process address is given, it is called after data
    has been read.  The buffer address is in ecx and the number
    of bytes read is in edx.  The data has a zero at end.  The
    feed process can change the data and byte count.  If the byte
    count is set negative the wrapped child will be aborted.
    summary:  input:  ecx=buffer      output:  ecx=buffer
                      edx=byte count           edx=count or abort
    After returning the data will be sent to childs stdin.
     
    The optional capture process is handled like the feed process,
    After returning the data will be sent to stdout.

    The feed and capture process's need to be used cautiously.
    They are running as part of the child input/output call and
    some kernel calls may cause problems.
     

-----------------------------------------------------------------------
396 sys_wrap_plus - wrap around an executable and capture in/out
-----------------------------------------------------------------------
           commands.  Also, restore terminal state.
 INPUTS
    eax = ptr to shell command string
    ebx = ptr to optional input (feed) process (see notes) 
    ecx = ptr to optional output capture process (see notes)
     dl = flags, bit(0) 01h - if set sys_wrap will call shell
     -           -             and assume eax is zero.
     -           -             WARNING - eax is ignored  
     -           -       00h - sys_wrap will assume eax is pointer
     -           -             to command string with program to
     -           -             execute.
     -           bit (1) 02h - if set use alternate screen
     -           bit (2) 04h - if set do crt_close then before
     -                         returning do  crt_open
     -           bit (3) 08h - if set do term reset before exit
     -                         (screen will be cleared)
     -           bit (4) 10h - if set save and restore cursor
     -                         (only works if using alt screen)
    env_stack function must be called prior to using this function
          to find default shell.  If env_stack is not called
          sys_wrap will try using /bin/sh as shell.
 OUTPUT
    al has status, 0 = success 
 NOTES
    file sys_wrap_plus.asm
     
    The optional feed process can be set to zero if not needed.
    If a feed process address is given, it is called after data
    has been read.  The buffer address is in ecx and the number
    of bytes read is in edx.  The data has a zero at end.  The
    feed process can change the data and bye count.  If the byte
    count is set negative the wrapped child will be aborted.
    summary:  input:  ecx=buffer      output:  ecx=buffer
    -                 edx=byte count           edx=count or abort
    After returning the data will be an input to executing child.
    -
    The optional capture process is handled like the feed process,
    except the byte count (edx) can not be used to abort a process.
    After returning the data will be sent to stdout.
    -
    The input data buffer and output data buffer use lib_buf) which
    can have a maximum size of 599 bytes.

-----------------------------------------------------------------------
397 sys_wrap_shell - launches command in wrapped shell
-----------------------------------------------------------------------

 INPUTS
    esi = ptr to command (see below)
    ebx = ptr to optional input (feed) process (see notes) 
    ecx = ptr to optional output capture process (see notes)

    The command is a series of strings with an extra zero
              at end of last string.

    examples: db "/bin/ls",0,0                 ;no parameters, full path
              db "myprogram,0,"parameter1",0,0 ;local executable, one parameter
              db "/bin/bash",0,'-c',0,"myprogram",0,0 ;shell program

    [enviro_ptrs] - is a global library variable needed to find enviornment
                    must be initialized by env_stack call at start
                    of program.

 OUTPUT
    XX......h     abort_flag -1(normal) 0(in wait) 1(abort)
    ..XX....h     last_kernel_rtn
    ....XX..h     parent_err_flag, 10h+, code location
    ......XXh     harvested_child_status

    [child_pid] - the global variable child_pid is available at
                  sys_wrap executes for possible abort of the child.
                  This might be possible if a program hangs up and
                  somehow keyboard intercept or signal detected the
                  problem. 
 NOTES
    source file: sys_wrap_shell.asm
     
    The optional feed process can be set to zero if not needed.
    If a feed process address is given, it is called after data
    has been read.  The buffer address is in ecx and the number
    of bytes read is in edx.  The data has a zero at end.  The
    feed process can change the data and byte count.  If the byte
    count is set negative the wrapped child will be aborted.
    summary:  input:  ecx=buffer      output:  ecx=buffer
                      edx=byte count           edx=count or abort
    After returning the data will be sent to childs stdin.
     
    The optional capture process is handled like the feed process,
    After returning the data will be sent to stdout.

    The feed and capture process's need to be used cautiously.
    They are running as part of the child input/output call and
    some kernel calls may cause problems.
     

-----------------------------------------------------------------------
398 vt_ptty_setup - wrap around an executable and capture in/out
-----------------------------------------------------------------------
 INPUTS
    eax = ptr to command (see below)

    The command is a series of strings with an extra zero
              at end of last string.

    examples: db "/bin/ls",0,0                 ;no parameters, full path
              db "myprogram,0,"parameter1",0,0 ;local executable, one parameter
              db "/bin/bash",0,'-c',0,"myprogram",0,0 ;shell program

    [enviro_ptrs] - is a global library variable needed to find enviornment
                    must be initialized by env_stack call at start
                    of program.

 OUTPUT

    [ptty_fd] - child terminal fd
    If a signal is wanted for the ptty_fd, set it up
    before calling vt_ptty_launch.  If no signal the
    ptty_fd needs to be polled and serviced.
 
 NOTES
    source file vt_ptty.asm
     

-----------------------------------------------------------------------
399 wait_event - poll fd input/output status
-----------------------------------------------------------------------
 INPUTS
    esi = array of dword fd's terminated by -1
    eax = max wait time(usec), or zero to wait forever, and
          minus 1 for immediate return of status
 OUTPUT
    eax = 0 child has died? signal?
        = negative, then error/signal active(-4)
        = positive number of events pending
    ecx = ptr to array of bits set for each fd with
          pending actions, bit 1 represents stdin (fd 0).
          fd's must be in numerical order (small to large).
 NOTES
    source file wait_event.asm
    note: see bit_test, bit_set_list

-----------------------------------------------------------------------
400 wait_pid - wait for a process to change state
-----------------------------------------------------------------------
 INPUTS
    ebx = (-1)      wait for any child
          (-group#) wait for group
          0         wait for child in our group
          pid       wait for individual process by  pid
    edx = 0 wait for child
          1 WNOHANG, return status immediatly if no child has exited.
            If no children are waiting then return without updating
            status, this means we need to preload status with a value.
          2 WUNTRACED, return if child stopped   

 OUTPUT
    eax = positive pid if success, status in edx
        = negative error, only -1 is defined.

    The format of status in edx is:
      if bl=0 then process exited, return status in bh
         if bh=0 it could be return code or no process found.
      if bl=(1-7e) then bh = signal that killed process
      if bl=7fh then bh = signal that stopped process
      if bl=ffh then bh = signal that continued process
 NOTES
    source file wait_pid.asm
    note: see also wait_event

-----------------------------------------------------------------------
401 is_multi_cpu - is OS handling multi cpu's or cores
-----------------------------------------------------------------------
 INPUT
   ebp = pointer to buffer of at least 800 bytes
 OUTPUT
   ecx = core count (this cpu)
   ebx = siblings (total cores in all cpu's)
 NOTE

-----------------------------------------------------------------------
402 our_core - what cpu core are we running on
-----------------------------------------------------------------------
 INPUT
   ebp = buffer of at least 799 bytes
 OUTPUT
   eax = core number we are running on. (0=first)
 NOTE

-----------------------------------------------------------------------
403 select_core - select execution cpu core
-----------------------------------------------------------------------
 INPUT
   eax = pid to assign a core
   ebp = buffer of at least 128 bytes
 OUTPUT
   output of sys_sched_afinity kernel call
 NOTE

-----------------------------------------------------------------------
404 sys__llseek - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys__llseek                                         

    Note: functon call consists of four instructions
          
          sys__llseek:                                      
              mov  eax,140    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
405 sys__newselect - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys__newselect                                      

    Note: functon call consists of four instructions
          
          sys__newselect:                                   
              mov  eax,142    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
406 sys__sysctl - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys__sysctl                                         

    Note: functon call consists of four instructions
          
          sys__sysctl:                                      
              mov  eax,149    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
407 sys_access - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_access                                          

    Note: functon call consists of four instructions
          
          sys_access:                                       
              mov  eax,33     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
408 sys_acct - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_acct                                            

    Note: functon call consists of four instructions
          
          sys_acct:                                         
              mov  eax,51     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
409 sys_add_key - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_add_key                                         

    Note: functon call consists of four instructions
          
          sys_add_key:                                      
              mov  eax,286    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
410 sys_adjtimex - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_adjtimex                                        

    Note: functon call consists of four instructions
          
          sys_adjtimex:                                     
              mov  eax,124    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
411 sys_afs_syscall - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_afs_syscall                                     

    Note: functon call consists of four instructions
          
          sys_afs_syscall:                                  
              mov  eax,137    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
412 sys_alarm - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_alarm                                           

    Note: functon call consists of four instructions
          
          sys_alarm:                                        
              mov  eax,27     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
413 sys_bdflush - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_bdflush                                         

    Note: functon call consists of four instructions
          
          sys_bdflush:                                      
              mov  eax,134    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
414 sys_break - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_break                                           

    Note: functon call consists of four instructions
          
          sys_break:                                        
              mov  eax,17     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
415 sys_brk - kernel function                                 
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_brk                                             

    Note: functon call consists of four instructions
          
          sys_brk:                                          
              mov  eax,45     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
416 sys_capget - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_capget                                          

    Note: functon call consists of four instructions
          
          sys_capget:                                       
              mov  eax,184    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
417 sys_capset - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_capset                                          

    Note: functon call consists of four instructions
          
          sys_capset:                                       
              mov  eax,185    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
418 sys_chdir - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_chdir                                           

    Note: functon call consists of four instructions
          
          sys_chdir:                                        
              mov  eax,12     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
419 sys_chmod - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_chmod                                           

    Note: functon call consists of four instructions
          
          sys_chmod:                                        
              mov  eax,15     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
420 sys_chown - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_chown                                           

    Note: functon call consists of four instructions
          
          sys_chown:                                        
              mov  eax,182    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
421 sys_chown32 - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_chown32                                         

    Note: functon call consists of four instructions
          
          sys_chown32:                                      
              mov  eax,212    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
422 sys_chroot - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_chroot                                          

    Note: functon call consists of four instructions
          
          sys_chroot:                                       
              mov  eax,61     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
423 sys_clone - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_clone                                           

    Note: functon call consists of four instructions
          
          sys_clone:                                        
              mov  eax,120    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
424 sys_close - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_close                                           

    Note: functon call consists of four instructions
          
          sys_close:                                        
              mov  eax,6      
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
425 sys_creat - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_creat                                           

    Note: functon call consists of four instructions
          
          sys_creat:                                        
              mov  eax,8      
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
426 sys_create_module - kernel function                       
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_create_module                                   

    Note: functon call consists of four instructions
          
          sys_create_module:                                
              mov  eax,127    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
427 sys_delete_module - kernel function                       
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_delete_module                                   

    Note: functon call consists of four instructions
          
          sys_delete_module:                                
              mov  eax,129    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
428 sys_dup - kernel function                                 
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_dup                                             

    Note: functon call consists of four instructions
          
          sys_dup:                                          
              mov  eax,41     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
429 sys_dup2 - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_dup2                                            

    Note: functon call consists of four instructions
          
          sys_dup2:                                         
              mov  eax,63     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
430 sys_epoll_create - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_epoll_create                                    

    Note: functon call consists of four instructions
          
          sys_epoll_create:                                 
              mov  eax,254    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
431 sys_epoll_ctl - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_epoll_ctl                                       

    Note: functon call consists of four instructions
          
          sys_epoll_ctl:                                    
              mov  eax,255    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
432 sys_epoll_pwait - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_epoll_pwait                                     

    Note: functon call consists of four instructions
          
          sys_epoll_pwait:                                  
              mov  eax,319    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
433 sys_epoll_wait - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_epoll_wait                                      

    Note: functon call consists of four instructions
          
          sys_epoll_wait:                                   
              mov  eax,256    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
434 sys_eventfd - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_eventfd                                         

    Note: functon call consists of four instructions
          
          sys_eventfd:                                      
              mov  eax,323    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
435 sys_execve - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_execve                                          

    Note: functon call consists of four instructions
          
          sys_execve:                                       
              mov  eax,11     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
436 sys_exit - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_exit                                            

    Note: functon call consists of four instructions
          
          sys_exit:                                         
              mov  eax,1      
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
437 sys_exit_group - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_exit_group                                      

    Note: functon call consists of four instructions
          
          sys_exit_group:                                   
              mov  eax,252    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
438 sys_faccessat - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_faccessat                                       

    Note: functon call consists of four instructions
          
          sys_faccessat:                                    
              mov  eax,307    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
439 sys_fadvise64 - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fadvise64                                       

    Note: functon call consists of four instructions
          
          sys_fadvise64:                                    
              mov  eax,250    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
440 sys_fadvise64_64 - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fadvise64_64                                    

    Note: functon call consists of four instructions
          
          sys_fadvise64_64:                                 
              mov  eax,272    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
441 sys_fallocate - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fallocate                                       

    Note: functon call consists of four instructions
          
          sys_fallocate:                                    
              mov  eax,324    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
442 sys_fchdir - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fchdir                                          

    Note: functon call consists of four instructions
          
          sys_fchdir:                                       
              mov  eax,133    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
443 sys_fchmod - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fchmod                                          

    Note: functon call consists of four instructions
          
          sys_fchmod:                                       
              mov  eax,94     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
444 sys_fchmodat - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fchmodat                                        

    Note: functon call consists of four instructions
          
          sys_fchmodat:                                     
              mov  eax,306    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
445 sys_fchown - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fchown                                          

    Note: functon call consists of four instructions
          
          sys_fchown:                                       
              mov  eax,95     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
446 sys_fchown32 - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fchown32                                        

    Note: functon call consists of four instructions
          
          sys_fchown32:                                     
              mov  eax,207    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
447 sys_fchownat - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fchownat                                        

    Note: functon call consists of four instructions
          
          sys_fchownat:                                     
              mov  eax,298    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
448 sys_fcntl - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fcntl                                           

    Note: functon call consists of four instructions
          
          sys_fcntl:                                        
              mov  eax,55     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
449 sys_fcntl64 - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fcntl64                                         

    Note: functon call consists of four instructions
          
          sys_fcntl64:                                      
              mov  eax,221    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
450 sys_fdatasync - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fdatasync                                       

    Note: functon call consists of four instructions
          
          sys_fdatasync:                                    
              mov  eax,148    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
451 sys_fgetxattr - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fgetxattr                                       

    Note: functon call consists of four instructions
          
          sys_fgetxattr:                                    
              mov  eax,231    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
452 sys_flistxattr - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_flistxattr                                      

    Note: functon call consists of four instructions
          
          sys_flistxattr:                                   
              mov  eax,234    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
453 sys_flock - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_flock                                           

    Note: functon call consists of four instructions
          
          sys_flock:                                        
              mov  eax,143    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
454 sys_fork - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fork                                            

    Note: functon call consists of four instructions
          
          sys_fork:                                         
              mov  eax,2      
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
455 sys_fremovexattr - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fremovexattr                                    

    Note: functon call consists of four instructions
          
          sys_fremovexattr:                                 
              mov  eax,237    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
456 sys_fsetxattr - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fsetxattr                                       

    Note: functon call consists of four instructions
          
          sys_fsetxattr:                                    
              mov  eax,228    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
457 sys_fstat - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fstat                                           

    Note: functon call consists of four instructions
          
          sys_fstat:                                        
              mov  eax,108    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
458 sys_fstat64 - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fstat64                                         

    Note: functon call consists of four instructions
          
          sys_fstat64:                                      
              mov  eax,197    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
459 sys_fstatat64 - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fstatat64                                       

    Note: functon call consists of four instructions
          
          sys_fstatat64:                                    
              mov  eax,300    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
460 sys_fstatfs - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fstatfs                                         

    Note: functon call consists of four instructions
          
          sys_fstatfs:                                      
              mov  eax,100    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
461 sys_fstatfs64 - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fstatfs64                                       

    Note: functon call consists of four instructions
          
          sys_fstatfs64:                                    
              mov  eax,269    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
462 sys_fsync - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_fsync                                           

    Note: functon call consists of four instructions
          
          sys_fsync:                                        
              mov  eax,118    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
463 sys_ftime - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ftime                                           

    Note: functon call consists of four instructions
          
          sys_ftime:                                        
              mov  eax,35     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
464 sys_ftruncate - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ftruncate                                       

    Note: functon call consists of four instructions
          
          sys_ftruncate:                                    
              mov  eax,93     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
465 sys_ftruncate64 - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ftruncate64                                     

    Note: functon call consists of four instructions
          
          sys_ftruncate64:                                  
              mov  eax,194    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
466 sys_futex - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_futex                                           

    Note: functon call consists of four instructions
          
          sys_futex:                                        
              mov  eax,240    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
467 sys_futimesat - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_futimesat                                       

    Note: functon call consists of four instructions
          
          sys_futimesat:                                    
              mov  eax,299    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
468 sys_get_kernel_syms - kernel function                     
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_get_kernel_syms                                 

    Note: functon call consists of four instructions
          
          sys_get_kernel_syms:                              
              mov  eax,130    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
469 sys_get_mempolicy - kernel function                       
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_get_mempolicy                                   

    Note: functon call consists of four instructions
          
          sys_get_mempolicy:                                
              mov  eax,275    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
470 sys_get_robust_list - kernel function                     
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_get_robust_list                                 

    Note: functon call consists of four instructions
          
          sys_get_robust_list:                              
              mov  eax,312    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
471 sys_get_thread_area - kernel function                     
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_get_thread_area                                 

    Note: functon call consists of four instructions
          
          sys_get_thread_area:                              
              mov  eax,244    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
472 sys_getcpu - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getcpu                                          

    Note: functon call consists of four instructions
          
          sys_getcpu:                                       
              mov  eax,318    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
473 sys_getcwd - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getcwd                                          

    Note: functon call consists of four instructions
          
          sys_getcwd:                                       
              mov  eax,183    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
474 sys_getdents - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getdents                                        

    Note: functon call consists of four instructions
          
          sys_getdents:                                     
              mov  eax,141    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
475 sys_getdents64 - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getdents64                                      

    Note: functon call consists of four instructions
          
          sys_getdents64:                                   
              mov  eax,220    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
476 sys_getegid - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getegid                                         

    Note: functon call consists of four instructions
          
          sys_getegid:                                      
              mov  eax,50     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
477 sys_getegid32 - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getegid32                                       

    Note: functon call consists of four instructions
          
          sys_getegid32:                                    
              mov  eax,202    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
478 sys_geteuid - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_geteuid                                         

    Note: functon call consists of four instructions
          
          sys_geteuid:                                      
              mov  eax,49     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
479 sys_geteuid32 - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_geteuid32                                       

    Note: functon call consists of four instructions
          
          sys_geteuid32:                                    
              mov  eax,201    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
480 sys_getgid - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getgid                                          

    Note: functon call consists of four instructions
          
          sys_getgid:                                       
              mov  eax,47     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
481 sys_getgid32 - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getgid32                                        

    Note: functon call consists of four instructions
          
          sys_getgid32:                                     
              mov  eax,200    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
482 sys_getgroups - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getgroups                                       

    Note: functon call consists of four instructions
          
          sys_getgroups:                                    
              mov  eax,80     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
483 sys_getgroups32 - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getgroups32                                     

    Note: functon call consists of four instructions
          
          sys_getgroups32:                                  
              mov  eax,205    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
484 sys_getitimer - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getitimer                                       

    Note: functon call consists of four instructions
          
          sys_getitimer:                                    
              mov  eax,105    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
485 sys_getpgid - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getpgid                                         

    Note: functon call consists of four instructions
          
          sys_getpgid:                                      
              mov  eax,132    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
486 sys_getpgrp - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getpgrp                                         

    Note: functon call consists of four instructions
          
          sys_getpgrp:                                      
              mov  eax,65     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
487 sys_getpid - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getpid                                          

    Note: functon call consists of four instructions
          
          sys_getpid:                                       
              mov  eax,20     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
488 sys_getpmsg - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getpmsg                                         

    Note: functon call consists of four instructions
          
          sys_getpmsg:                                      
              mov  eax,188    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
489 sys_getppid - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getppid                                         

    Note: functon call consists of four instructions
          
          sys_getppid:                                      
              mov  eax,64     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
490 sys_getpriority - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getpriority                                     

    Note: functon call consists of four instructions
          
          sys_getpriority:                                  
              mov  eax,96     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
491 sys_getresgid - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getresgid                                       

    Note: functon call consists of four instructions
          
          sys_getresgid:                                    
              mov  eax,171    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
492 sys_getresgid32 - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getresgid32                                     

    Note: functon call consists of four instructions
          
          sys_getresgid32:                                  
              mov  eax,211    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
493 sys_getresuid - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getresuid                                       

    Note: functon call consists of four instructions
          
          sys_getresuid:                                    
              mov  eax,165    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
494 sys_getresuid32 - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getresuid32                                     

    Note: functon call consists of four instructions
          
          sys_getresuid32:                                  
              mov  eax,209    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
495 sys_getrlimit - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getrlimit                                       

    Note: functon call consists of four instructions
          
          sys_getrlimit:                                    
              mov  eax,76     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
496 sys_getrusage - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getrusage                                       

    Note: functon call consists of four instructions
          
          sys_getrusage:                                    
              mov  eax,77     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
497 sys_getsid - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getsid                                          

    Note: functon call consists of four instructions
          
          sys_getsid:                                       
              mov  eax,147    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
498 sys_gettid - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_gettid                                          

    Note: functon call consists of four instructions
          
          sys_gettid:                                       
              mov  eax,224    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
499 sys_gettimeofday - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_gettimeofday                                    

    Note: functon call consists of four instructions
          
          sys_gettimeofday:                                 
              mov  eax,78     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
500 sys_getuid - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getuid                                          

    Note: functon call consists of four instructions
          
          sys_getuid:                                       
              mov  eax,24     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
501 sys_getuid32 - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getuid32                                        

    Note: functon call consists of four instructions
          
          sys_getuid32:                                     
              mov  eax,199    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
502 sys_getxattr - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_getxattr                                        

    Note: functon call consists of four instructions
          
          sys_getxattr:                                     
              mov  eax,229    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
503 sys_gtty - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_gtty                                            

    Note: functon call consists of four instructions
          
          sys_gtty:                                         
              mov  eax,32     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
504 sys_idle - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_idle                                            

    Note: functon call consists of four instructions
          
          sys_idle:                                         
              mov  eax,112    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
505 sys_init_module - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_init_module                                     

    Note: functon call consists of four instructions
          
          sys_init_module:                                  
              mov  eax,128    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
506 sys_inotify_add_watch - kernel function                   
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_inotify_add_watch                               

    Note: functon call consists of four instructions
          
          sys_inotify_add_watch:                            
              mov  eax,292    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
507 sys_inotify_init - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_inotify_init                                    

    Note: functon call consists of four instructions
          
          sys_inotify_init:                                 
              mov  eax,291    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
508 sys_inotify_rm_watch - kernel function                    
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_inotify_rm_watch                                

    Note: functon call consists of four instructions
          
          sys_inotify_rm_watch:                             
              mov  eax,293    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
509 sys_io_cancel - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_io_cancel                                       

    Note: functon call consists of four instructions
          
          sys_io_cancel:                                    
              mov  eax,249    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
510 sys_io_destroy - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_io_destroy                                      

    Note: functon call consists of four instructions
          
          sys_io_destroy:                                   
              mov  eax,246    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
511 sys_io_getevents - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_io_getevents                                    

    Note: functon call consists of four instructions
          
          sys_io_getevents:                                 
              mov  eax,247    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
512 sys_io_setup - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_io_setup                                        

    Note: functon call consists of four instructions
          
          sys_io_setup:                                     
              mov  eax,245    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
513 sys_io_submit - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_io_submit                                       

    Note: functon call consists of four instructions
          
          sys_io_submit:                                    
              mov  eax,248    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
514 sys_ioctl - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ioctl                                           

    Note: functon call consists of four instructions
          
          sys_ioctl:                                        
              mov  eax,54     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
515 sys_ioperm - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ioperm                                          

    Note: functon call consists of four instructions
          
          sys_ioperm:                                       
              mov  eax,101    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
516 sys_iopl - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_iopl                                            

    Note: functon call consists of four instructions
          
          sys_iopl:                                         
              mov  eax,110    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
517 sys_ioprio_get - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ioprio_get                                      

    Note: functon call consists of four instructions
          
          sys_ioprio_get:                                   
              mov  eax,290    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
518 sys_ioprio_set - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ioprio_set                                      

    Note: functon call consists of four instructions
          
          sys_ioprio_set:                                   
              mov  eax,289    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
519 sys_ipc - kernel function                                 
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ipc                                             

    Note: functon call consists of four instructions
          
          sys_ipc:                                          
              mov  eax,117    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
520 sys_kexec_load - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_kexec_load                                      

    Note: functon call consists of four instructions
          
          sys_kexec_load:                                   
              mov  eax,283    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
521 sys_keyctl - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_keyctl                                          

    Note: functon call consists of four instructions
          
          sys_keyctl:                                       
              mov  eax,288    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
522 sys_kill - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_kill                                            

    Note: functon call consists of four instructions
          
          sys_kill:                                         
              mov  eax,37     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
523 sys_lchown - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_lchown                                          

    Note: functon call consists of four instructions
          
          sys_lchown:                                       
              mov  eax,16     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
524 sys_lchown32 - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_lchown32                                        

    Note: functon call consists of four instructions
          
          sys_lchown32:                                     
              mov  eax,198    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
525 sys_lgetxattr - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_lgetxattr                                       

    Note: functon call consists of four instructions
          
          sys_lgetxattr:                                    
              mov  eax,230    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
526 sys_link - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_link                                            

    Note: functon call consists of four instructions
          
          sys_link:                                         
              mov  eax,9      
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
527 sys_linkat - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_linkat                                          

    Note: functon call consists of four instructions
          
          sys_linkat:                                       
              mov  eax,303    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
528 sys_listxattr - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_listxattr                                       

    Note: functon call consists of four instructions
          
          sys_listxattr:                                    
              mov  eax,232    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
529 sys_llistxattr - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_llistxattr                                      

    Note: functon call consists of four instructions
          
          sys_llistxattr:                                   
              mov  eax,233    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
530 sys_lock - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_lock                                            

    Note: functon call consists of four instructions
          
          sys_lock:                                         
              mov  eax,53     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
531 sys_lookup_dcookie - kernel function                      
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_lookup_dcookie                                  

    Note: functon call consists of four instructions
          
          sys_lookup_dcookie:                               
              mov  eax,253    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
532 sys_lremovexattr - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_lremovexattr                                    

    Note: functon call consists of four instructions
          
          sys_lremovexattr:                                 
              mov  eax,236    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
533 sys_lseek - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_lseek                                           

    Note: functon call consists of four instructions
          
          sys_lseek:                                        
              mov  eax,19     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
534 sys_lsetxattr - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_lsetxattr                                       

    Note: functon call consists of four instructions
          
          sys_lsetxattr:                                    
              mov  eax,227    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
535 sys_lstat - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_lstat                                           

    Note: functon call consists of four instructions
          
          sys_lstat:                                        
              mov  eax,107    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
536 sys_lstat64 - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_lstat64                                         

    Note: functon call consists of four instructions
          
          sys_lstat64:                                      
              mov  eax,196    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
537 sys_madvise - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_madvise                                         

    Note: functon call consists of four instructions
          
          sys_madvise:                                      
              mov  eax,219    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
538 sys_madvise1 - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_madvise1                                        

    Note: functon call consists of four instructions
          
          sys_madvise1:                                     
              mov  eax,219    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
539 sys_mbind - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mbind                                           

    Note: functon call consists of four instructions
          
          sys_mbind:                                        
              mov  eax,274    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
540 sys_migrate_pages - kernel function                       
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_migrate_pages                                   

    Note: functon call consists of four instructions
          
          sys_migrate_pages:                                
              mov  eax,294    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
541 sys_mincore - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mincore                                         

    Note: functon call consists of four instructions
          
          sys_mincore:                                      
              mov  eax,218    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
542 sys_mkdir - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mkdir                                           

    Note: functon call consists of four instructions
          
          sys_mkdir:                                        
              mov  eax,39     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
543 sys_mkdirat - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mkdirat                                         

    Note: functon call consists of four instructions
          
          sys_mkdirat:                                      
              mov  eax,296    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
544 sys_mknod - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mknod                                           

    Note: functon call consists of four instructions
          
          sys_mknod:                                        
              mov  eax,14     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
545 sys_mknodat - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mknodat                                         

    Note: functon call consists of four instructions
          
          sys_mknodat:                                      
              mov  eax,297    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
546 sys_mlock - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mlock                                           

    Note: functon call consists of four instructions
          
          sys_mlock:                                        
              mov  eax,150    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
547 sys_mlockall - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mlockall                                        

    Note: functon call consists of four instructions
          
          sys_mlockall:                                     
              mov  eax,152    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
548 sys_mmap - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mmap                                            

    Note: functon call consists of four instructions
          
          sys_mmap:                                         
              mov  eax,90     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
549 sys_mmap2 - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mmap2                                           

    Note: functon call consists of four instructions
          
          sys_mmap2:                                        
              mov  eax,192    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
550 sys_modify_ldt - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_modify_ldt                                      

    Note: functon call consists of four instructions
          
          sys_modify_ldt:                                   
              mov  eax,123    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
551 sys_mount - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mount                                           

    Note: functon call consists of four instructions
          
          sys_mount:                                        
              mov  eax,21     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
552 sys_move_pages - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_move_pages                                      

    Note: functon call consists of four instructions
          
          sys_move_pages:                                   
              mov  eax,317    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
553 sys_mprotect - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mprotect                                        

    Note: functon call consists of four instructions
          
          sys_mprotect:                                     
              mov  eax,125    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
554 sys_mpx - kernel function                                 
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mpx                                             

    Note: functon call consists of four instructions
          
          sys_mpx:                                          
              mov  eax,56     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
555 sys_mq_open - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mq_open                                         

    Note: functon call consists of four instructions
          
          sys_mq_open:                                      
              mov  eax,277    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
556 sys_mremap - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_mremap                                          

    Note: functon call consists of four instructions
          
          sys_mremap:                                       
              mov  eax,163    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
557 sys_msync - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_msync                                           

    Note: functon call consists of four instructions
          
          sys_msync:                                        
              mov  eax,144    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
558 sys_munlock - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_munlock                                         

    Note: functon call consists of four instructions
          
          sys_munlock:                                      
              mov  eax,151    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
559 sys_munlockall - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_munlockall                                      

    Note: functon call consists of four instructions
          
          sys_munlockall:                                   
              mov  eax,153    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
560 sys_munmap - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_munmap                                          

    Note: functon call consists of four instructions
          
          sys_munmap:                                       
              mov  eax,91     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
561 sys_nanosleep - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_nanosleep                                       

    Note: functon call consists of four instructions
          
          sys_nanosleep:                                    
              mov  eax,162    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
562 sys_nfsservctl - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_nfsservctl                                      

    Note: functon call consists of four instructions
          
          sys_nfsservctl:                                   
              mov  eax,169    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
563 sys_nice - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_nice                                            

    Note: functon call consists of four instructions
          
          sys_nice:                                         
              mov  eax,34     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
564 sys_oldfstat - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_oldfstat                                        

    Note: functon call consists of four instructions
          
          sys_oldfstat:                                     
              mov  eax,28     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
565 sys_oldlstat - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_oldlstat                                        

    Note: functon call consists of four instructions
          
          sys_oldlstat:                                     
              mov  eax,84     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
566 sys_oldolduname - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_oldolduname                                     

    Note: functon call consists of four instructions
          
          sys_oldolduname:                                  
              mov  eax,59     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
567 sys_oldstat - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_oldstat                                         

    Note: functon call consists of four instructions
          
          sys_oldstat:                                      
              mov  eax,18     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
568 sys_olduname - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_olduname                                        

    Note: functon call consists of four instructions
          
          sys_olduname:                                     
              mov  eax,109    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
569 sys_open - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_open                                            

    Note: functon call consists of four instructions
          
          sys_open:                                         
              mov  eax,5      
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
570 sys_openat - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_openat                                          

    Note: functon call consists of four instructions
          
          sys_openat:                                       
              mov  eax,295    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
571 sys_pause - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_pause                                           

    Note: functon call consists of four instructions
          
          sys_pause:                                        
              mov  eax,29     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
572 sys_personality - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_personality                                     

    Note: functon call consists of four instructions
          
          sys_personality:                                  
              mov  eax,136    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
573 sys_pipe - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_pipe                                            

    Note: functon call consists of four instructions
          
          sys_pipe:                                         
              mov  eax,42     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
574 sys_pivot_root - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_pivot_root                                      

    Note: functon call consists of four instructions
          
          sys_pivot_root:                                   
              mov  eax,217    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
575 sys_poll - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_poll                                            

    Note: functon call consists of four instructions
          
          sys_poll:                                         
              mov  eax,168    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
576 sys_ppoll - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ppoll                                           

    Note: functon call consists of four instructions
          
          sys_ppoll:                                        
              mov  eax,309    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
577 sys_prctl - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_prctl                                           

    Note: functon call consists of four instructions
          
          sys_prctl:                                        
              mov  eax,172    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
578 sys_pread64 - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_pread64                                         

    Note: functon call consists of four instructions
          
          sys_pread64:                                      
              mov  eax,180    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
579 sys_prof - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_prof                                            

    Note: functon call consists of four instructions
          
          sys_prof:                                         
              mov  eax,44     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
580 sys_profil - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_profil                                          

    Note: functon call consists of four instructions
          
          sys_profil:                                       
              mov  eax,98     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
581 sys_pselect6 - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_pselect6                                        

    Note: functon call consists of four instructions
          
          sys_pselect6:                                     
              mov  eax,308    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
582 sys_ptrace - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ptrace                                          

    Note: functon call consists of four instructions
          
          sys_ptrace:                                       
              mov  eax,26     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
583 sys_putpmsg - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_putpmsg                                         

    Note: functon call consists of four instructions
          
          sys_putpmsg:                                      
              mov  eax,189    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
584 sys_pwrite64 - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_pwrite64                                        

    Note: functon call consists of four instructions
          
          sys_pwrite64:                                     
              mov  eax,181    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
585 sys_query_module - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_query_module                                    

    Note: functon call consists of four instructions
          
          sys_query_module:                                 
              mov  eax,167    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
586 sys_quotactl - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_quotactl                                        

    Note: functon call consists of four instructions
          
          sys_quotactl:                                     
              mov  eax,131    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
587 sys_read - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_read                                            

    Note: functon call consists of four instructions
          
          sys_read:                                         
              mov  eax,3      
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
588 sys_readahead - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_readahead                                       

    Note: functon call consists of four instructions
          
          sys_readahead:                                    
              mov  eax,225    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
589 sys_readdir - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_readdir                                         

    Note: functon call consists of four instructions
          
          sys_readdir:                                      
              mov  eax,89     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
590 sys_readlink - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_readlink                                        

    Note: functon call consists of four instructions
          
          sys_readlink:                                     
              mov  eax,85     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
591 sys_readlinkat - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_readlinkat                                      

    Note: functon call consists of four instructions
          
          sys_readlinkat:                                   
              mov  eax,305    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
592 sys_readv - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_readv                                           

    Note: functon call consists of four instructions
          
          sys_readv:                                        
              mov  eax,145    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
593 sys_reboot - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_reboot                                          

    Note: functon call consists of four instructions
          
          sys_reboot:                                       
              mov  eax,88     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
594 sys_remap_file_pages - kernel function                    
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_remap_file_pages                                

    Note: functon call consists of four instructions
          
          sys_remap_file_pages:                             
              mov  eax,257    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
595 sys_removexattr - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_removexattr                                     

    Note: functon call consists of four instructions
          
          sys_removexattr:                                  
              mov  eax,235    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
596 sys_rename - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_rename                                          

    Note: functon call consists of four instructions
          
          sys_rename:                                       
              mov  eax,38     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
597 sys_renameat - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_renameat                                        

    Note: functon call consists of four instructions
          
          sys_renameat:                                     
              mov  eax,302    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
598 sys_request_key - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_request_key                                     

    Note: functon call consists of four instructions
          
          sys_request_key:                                  
              mov  eax,287    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
599 sys_restart_syscall - kernel function                     
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_restart_syscall                                 

    Note: functon call consists of four instructions
          
          sys_restart_syscall:                              
              mov  eax,0      
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
600 sys_rmdir - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_rmdir                                           

    Note: functon call consists of four instructions
          
          sys_rmdir:                                        
              mov  eax,40     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
601 sys_rt_sigaction - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_rt_sigaction                                    

    Note: functon call consists of four instructions
          
          sys_rt_sigaction:                                 
              mov  eax,174    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
602 sys_rt_sigpending - kernel function                       
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_rt_sigpending                                   

    Note: functon call consists of four instructions
          
          sys_rt_sigpending:                                
              mov  eax,176    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
603 sys_rt_sigprocmask - kernel function                      
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_rt_sigprocmask                                  

    Note: functon call consists of four instructions
          
          sys_rt_sigprocmask:                               
              mov  eax,175    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
604 sys_rt_sigqueueinfo - kernel function                     
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_rt_sigqueueinfo                                 

    Note: functon call consists of four instructions
          
          sys_rt_sigqueueinfo:                              
              mov  eax,178    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
605 sys_rt_sigreturn - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_rt_sigreturn                                    

    Note: functon call consists of four instructions
          
          sys_rt_sigreturn:                                 
              mov  eax,173    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
606 sys_rt_sigsuspend - kernel function                       
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_rt_sigsuspend                                   

    Note: functon call consists of four instructions
          
          sys_rt_sigsuspend:                                
              mov  eax,179    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
607 sys_rt_sigtimedwait - kernel function                     
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_rt_sigtimedwait                                 

    Note: functon call consists of four instructions
          
          sys_rt_sigtimedwait:                              
              mov  eax,177    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
608 sys_sched_get_priority_min - kernel function              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sched_get_priority_min                          

    Note: functon call consists of four instructions
          
          sys_sched_get_priority_min:                       
              mov  eax,160    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
609 sys_sched_get_priority_max - kernel function              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sched_get_priority_max                          

    Note: functon call consists of four instructions
          
          sys_sched_get_priority_max:                       
              mov  eax,159    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
610 sys_sched_getaffinity - kernel function                   
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sched_getaffinity                               

    Note: functon call consists of four instructions
          
          sys_sched_getaffinity:                            
              mov  eax,242    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
611 sys_sched_getparam - kernel function                      
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sched_getparam                                  

    Note: functon call consists of four instructions
          
          sys_sched_getparam:                               
              mov  eax,155    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
612 sys_sched_getscheduler - kernel function                  
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sched_getscheduler                              

    Note: functon call consists of four instructions
          
          sys_sched_getscheduler:                           
              mov  eax,157    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
613 sys_sched_rr_get_interval - kernel function               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sched_rr_get_interval                           

    Note: functon call consists of four instructions
          
          sys_sched_rr_get_interval:                        
              mov  eax,161    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
614 sys_sched_setaffinity - kernel function                   
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sched_setaffinity                               

    Note: functon call consists of four instructions
          
          sys_sched_setaffinity:                            
              mov  eax,241    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
615 sys_sched_setparam - kernel function                      
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sched_setparam                                  

    Note: functon call consists of four instructions
          
          sys_sched_setparam:                               
              mov  eax,154    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
616 sys_sched_setscheduler - kernel function                  
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sched_setscheduler                              

    Note: functon call consists of four instructions
          
          sys_sched_setscheduler:                           
              mov  eax,156    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
617 sys_sched_yield - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sched_yield                                     

    Note: functon call consists of four instructions
          
          sys_sched_yield:                                  
              mov  eax,158    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
618 sys_select - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_select                                          

    Note: functon call consists of four instructions
          
          sys_select:                                       
              mov  eax,82     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
619 sys_sendfile - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sendfile                                        

    Note: functon call consists of four instructions
          
          sys_sendfile:                                     
              mov  eax,187    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
620 sys_sendfile64 - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sendfile64                                      

    Note: functon call consists of four instructions
          
          sys_sendfile64:                                   
              mov  eax,239    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
621 sys_set_mempolicy - kernel function                       
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_set_mempolicy                                   

    Note: functon call consists of four instructions
          
          sys_set_mempolicy:                                
              mov  eax,276    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
622 sys_set_robust_list - kernel function                     
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_set_robust_list                                 

    Note: functon call consists of four instructions
          
          sys_set_robust_list:                              
              mov  eax,311    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
623 sys_set_thread_area - kernel function                     
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_set_thread_area                                 

    Note: functon call consists of four instructions
          
          sys_set_thread_area:                              
              mov  eax,243    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
624 sys_set_tid_address - kernel function                     
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_set_tid_address                                 

    Note: functon call consists of four instructions
          
          sys_set_tid_address:                              
              mov  eax,258    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
625 sys_setdomainname - kernel function                       
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setdomainname                                   

    Note: functon call consists of four instructions
          
          sys_setdomainname:                                
              mov  eax,121    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
626 sys_setfsgid - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setfsgid                                        

    Note: functon call consists of four instructions
          
          sys_setfsgid:                                     
              mov  eax,139    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
627 sys_setfsgid32 - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setfsgid32                                      

    Note: functon call consists of four instructions
          
          sys_setfsgid32:                                   
              mov  eax,216    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
628 sys_setfsuid - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setfsuid                                        

    Note: functon call consists of four instructions
          
          sys_setfsuid:                                     
              mov  eax,138    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
629 sys_setfsuid32 - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setfsuid32                                      

    Note: functon call consists of four instructions
          
          sys_setfsuid32:                                   
              mov  eax,215    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
630 sys_setgid - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setgid                                          

    Note: functon call consists of four instructions
          
          sys_setgid:                                       
              mov  eax,46     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
631 sys_setgid32 - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setgid32                                        

    Note: functon call consists of four instructions
          
          sys_setgid32:                                     
              mov  eax,214    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
632 sys_setgroups - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setgroups                                       

    Note: functon call consists of four instructions
          
          sys_setgroups:                                    
              mov  eax,81     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
633 sys_setgroups32 - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setgroups32                                     

    Note: functon call consists of four instructions
          
          sys_setgroups32:                                  
              mov  eax,206    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
634 sys_sethostname - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sethostname                                     

    Note: functon call consists of four instructions
          
          sys_sethostname:                                  
              mov  eax,74     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
635 sys_setitimer - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setitimer                                       

    Note: functon call consists of four instructions
          
          sys_setitimer:                                    
              mov  eax,104    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
636 sys_setpgid - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setpgid                                         

    Note: functon call consists of four instructions
          
          sys_setpgid:                                      
              mov  eax,57     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
637 sys_setpriority - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setpriority                                     

    Note: functon call consists of four instructions
          
          sys_setpriority:                                  
              mov  eax,97     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
638 sys_setregid - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setregid                                        

    Note: functon call consists of four instructions
          
          sys_setregid:                                     
              mov  eax,71     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
639 sys_setregid32 - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setregid32                                      

    Note: functon call consists of four instructions
          
          sys_setregid32:                                   
              mov  eax,204    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
640 sys_setresgid - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setresgid                                       

    Note: functon call consists of four instructions
          
          sys_setresgid:                                    
              mov  eax,170    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
641 sys_setresgid32 - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setresgid32                                     

    Note: functon call consists of four instructions
          
          sys_setresgid32:                                  
              mov  eax,210    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
642 sys_setresuid - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setresuid                                       

    Note: functon call consists of four instructions
          
          sys_setresuid:                                    
              mov  eax,164    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
643 sys_setresuid32 - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setresuid32                                     

    Note: functon call consists of four instructions
          
          sys_setresuid32:                                  
              mov  eax,208    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
644 sys_setreuid - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setreuid                                        

    Note: functon call consists of four instructions
          
          sys_setreuid:                                     
              mov  eax,70     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
645 sys_setreuid32 - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setreuid32                                      

    Note: functon call consists of four instructions
          
          sys_setreuid32:                                   
              mov  eax,203    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
646 sys_setrlimit - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setrlimit                                       

    Note: functon call consists of four instructions
          
          sys_setrlimit:                                    
              mov  eax,75     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
647 sys_setsid - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setsid                                          

    Note: functon call consists of four instructions
          
          sys_setsid:                                       
              mov  eax,66     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
648 sys_settimeofday - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_settimeofday                                    

    Note: functon call consists of four instructions
          
          sys_settimeofday:                                 
              mov  eax,79     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
649 sys_setuid - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setuid                                          

    Note: functon call consists of four instructions
          
          sys_setuid:                                       
              mov  eax,23     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
650 sys_setuid32 - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setuid32                                        

    Note: functon call consists of four instructions
          
          sys_setuid32:                                     
              mov  eax,213    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
651 sys_setxattr - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_setxattr                                        

    Note: functon call consists of four instructions
          
          sys_setxattr:                                     
              mov  eax,226    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
652 sys_sgetmask - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sgetmask                                        

    Note: functon call consists of four instructions
          
          sys_sgetmask:                                     
              mov  eax,68     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
653 sys_sigaction - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sigaction                                       

    Note: functon call consists of four instructions
          
          sys_sigaction:                                    
              mov  eax,67     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
654 sys_sigaltstack - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sigaltstack                                     

    Note: functon call consists of four instructions
          
          sys_sigaltstack:                                  
              mov  eax,186    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
655 sys_signal - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_signal                                          

    Note: functon call consists of four instructions
          
          sys_signal:                                       
              mov  eax,48     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
656 sys_signalfd - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_signalfd                                        

    Note: functon call consists of four instructions
          
          sys_signalfd:                                     
              mov  eax,321    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
657 sys_sigpending - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sigpending                                      

    Note: functon call consists of four instructions
          
          sys_sigpending:                                   
              mov  eax,73     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
658 sys_sigprocmask - kernel function                         
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sigprocmask                                     

    Note: functon call consists of four instructions
          
          sys_sigprocmask:                                  
              mov  eax,126    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
659 sys_sigreturn - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sigreturn                                       

    Note: functon call consists of four instructions
          
          sys_sigreturn:                                    
              mov  eax,119    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
660 sys_sigsuspend - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sigsuspend                                      

    Note: functon call consists of four instructions
          
          sys_sigsuspend:                                   
              mov  eax,72     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
661 sys_socketcall - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_socketcall                                      

    Note: functon call consists of four instructions
          
          sys_socketcall:                                   
              mov  eax,102    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
662 sys_splice - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_splice                                          

    Note: functon call consists of four instructions
          
          sys_splice:                                       
              mov  eax,313    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
663 sys_ssetmask - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ssetmask                                        

    Note: functon call consists of four instructions
          
          sys_ssetmask:                                     
              mov  eax,69     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
664 sys_stat - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_stat                                            

    Note: functon call consists of four instructions
          
          sys_stat:                                         
              mov  eax,106    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
665 sys_stat64 - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_stat64                                          

    Note: functon call consists of four instructions
          
          sys_stat64:                                       
              mov  eax,195    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
666 sys_statfs - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_statfs                                          

    Note: functon call consists of four instructions
          
          sys_statfs:                                       
              mov  eax,99     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
667 sys_statfs64 - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_statfs64                                        

    Note: functon call consists of four instructions
          
          sys_statfs64:                                     
              mov  eax,268    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
668 sys_stime - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_stime                                           

    Note: functon call consists of four instructions
          
          sys_stime:                                        
              mov  eax,25     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
669 sys_stty - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_stty                                            

    Note: functon call consists of four instructions
          
          sys_stty:                                         
              mov  eax,31     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
670 sys_swapoff - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_swapoff                                         

    Note: functon call consists of four instructions
          
          sys_swapoff:                                      
              mov  eax,115    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
671 sys_swapon - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_swapon                                          

    Note: functon call consists of four instructions
          
          sys_swapon:                                       
              mov  eax,87     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
672 sys_symlink - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_symlink                                         

    Note: functon call consists of four instructions
          
          sys_symlink:                                      
              mov  eax,83     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
673 sys_symlinkat - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_symlinkat                                       

    Note: functon call consists of four instructions
          
          sys_symlinkat:                                    
              mov  eax,304    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
674 sys_sync - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sync                                            

    Note: functon call consists of four instructions
          
          sys_sync:                                         
              mov  eax,36     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
675 sys_sync_file_range - kernel function                     
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sync_file_range                                 

    Note: functon call consists of four instructions
          
          sys_sync_file_range:                              
              mov  eax,314    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
676 sys_sysfs - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sysfs                                           

    Note: functon call consists of four instructions
          
          sys_sysfs:                                        
              mov  eax,135    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
677 sys_sysinfo - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_sysinfo                                         

    Note: functon call consists of four instructions
          
          sys_sysinfo:                                      
              mov  eax,116    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
678 sys_syslog - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_syslog                                          

    Note: functon call consists of four instructions
          
          sys_syslog:                                       
              mov  eax,103    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
679 sys_tee - kernel function                                 
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_tee                                             

    Note: functon call consists of four instructions
          
          sys_tee:                                          
              mov  eax,315    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
680 sys_tgkill - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_tgkill                                          

    Note: functon call consists of four instructions
          
          sys_tgkill:                                       
              mov  eax,270    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
681 sys_time - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_time                                            

    Note: functon call consists of four instructions
          
          sys_time:                                         
              mov  eax,13     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
682 sys_timer_create - kernel function                        
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_timer_create                                    

    Note: functon call consists of four instructions
          
          sys_timer_create:                                 
              mov  eax,259    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
683 sys_timerfd - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_timerfd                                         

    Note: functon call consists of four instructions
          
          sys_timerfd:                                      
              mov  eax,322    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
684 sys_times - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_times                                           

    Note: functon call consists of four instructions
          
          sys_times:                                        
              mov  eax,43     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
685 sys_tkill - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_tkill                                           

    Note: functon call consists of four instructions
          
          sys_tkill:                                        
              mov  eax,238    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
686 sys_truncate - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_truncate                                        

    Note: functon call consists of four instructions
          
          sys_truncate:                                     
              mov  eax,92     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
687 sys_truncate64 - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_truncate64                                      

    Note: functon call consists of four instructions
          
          sys_truncate64:                                   
              mov  eax,193    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
688 sys_ugetrlimit - kernel function                          
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ugetrlimit                                      

    Note: functon call consists of four instructions
          
          sys_ugetrlimit:                                   
              mov  eax,191    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
689 sys_ulimit - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ulimit                                          

    Note: functon call consists of four instructions
          
          sys_ulimit:                                       
              mov  eax,58     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
690 sys_umask - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_umask                                           

    Note: functon call consists of four instructions
          
          sys_umask:                                        
              mov  eax,60     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
691 sys_umount - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_umount                                          

    Note: functon call consists of four instructions
          
          sys_umount:                                       
              mov  eax,22     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
692 sys_umount2 - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_umount2                                         

    Note: functon call consists of four instructions
          
          sys_umount2:                                      
              mov  eax,52     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
693 sys_uname - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_uname                                           

    Note: functon call consists of four instructions
          
          sys_uname:                                        
              mov  eax,122    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
694 sys_unlink - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_unlink                                          

    Note: functon call consists of four instructions
          
          sys_unlink:                                       
              mov  eax,10     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
695 sys_unlinkat - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_unlinkat                                        

    Note: functon call consists of four instructions
          
          sys_unlinkat:                                     
              mov  eax,301    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
696 sys_unshare - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_unshare                                         

    Note: functon call consists of four instructions
          
          sys_unshare:                                      
              mov  eax,310    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
697 sys_uselib - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_uselib                                          

    Note: functon call consists of four instructions
          
          sys_uselib:                                       
              mov  eax,86     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
698 sys_ustat - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_ustat                                           

    Note: functon call consists of four instructions
          
          sys_ustat:                                        
              mov  eax,62     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
699 sys_utime - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_utime                                           

    Note: functon call consists of four instructions
          
          sys_utime:                                        
              mov  eax,30     
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
700 sys_utimensat - kernel function                           
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_utimensat                                       

    Note: functon call consists of four instructions
          
          sys_utimensat:                                    
              mov  eax,320    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
701 sys_utimes - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_utimes                                          

    Note: functon call consists of four instructions
          
          sys_utimes:                                       
              mov  eax,271    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
702 sys_vfork - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_vfork                                           

    Note: functon call consists of four instructions
          
          sys_vfork:                                        
              mov  eax,190    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
703 sys_vhangup - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_vhangup                                         

    Note: functon call consists of four instructions
          
          sys_vhangup:                                      
              mov  eax,111    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
704 sys_vm86 - kernel function                                
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_vm86                                            

    Note: functon call consists of four instructions
          
          sys_vm86:                                         
              mov  eax,166    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
705 sys_vm86old - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_vm86old                                         

    Note: functon call consists of four instructions
          
          sys_vm86old:                                      
              mov  eax,113    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
706 sys_vmsplice - kernel function                            
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_vmsplice                                        

    Note: functon call consists of four instructions
          
          sys_vmsplice:                                     
              mov  eax,316    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
707 sys_vserver - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_vserver                                         

    Note: functon call consists of four instructions
          
          sys_vserver:                                      
              mov  eax,273    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
708 sys_wait4 - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_wait4                                           

    Note: functon call consists of four instructions
          
          sys_wait4:                                        
              mov  eax,114    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
709 sys_waitid - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_waitid                                          

    Note: functon call consists of four instructions
          
          sys_waitid:                                       
              mov  eax,284    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
710 sys_waitpid - kernel function                             
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_waitpid                                         

    Note: functon call consists of four instructions
          
          sys_waitpid:                                      
              mov  eax,7      
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
711 sys_write - kernel function                               
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_write                                           

    Note: functon call consists of four instructions
          
          sys_write:                                        
              mov  eax,4      
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
712 sys_writev - kernel function                              
-----------------------------------------------------------------------

    INPUTS 
     see AsmRef function -> sys_writev                                          

    Note: functon call consists of four instructions
          
          sys_writev:                                       
              mov  eax,146    
              int  byte 80h
              or   eax,eax
              ret

-----------------------------------------------------------------------
713 alt_screen - switch to alt terminal screen
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   none
 NOTES
    source file: alt_screen.asm

    This function only works on x-terminal

    processing - exit if already in alt window.  This
                 check uses a global flag (twindow_state)
                 which tracks state of normal/alt windows.
                 twindow_state = 1 if in alt window.
               - call save_norm_cursor
               - switch to alt window
               - restore alt cursor posn  

-----------------------------------------------------------------------
714 get_string - get string in scrolled window line
-----------------------------------------------------------------------
    Read string into buffer using optional window size.
    Unknown keys can be returned to caller for processing
    or ignored by get_string.
 INPUTS
    ebp= pointer to table with following structure:

    struc strdef
    ._data_buffer_ptr    resd 1 ;+0    cleared or preload with text (see note)
    ._buffer_size        resd 1 ;+4    buffer size, > or = window_size
    ._color ptr          resd 1 ;+8    (see file crt_data.asm)
    ._display_row        resb 1 ;+12   ;row (1-x)
    ._display_column     resb 1 ;+13   ;column (1-x)
    ._sflags             resb 1 ;+14   ;see notes
    ._initial_cursor_col resb 1 ;+15   ;must be within data area
    ._window_size        resd 1 ;+16   bytes in window
    endstruc

    note: get_string is always in insert mode and end of string
      has a zero character.  The _sflags byte defines operations
    note: The buffer must have 2 extra bytes at end for overflow.
    
    _sflags = 00000001b = allow 0d/0a in output string.  the ESC
                          character terminates string entry.  Normally
                          string entry is terminated by Enter key.
              00000010b = clear buffer.
              00000100b = disable the Home,End keys
                          if bit 000100000b is set they are
                          returned in global "key_buf" for processing
              00001000b = disable the right,left scroll keys
                          if bit 000100000b is set they are returned
                          in the global "key_buf"  for processing
              00010000b = return unknown or unprocessed keys, to
                          continue entering data, set 10000000b
                          and call get_string again.
              00100000b = use _buffer_size for _window_size and
                          ignore the _window_size field
              01000000b = ignore both the _initial_cursor_col and
                          _window_size fields.  The _window_size will
                          be set to _buffer_size and _initial_cursor_col
                          will be set to end of string
              10000000b = continue, do not initialize any settings


    notes: The Initial cursor column must equal the display column
      or within the range of "display_column" + window_size"
      Thus, if "display_column=5" and "window_size"=2 then
      "initial cursor" can be 5 or 6
      Setting the initial cursor column to zero will put it at
      end of any string found at _data_buffer_ptr
      If window_size extends beyond physical right edge of screen
      it will be truncated.
           
 OUTPUT
    ebp=pointer to input table (unchanged)
    al=0 data in buffer,  <Enter> char in kbuf
         the enter char will always be 0ah if "Enter"
         key was pressed and 1bh if ESC was enabled
         by the allow_0a flag
    al=1 mouse click, buffer may have data
    al=2 unprocessed char in kbuf
    ah=current cursor column
    ecx=string size

 EXAMPLE
    call  mouse_enable	;library call to enable mouse
    mov  ebp,string_block
    and  [ebp+strdef._sflags],byte ~keep_settings
  key_loop:
    call get_string
    and  [ebp+strdef,_sflags],byte keep_settings
    cmp  al,2		;check if ignored key or mouse
    jae  key_loop	;go back and keep reading
    jmp  process_string

    [section .data]
   string_block:
   data_buffer_ptr    dd buf ;+0    cleared or preload with text
   buffer_size        dd 100 ;+4    buffer size
   color_ptr          dd color1 ;+8    (see file crt_data.asm)
   display_row        db   1 ;+12   ;row (1-x)
   display_column     db   1 ;+13   ;column (1-x)
   sflags             db   00000000b  ;+14   ;see notes
   initial_cursor_col db   1 ;+15   ;must be within data area
   window_size        dd  80 ;+16   bytes in window

   color1 dd 30003730h
   buf times buffer_size+2 db 0

 NOTES
   source file: get_string.asm
   see also, get_text

-----------------------------------------------------------------------
715 get_text - get string in scrolled window line
-----------------------------------------------------------------------
    Read string into buffer using optional window size.
    Unknown keys can be returned to caller for processing
    or ignored by get_text.
 INPUTS
    ebp= pointer to table with following structure:

    struc strdef
    ._data_buffer_ptr    resd 1 ;+0    blanked or preload with text
    ._buffer_size        resd 1 ;+4    buffer size, > or = window_size
    ._color ptr          resd 1 ;+8    (see file crt_data.asm)
    ._display_row        resb 1 ;+12   ;row (1-x)
    ._display_column     resb 1 ;+13   ;column (1-x)
    ._initial_cursor_col resb 1 ;+15   ;must be within data area
    ._window_size        resd 1 ;+16   bytes in window
    ._scroll             resd 1 ;+20   window scroll right count
    endstruc

    note: the input block is updated by get_text and must
          be writable.  This allows get_text entry to continue
          from last entry when called over and over.

    note: get_text is always in insert mode.
    
    note: The Initial cursor column must equal the display column
      or within the range of "display_column" + window_size"
      Thus, if "display_column=5" and "window_size"=2 then
      "initial cursor" can be 5 or 6
      If window_size extends beyond physical right edge of screen
      it will be truncated.

    note: the initial buffer is assumed to contain text or
          blanks.  At exit the whole buffer is retruned with
          edits.
           
 OUTPUT
    ebp=pointer to input table (unchanged)
    [kbuf] has key press that caused exit

    note: get_text uses right/left arrow, rubout, del
          home, end, and mouse click within window.  All
          other non-text data will force exit.

 EXAMPLE
    call  mouse_enable	;library call to enable mouse
    mov  ebp,string_block
  key_loop:
    call get_text

    [section .data]
   string_block:
   data_buffer_ptr    dd buf ;+0    cleared or preload with text
   buffer_size        dd 100 ;+4    buffer size
   color_ptr          dd color1 ;+8    (see file crt_data.asm)
   display_row        db   1 ;+12   ;row (1-x)
   display_column     db   1 ;+13   ;column (1-x)
   initial_cursor_col db   1 ;+15   ;must be within data area
   window_size        dd  80 ;+16   bytes in window
   scroll             dd   0 ;+20   no scroll initially

   color1 dd 30003730h
   buf times buffer_size db ' '

 NOTES
   source file: get_text.asm
   see also, get_string

-----------------------------------------------------------------------
716 is_raw_term - check if stdin is in raw mode
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
   edx = pointer to termios structure
   flags set for je=raw  jne=cooked
 NOTES
    source file /crt/is_raw_term.asm
    lib_buf is temp buffer holding termios

-----------------------------------------------------------------------
717 isatty - check if fd is a tty
-----------------------------------------------------------------------
 INPUTS
    ebx = fd to check    
 OUTPUT
  if jns (then) is a tty 
  if js (then) not a tty
 NOTES

-----------------------------------------------------------------------
718 key_flush - remove keys from stdin
-----------------------------------------------------------------------
 INPUTS
    keyboard must be in raw mode
 OUTPUT
    none
 NOTES
   source file: key_flush.asm

-----------------------------------------------------------------------
719 key_mouse1 - flush and read one key string or mouse click
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    kbuf has key sequence ending with zero byte
    if key sequence starts with byte of -1 then
    it is a mouse click and following bytes are:
     button(0-3), column(1-x), row(1-x)
     button = 0=left 1=middle 2=right 3=release
 NOTES
   source file: read_stdin.asm
   The keyboard is flushed before reading key data.
   function crt_open must be called before using!

-----------------------------------------------------------------------
720 key_poll - check if key avail.
-----------------------------------------------------------------------
 INPUTS
    terminal must be in raw mode
 OUTPUT
    zero flag for jz set if no key available
 NOTES
    source file: key_mouse.asm

-----------------------------------------------------------------------
721 key_string1 - get string (preloaded string in buffer)
-----------------------------------------------------------------------
    This function is being replaced, use get_string or
    get_text instead.
 INPUTS
    ebp= pointer to table with following:
      data buffer ptr    +0    (dword) cleared or preload with text
      max string length  +4    (dword) buffer must be 1 byte bigger
      color ptr          +8    (dword) (see file crt_data.asm)
      display row        +12   (db)	;row (1-x)
      display column     +13   (db)  ;column (1-x)
      allow 0d/0a in str +14   (db)	;0=no 1=yes
      initial curosr col +15   (db)  ;must be within data area
    notes: user can signal "done" by typing ESC-key. If allow 0d flag
      is set=0 a string can also be terminated by <Enter> key.
    notes: The Initial cursor column must equal the display column
      or within the range of "display_column" + "max string length"
      Thus, if "display_column=5" and "max string length"=2 then
      "initial cursor" can be 5 or 6
           
 OUTPUT
    al=0 data in buffer, unknown char in kbuf
    al=1 data in buffer. mouse click
    ah=current cursor column
 NOTES
   source file: key_string.asm
   requires calls to env_stack and get_window_size

-----------------------------------------------------------------------
722 key_string2 - get string (no preloaded string displayed)
-----------------------------------------------------------------------
    This function is being replaced, use get_string or
    get_text instead
 INPUTS
    ebp= pointer to table with following:
      data buffer ptr    +0    (dword) cleared or preload with text
      max string length  +4    (dword) buffer must be 1 byte bigger
      color ptr          +8    (dword) (see file crt_data.asm)
      display row        +12   (db)	;row (1-x)
      display column     +13   (db)  ;column (1-x)
      allow 0d/0a in str +14   (db)	;0=no 1=yes
    notes: user can signal "done" by typing ESC-key. If allow 0d flag
      is set=0 a string can also be terminated by <Enter> key.
 OUTPUT
    al=0 data in buffer, unknown char in kbuf
    al=1 data in buffer. mouse click
 NOTES
   source file: key_string.asm
   requires calls to env_stack and get_window_size

-----------------------------------------------------------------------
723 mouse_check - reformat keyboard data if mouse click info
-----------------------------------------------------------------------
 INPUTS
   [kbuf]  has mouse escape sequenes
          1b,5b,4d,xx,yy,zz
            xx - 20=left but  21=middle 22=right 23=release
            yy - column+20h
            zz - row + 20h
 OUTPUT
   [kbuf]  = ff,button,column,row
             where: ff = db -1
                    button = 0=left but  1=middle 2=right 3=release
                    column = binary column (byte)
                    row = binary row (byte)  
 NOTES
    source file: mouse_check.asm

    mouse_check assumes the keyboard is in raw mode.  It is
    called from the keyboard handlers and probably isn't of
    interest for other applications.

-----------------------------------------------------------------------
724 mouse_enable - enable mouse on x terminals
-----------------------------------------------------------------------
 INPUTS
     none
 OUTPUT
     none
 NOTES
   source file: mouse_enable.asm
   function crt_open also needed to use mouse

-----------------------------------------------------------------------
725 normal_screen - switch to normal terminal screen
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   none
 NOTES
    source file: alt_screen.asm

    this function works in x-terminal

    processing - exit if already in normal window.  This
                 check uses a global flag (twindow_state)
                 which tracks state of normal/alt windows.
                 twindow_state = 0 if in normal window.
               - call save_alt_cursor.
               - switch to normal window
               - restore normal window cursor position

-----------------------------------------------------------------------
726 output_term_info_0 - output stdin window size and settings
-----------------------------------------------------------------------
 INPUTS
    edx = ptr to info struc, size = 44 bytes
    struc term_info_struc
    .ws_row:resw 1		;winsize struc
    .ws_col:resw 1
    .ws_xpixel:resw 1
    .ws_ypixel:resw 1
    .c_iflag: resd 1		;termios struc
    .c_oflag: resd 1
    .c_cflag: resd 1
    .c_lflag: resd 1
    .c_line: resb 1
    .c_cc: resb 19
 OUTPUT
    structure at edx filled int
 NOTES
    source file: output_term_info.asm

-----------------------------------------------------------------------
727 output_term_info_x - output terminal structure "termios"
-----------------------------------------------------------------------
 INPUTS
    ebx = fd (file descriptor) of terminal
    edx = ptr to winsize struc, size = 44 bytes
    struc term_info_struc

    .ws_row:resw 1		;winsize struc
    .ws_col:resw 1
    .ws_xpixel:resw 1
    .ws_ypixel:resw 1
    .c_iflag: resd 1		;termios struc
    .c_oflag: resd 1
    .c_cflag: resd 1
    .c_lflag: resd 1
    .c_line: resb 1
    .c_cc: resb 19
 OUTPUT
   structure at edx filled in 
 NOTES
    source file: output_term_info.asm

-----------------------------------------------------------------------
728 output_termios_0 - output stdin terminal structure "termios"
-----------------------------------------------------------------------
 INPUTS
    edx = ptr to saved termios buffer, size = 36 bytes

    struc termio_struc
    .c_iflag: resd 1
    .c_oflag: resd 1
    .c_cflag: resd 1
    .c_lflag: resd 1
    .c_line: resb 1
    .c_cc: resb 19
    endstruc
 OUTPUT
   none
 NOTES
    source file output_termios.asm

-----------------------------------------------------------------------
729 output_termios_x - output terminal structure "termios"
-----------------------------------------------------------------------
 INPUTS
    ebx = fd (file descriptor) of terminal
    edx = ptr to termios output buffer, size = 36 bytes
    struc termio_struc
    .c_iflag: resd 1
    .c_oflag: resd 1
    .c_cflag: resd 1
    .c_lflag: resd 1
    .c_line: resb 1
    .c_cc: resb 19
  * endstruc
 OUTPUT
   none
 NOTES
    source file output_termios.asm

-----------------------------------------------------------------------
730 output_winsize_0 - output stdin window size
-----------------------------------------------------------------------
 INPUTS
    edx = ptr to winsize struc, size = 8 bytes
   
    struc wnsize_struc
    .ws_row:resw 1
    .ws_col:resw 1
    .ws_xpixel:resw 1
    .ws_ypixel:resw 1
    endstruc
    wnsize_struc_size
 OUTPUT
    none
 NOTES
    source file terminal.asm

-----------------------------------------------------------------------
731 output_winsize_x - output terminal structure "termios"
-----------------------------------------------------------------------
 INPUTS
    ebx = fd (file descriptor) of terminal
    edx = ptr to winsize struc, size = 8 bytes
   
    struc wnsize_struc
    .ws_row:resw 1
    .ws_col:resw 1
    .ws_xpixel:resw 1
    .ws_ypixel:resw 1
    endstruc
    wnsize_struc_size
 OUTPUT
   none
 NOTES
    source file terminal.asm

-----------------------------------------------------------------------
732 raw_set1 - switch stdin to raw mode
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   [termios1] is a global library structure which
              is set to previous state of termios.
   lib_buf contains modified termios that was output
 NOTES
    source file: raw_set.asm

    The current termios state is saved at global
    variable "termios1" as follows:
      c_iflag: resd 1
      c_oflag: resd 1
      c_cflag: resd 1
      c_lflag: resd 1
      c_line:  resb 1
      c_cc:    resb 19 ; total size is 36 bytes
    The new termios is created with the following bits
      c_iflag bit ICRNL (0100) map input CR to NL set
      c_lflag bits ICANON (0002) and ECHO (0008) cleared,
                   this sets us in raw mode witout echo 

    The buffer "lib_buf" is used as temp work buffer
    Use function raw_unset1 to restore termios1

-----------------------------------------------------------------------
733 raw_set2 - switch stdin to raw mode
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   [termios2] is set to current termios state then
   copied to lib_buf and modified to set raw mode.
 NOTES
    source file: raw_set.asm

    This function is called by "read_stdin" and should not
    be called by code that also calls "read_stdin"  while
    termios data is saved in "termios2"

    The current termios state is saved at global
    variable "termios2" as follows:
      c_iflag: resd 1
      c_oflag: resd 1
      c_cflag: resd 1
      c_lflag: resd 1
      c_line:  resb 1
      c_cc:    resb 19 ; total size is 36 bytes
    The new termios is created with the following bits
      c_iflag bit ICRNL (0100) map input CR to NL set
      c_lflag bits ICANON (0002) and ECHO (0008) cleared,
                   this sets us in raw mode witout echo 

    The buffer "lib_buf" is used as temp work buffer
    Use function raw_unset1 to restore termios2

-----------------------------------------------------------------------
734 raw_unset1 - restore termios saved with raw_set1
-----------------------------------------------------------------------
 INPUTS
   [termios1] is global library structure with new
              termios data
 OUTPUT
   none
 NOTES
    source file: raw_set.asm

-----------------------------------------------------------------------
735 raw_unset2 - restore termios saved with raw_set2
-----------------------------------------------------------------------
 INPUTS
   [termios2] - global library structure with termios
                to restore      
 OUTPUT
   none
 NOTES
    source file: raw_set.asm

-----------------------------------------------------------------------
736 read_one_byte - read one byte from stdin
-----------------------------------------------------------------------
 INPUTS
    ecx = storage ptr
 OUTPUT
    [ecx] = ptr beyond key stored
 NOTES
    source file: read_one_byte.asm
    The terminal is assumed to be in raw mode.
    Normally this program is only called from
    key_mouse or other keyboard handlers.

-----------------------------------------------------------------------
737 read_stdin - read one key string or mouse click
-----------------------------------------------------------------------
 INPUTS
    none
 OUTPUT
    kbuf has key sequence ending with zero byte
    if key sequence starts with byte of -1 then
    it is a mouse click and following bytes are:
     button(0-3), column(1-x), row(1-x)
     button = 0=left 1=middle 2=right 3=release
 NOTES
   file: read_stdin.asm
   The keyboard is not flushed before reading key data.

-----------------------------------------------------------------------
738 read_term_info_0 - save stdin window size and settings
-----------------------------------------------------------------------
 INPUTS
    edx = ptr to info struc, size = 44 bytes
    struc term_info_struc
    .ws_row:resw 1		;winsize struc
    .ws_col:resw 1
    .ws_xpixel:resw 1
    .ws_ypixel:resw 1
    .c_iflag: resd 1		;termios struc
    .c_oflag: resd 1
    .c_cflag: resd 1
    .c_lflag: resd 1
    .c_line: resb 1
    .c_cc: resb 19
 OUTPUT
    structure at edx filled in
 NOTES
    source file read_term_info.asm

    see also: crt_type - returns $TERM usually as "linux" or "xterm"
              terminal_type - returns code for console,xterm,clone
              read_winsize_x - returns winsize struc
              read_term_info_x - returns termios and winsize struc
              read_window_size - returns text size for console,xterm,clone
              get_screen_size - returns pixels for xterm or framebuffer
              win_size - returns xterm pixels or zero if not xterm
              win_txt_size - returns text size for xterm or zero if other term

-----------------------------------------------------------------------
739 read_term_info__x - save terminal structure "termios"
-----------------------------------------------------------------------
 INPUTS
    ebx = fd (file descriptor) of terminal
    edx = ptr to winsize struc, size = 44 bytes
    struc term_info_struc
    .ws_row:resw 1		;winsize struc
    .ws_col:resw 1
    .ws_xpixel:resw 1
    .ws_ypixel:resw 1
    .c_iflag: resd 1		;termios struc
    .c_oflag: resd 1
    .c_cflag: resd 1
    .c_lflag: resd 1
    .c_line: resb 1
    .c_cc: resb 19
 OUTPUT
   structure at edx filled in
 NOTES
    source file: read_term_info.asm

    see also: crt_type - returns $TERM usually as "linux" or "xterm"
              terminal_type - returns code for console,xterm,clone
              read_winsize_x - returns winsize struc
              read_term_info_x - returns termios and winsize struc
              read_window_size - returns text size for console,xterm,clone
              get_screen_size - returns pixels for xterm or framebuffer
              win_size - returns xterm pixels or zero if not xterm
              win_txt_size - returns text size for xterm or zero if other term

-----------------------------------------------------------------------
740 read_termios_0 - save stdin terminal structure "termios"
-----------------------------------------------------------------------
 INPUTS
    edx = ptr to termios save buffer, size = 36 bytes
    struc termio_struc
    .c_iflag: resd 1
    .c_oflag: resd 1
    .c_cflag: resd 1
    .c_lflag: resd 1
    .c_line: resb 1
    .c_cc: resb 19
    endstruc
 OUTPUT
   structure at edx filled in
 NOTES
    source file: read_termios.asm

-----------------------------------------------------------------------
741 read_termios_x - save terminal structure "termios"
-----------------------------------------------------------------------
 INPUTS
    ebx = fd (file descriptor) of terminal
    edx = ptr to termios save buffer, size = 36 bytes
    struc termio_struc
    .c_iflag: resd 1
    .c_oflag: resd 1
    .c_cflag: resd 1
    .c_lflag: resd 1
    .c_line: resb 1
    .c_cc: resb 19
    endstruc
 OUTPUT
   structure at edx filled int
 NOTES
    source file read_termios.asm

-----------------------------------------------------------------------
742 read_window_size - set global window size info
-----------------------------------------------------------------------
 INPUTS
    none                 
 OUTPUT
  if jns (then)
  edx = pointer to structure as follows:
    [crt_rows]      dword       number of rows on terminal
    [crt_columns]   dword       number of columns on terminal
    [root_pix_rows] dword       height in pixels, x root window
    [root_pix_cols] dword       width  in pixels, x root window
  if js (then) error, edx points to empty struc
 NOTES

-----------------------------------------------------------------------
743 read_winsize_0 - save stdin window size
-----------------------------------------------------------------------
 INPUTS
    edx = ptr to winsize struc, size = 8 bytes
   
    struc wnsize_struc
    .ws_row:resw 1
    .ws_col:resw 1
    .ws_xpixel:resw 1
    .ws_ypixel:resw 1
    endstruc
    wnsize_struc_size
 OUTPUT
    structure at edx filled in
 NOTES
    source file /xterm/read_winsize.asm


-----------------------------------------------------------------------
744 read_winsize_x - read (fd) window size
-----------------------------------------------------------------------
 INPUTS
    ebx = fd (file descriptor) of terminal
    edx = ptr to winsize struc, size = 8 bytes
   
    struc wnsize_struc
    .ws_row:resw 1
    .ws_col:resw 1
    .ws_xpixel:resw 1
    .ws_ypixel:resw 1
    endstruc
    wnsize_struc_size
 OUTPUT
   structure at edx filled in
 NOTES
    source file /xterm/read_winsize.asm


-----------------------------------------------------------------------
745 restore_alt_cursor - restore cursor for alt window
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   none
 NOTES
    source file: restore_alt_cursor.asm

    This function assumes we have switched to alt-window
    and restores the saved alt window cursor, if no previous
    cursor has been saved, it puts cursor at location 1,1

-----------------------------------------------------------------------
746 restore_cursor_from - restore cursor position
-----------------------------------------------------------------------
 INPUTS
    [esi] - global string with cursor info
      format is: db 1bh ;escape char
                 db '['
                 db '1' ;ascii row, 1 or 2 digits
                 db ';' ;separator
                 db '1' ;ascii column, 1 or 2 digits
                 db 'H' ;end code (set by restore_cursor)
                 db  0  ;string end
 OUTPUT
    none
 NOTES
    source file save_restore_cursor.asm

-----------------------------------------------------------------------
747 restore_norm_cursor - restore cursor for normal window
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   none
 NOTES
    source file: restore_norm_cursor.asm

    This function assumes we are on a x-terminal and restores
    the normal window cursor.  If no cursor has been saved
    previously, it sets the cursor to 1,1

-----------------------------------------------------------------------
748 save_alt_cursor - save cursor and assume alt window active
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   none
 NOTES
    source file: save_alt_cursor

    This function only works on x-terminal

    The current window cursor is saved at global
    location "alt_cursor"
      format is: db 1bh ;escape char
                 db '['
                 db '1' ;ascii row, 1 or 2 digits
                 db ';' ;separator
                 db '1' ;ascii column, 1 or 2 digits
                 db 'H' ;end code (set by restore_cursor)
                 db  0  ;string end

-----------------------------------------------------------------------
749 save_cursor_at - save cursor position
-----------------------------------------------------------------------
 INPUTS
   edi = location to save cursor (10 bytes)
 OUTPUT
   edi = ptr to end of saved cursor
      format is: db 1bh ;escape char
                 db '['
                 db '1' ;ascii row, 1 or 2 digits
                 db ';' ;separator
                 db '1' ;ascii column, 1 or 2 digits
                 db 'H' ;end code (set by restore_cursor_from)
                 db  0  ;string end

 NOTES
    source file: save_cursor_at.asm

    processing: - send escape sequences to terminal
                - read return info. from stdin using read_stdin
                - save returned data at [edi]


-----------------------------------------------------------------------
750 save_norm_cursor - save cursor and assume normal window active
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   none
 NOTES
    source file: save_norm_cursor

    save_norm_cursor assumes we are in normal terminal window
    and saves cursor position in global "norm_cursor".

-----------------------------------------------------------------------
751 scroll_region - set scroll limits for terminal
-----------------------------------------------------------------------
 INPUTS
    al = starting row 1+
    ah = ending row (max 255)
    ebx = fd for tty
 OUTPUT
   none
 NOTES
    source file scroll_region.asm

-----------------------------------------------------------------------
752 set_screen_size - set scroll limits for terminal
-----------------------------------------------------------------------
 INPUTS
    al = ending row (max 255)
    ah = ending column (max 255)
    ebx = display  fd (usually 1)
 OUTPUT
   none
 NOTES
    source file set_screen_size.asm

-----------------------------------------------------------------------
753 stdout_str - display asciiz string at cursor position
-----------------------------------------------------------------------
 INPUTS
    ecx = ptr to string
 OUTPUT
   uses current color, see stdout_set_color, stdout_clear
 NOTES
   source file:  stdout_str.asm
   
   stdout_str first sets up terminal (termios) and then
   outputs data.  See crt_str for faster routine that
   does not set up terminal first.

-----------------------------------------------------------------------
754 terminal_report - get report using screen codes
-----------------------------------------------------------------------
 INPUTS
    ecx = request string
 OUTPUT
    [kbuf] has result string if eax=positive
 NOTES
    source file:  terminal_report.asm

-----------------------------------------------------------------------
755 terminal_type - check if console or xterm
-----------------------------------------------------------------------
 INPUTS
   Function env_stack must be called at start of
   application to setup [enviro_ptrs]
 OUTPUT
    al = 0 - unknown terminal
         1 - x window, no terminal
           [socket_fd] global set to socket fd (dword)
           [root_win_pix_width] set (dword)
           [root_win_pix_height] set (dword)
         2 - console
         3 - xterm clone
          [socket_fd] global set to socket fd (dword)
          [root_win_pix_width] set (dword)
          [root_win_pix_height] set (dword)
    [term_type] - global byte variable set using "al"
         initially term_type is set -1, once terminal_type
         has set term_type, the set value is returned and
         no terminal interrogtion occurs.
 NOTES
    source file:  terminal_type.asm


-----------------------------------------------------------------------
756 terminfo_decode_setup - setup to decode keyboard keys
-----------------------------------------------------------------------
 INPUTS
     the routines env_stack and terminfo_read must be
       called before using this function. Also the
       buffer filled by terminfo_read must be unmodified.
     eax = ptr to key decode table with following format:
          
           times 3*entries db 0  ;padding for expansion
           db x    ;format flag 1=terminfo_key_decode1 format
                                2=terminfo_key_decode2 format
           (insert key definitions here, see decode routines for
            format)
           db 0    ;end of table
 OUTPUT
     the table input with [eax] is rewritten and all padding
     flags removed.  It is now ready for terminfo_key_decode
     routines.

 NOTES
   Source file: terminfo_decode_setup.asm
   See asmref terminfo entry for more information
   Use this function with terminfo_key_decode1, and
   terminfo_key_decode2

-----------------------------------------------------------------------
757 terminfo_extract_flag - get boolean from terminfo
-----------------------------------------------------------------------
 INPUTS
     the routines env_stack and terminfo_read must be
       called before using this function. Also the
       buffer filled by terminfo_read must be unmodified.
     eax = flag number as follows:
        auto_left_margin               [0]
        auto_right_margin              [1]
        no_esc_ctlc                    [2]
        ceol_standout_glitch           [3]
        eat_newline_glitch             [4]
        erase_overstrike               [5]
        generic_type                   [6]
        hard_copy                      [7]
        has_meta_key                   [8]
        has_status_line                [9]
        insert_null_glitch             [10]
        memory_above                   [11]
        memory_below                   [12]
        move_insert_mode               [13]
        move_standout_mode             [14]
        over_strike                    [15]
        status_line_esc_ok             [16]
        dest_tabs_magic_smso           [17]
        tilde_glitch                   [18]
        transparent_underline          [19]
        xon_xoff                       [20]
        needs_xon_xoff                 [21]
        prtr_silent                    [22]
        hard_cursor                    [23]
        non_rev_rmcup                  [24]
        no_pad_char                    [25]
        non_dest_scroll_region         [26]
        can_change                     [27]
        back_color_erase               [28]
        hue_lightness_saturation       [29]
        col_addr_glitch                [30]
        cr_cancels_micro_mode          [31]
        has_print_wheel                [32]
        row_addr_glitch                [33]
        semi_auto_right_margin         [34]
        cpi_changes_res                [35]
        lpi_changes_res                [36]
 OUTPUT
     al = boolean
 NOTES
   Source file: terminfo_extract_flag.asm
   See asmref terminfo entry for more information

-----------------------------------------------------------------------
758 terminfo_extract_key - get value from terminfo
-----------------------------------------------------------------------
 INPUTS
     the routines env_stack and terminfo_read must be
       called before using this function. Also the
       buffer filled by terminfo_read must be unmodified.
     eax = key index as follows:
       back_tab                       [0]
       bell                           [1]
       carriage_return                [2]
       change_scroll_region           [3]
       clear_all_tabs                 [4]
       clear_screen                   [5]
       clr_eol                        [6]
       clr_eos                        [7]
       column_address                 [8]
       command_character              [9]
       cursor_address                 [10]
       cursor_down                    [11]
       cursor_home                    [12]
       cursor_invisible               [13]
       cursor_left                    [14]
       cursor_mem_address             [15]
       cursor_normal                  [16]
       cursor_right                   [17]
       cursor_to_ll                   [18]
       cursor_up                      [19]
       cursor_visible                 [20]
       delete_character               [21]
       delete_line                    [22]
       dis_status_line                [23]
       down_half_line                 [24]
       enter_alt_charset_mode         [25]
       enter_blink_mode               [26]
       enter_bold_mode                [27]
       enter_ca_mode                  [28]
       enter_delete_mode              [29]
       enter_dim_mode                 [30]
       enter_insert_mode              [31]
       enter_secure_mode              [32]
       enter_protected_mode           [33]
       enter_reverse_mode             [34]
       enter_standout_mode            [35]
       enter_underline_mode           [36]
       erase_chars                    [37]
       exit_alt_charset_mode          [38]
       exit_attribute_mode            [39]
       exit_ca_mode                   [40]
       exit_delete_mode               [41]
       exit_insert_mode               [42]
       exit_standout_mode             [43]
       exit_underline_mode            [44]
       flash_screen                   [45]
       form_feed                      [46]
       from_status_line               [47]
       init_1string                   [48]
       init_2string                   [49]
       init_3string                   [50]
       init_file                      [51]
       insert_character               [52]
       insert_line                    [53]
       insert_padding                 [54]
       key_backspace                  [55]
       key_catab                      [56]
       key_clear                      [57]
       key_ctab                       [58]
       key_dc                         [59]
       key_dl                         [60]
       key_down                       [61]
       key_eic                        [62]
       key_eol                        [63]
       key_eos                        [64]
       key_f0                         [65]
       key_f1                         [66]
       key_f10                        [67]
       key_f2                         [68]
       key_f3                         [69]
       key_f4                         [70]
       key_f5                         [71]
       key_f6                         [72]
       key_f7                         [73]
       key_f8                         [74]
       key_f9                         [75]
       key_home                       [76]
       key_ic                         [77]
       key_il                         [78]
       key_left                       [79]
       key_ll                         [80]
       key_npage                      [81]
       key_ppage                      [82]
       key_right                      [83]
       key_sf                         [84]
       key_sr                         [85]
       key_stab                       [86]
       key_up                         [87]
       keypad_local                   [88]
       keypad_xmit                    [89]
       lab_f0                         [90]
       lab_f1                         [91]
       lab_f10                        [92]
       lab_f2                         [93]
       lab_f3                         [94]
       lab_f4                         [95]
       lab_f5                         [96]
       lab_f6                         [97]
       lab_f7                         [98]
       lab_f8                         [99]
       lab_f9                         [100]
       meta_off                       [101]
       meta_on                        [102]
       newline                        [103]
       pad_char                       [104]
       parm_dch                       [105]
       parm_delete_line               [106]
       parm_down_cursor               [107]
       parm_ich                       [108]
       parm_index                     [109]
       parm_insert_line               [110]
       parm_left_cursor               [111]
       parm_right_cursor              [112]
       parm_rindex                    [113]
       parm_up_cursor                 [114]
       pkey_key                       [115]
       pkey_local                     [116]
       pkey_xmit                      [117]
       print_screen                   [118]
       prtr_off                       [119]
       prtr_on                        [120]
       repeat_char                    [121]
       reset_1string                  [122]
       reset_2string                  [123]
       reset_3string                  [124]
       reset_file                     [125]
       restore_cursor                 [126]
       row_address                    [127]
       save_cursor                    [128]
       scroll_forward                 [129]
       scroll_reverse                 [130]
       set_attributes                 [131]
       set_tab                        [132]
       set_window                     [133]
       tab                            [134]
       to_status_line                 [135]
       underline_char                 [136]
       up_half_line                   [137]
       init_prog                      [138]
       key_a1                         [139]
       key_a3                         [140]
       key_b2                         [141]
       key_c1                         [142]
       key_c3                         [143]
       prtr_non                       [144]
       char_padding                   [145]
       acs_chars                      [146]
       plab_norm                      [147]
       key_btab                       [148]
       enter_xon_mode                 [149]
       exit_xon_mode                  [150]
       enter_am_mode                  [151]
       exit_am_mode                   [152]
       xon_character                  [153]
       xoff_character                 [154]
       ena_acs                        [155]
       label_on                       [156]
       label_off                      [157]
       key_beg                        [158]
       key_cancel                     [159]
       key_close                      [160]
       key_command                    [161]
       key_copy                       [162]
       key_create                     [163]
       key_end                        [164]
       key_enter                      [165]
       key_exit                       [166]
       key_find                       [167]
       key_help                       [168]
       key_mark                       [169]
       key_message                    [170]
       key_move                       [171]
       key_next                       [172]
       key_open                       [173]
       key_options                    [174]
       key_previous                   [175]
       key_print                      [176]
       key_redo                       [177]
       key_reference                  [178]
       key_refresh                    [179]
       key_replace                    [180]
       key_restart                    [181]
       key_resume                     [182]
       key_save                       [183]
       key_suspend                    [184]
       key_undo                       [185]
       key_sbeg                       [186]
       key_scancel                    [187]
       key_scommand                   [188]
       key_scopy                      [189]
       key_screate                    [190]
       key_sdc                        [191]
       key_sdl                        [192]
       key_select                     [193]
       key_send                       [194]
       key_seol                       [195]
       key_sexit                      [196]
       key_sfind                      [197]
       key_shelp                      [198]
       key_shome                      [199]
       key_sic                        [200]
       key_sleft                      [201]
       key_smessage                   [202]
       key_smove                      [203]
       key_snext                      [204]
       key_soptions                   [205]
       key_sprevious                  [206]
       key_sprint                     [207]
       key_sredo                      [208]
       key_sreplace                   [209]
       key_sright                     [210]
       key_srsume                     [211]
       key_ssave                      [212]
       key_ssuspend                   [213]
       key_sundo                      [214]
       req_for_input                  [215]
       key_f11                        [216]
       key_f12                        [217]
       key_f13                        [218]
       key_f14                        [219]
       key_f15                        [220]
       key_f16                        [221]
       key_f17                        [222]
       key_f18                        [223]
       key_f19                        [224]
       key_f20                        [225]
       key_f21                        [226]
       key_f22                        [227]
       key_f23                        [228]
       key_f24                        [229]
       key_f25                        [230]
       key_f26                        [231]
       key_f27                        [232]
       key_f28                        [233]
       key_f29                        [234]
       key_f30                        [235]
       key_f31                        [236]
       key_f32                        [237]
       key_f33                        [238]
       key_f34                        [239]
       key_f35                        [240]
       key_f36                        [241]
       key_f37                        [242]
       key_f38                        [243]
       key_f39                        [244]
       key_f40                        [245]
       key_f41                        [246]
       key_f42                        [247]
       key_f43                        [248]
       key_f44                        [249]
       key_f45                        [250]
       key_f46                        [251]
       key_f47                        [252]
       key_f48                        [253]
       key_f49                        [254]
       key_f50                        [255]
       key_f51                        [256]
       key_f52                        [257]
       key_f53                        [258]
       key_f54                        [259]
       key_f55                        [260]
       key_f56                        [261]
       key_f57                        [262]
       key_f58                        [263]
       key_f59                        [264]
       key_f60                        [265]
       key_f61                        [266]
       key_f62                        [267]
       key_f63                        [268]
       clr_bol                        [269]
       clear_margins                  [270]
       set_left_margin                [271]
       set_right_margin               [272]
       label_format                   [273]
       set_clock                      [274]
       display_clock                  [275]
       remove_clock                   [276]
       create_window                  [277]
       goto_window                    [278]
       hangup                         [279]
       dial_phone                     [280]
       quick_dial                     [281]
       tone                           [282]
       pulse                          [283]
       flash_hook                     [284]
       fixed_pause                    [285]
       wait_tone                      [286]
       user0                          [287]
       user1                          [288]
       user2                          [289]
       user3                          [290]
       user4                          [291]
       user5                          [292]
       user6                          [293]
       user7                          [294]
       user8                          [295]
       user9                          [296]
       orig_pair                      [297]
       orig_colors                    [298]
       initialize_color               [299]
       initialize_pair                [300]
       set_color_pair                 [301]
       set_foreground                 [302]
       set_background                 [303]
       change_char_pitch              [304]
       change_line_pitch              [305]
       change_res_horz                [306]
       change_res_vert                [307]
       define_char                    [308]
       enter_doublewide_mode          [309]
       enter_draft_quality            [310]
       enter_italics_mode             [311]
       enter_leftward_mode            [312]
       enter_micro_mode               [313]
       enter_near_letter_quality      [314]
       enter_normal_quality           [315]
       enter_shadow_mode              [316]
       enter_subscript_mode           [317]
       enter_superscript_mode         [318]
       enter_upward_mode              [319]
       exit_doublewide_mode           [320]
       exit_italics_mode              [321]
       exit_leftward_mode             [322]
       exit_micro_mode                [323]
       exit_shadow_mode               [324]
       exit_subscript_mode            [325]
       exit_superscript_mode          [326]
       exit_upward_mode               [327]
       micro_column_address           [328]
       micro_down                     [329]
       micro_left                     [330]
       micro_right                    [331]
       micro_row_address              [332]
       micro_up                       [333]
       order_of_pins                  [334]
       parm_down_micro                [335]
       parm_left_micro                [336]
       parm_right_micro               [337]
       parm_up_micro                  [338]
       select_char_set                [339]
       set_bottom_margin              [340]
       set_bottom_margin_parm         [341]
       set_left_margin_parm           [342]
       set_right_margin_parm          [343]
       set_top_margin                 [344]
       set_top_margin_parm            [345]
       start_bit_image                [346]
       start_char_set_def             [347]
       stop_bit_image                 [348]
       stop_char_set_def              [349]
       subscript_characters           [350]
       superscript_characters         [351]
       these_cause_cr                 [352]
       zero_motion                    [353]
       char_set_names                 [354]
       key_mouse                      [355]
       mouse_info                     [356]
       req_mouse_pos                  [357]
       get_mouse                      [358]
       set_a_foreground               [359]
       set_a_background               [360]
       pkey_plab                      [361]
       device_type                    [362]
       code_set_init                  [363]
       set0_des_seq                   [364]
       set1_des_seq                   [365]
       set2_des_seq                   [366]
       set3_des_seq                   [367]
       set_lr_margin                  [368]
       set_tb_margin                  [369]
       bit_image_repeat               [370]
       bit_image_newline              [371]
       bit_image_carriage_return      [372]
       color_names                    [373]
       define_bit_image_region        [374]
       end_bit_image_region           [375]
       set_color_band                 [376]
       set_page_length                [377]
       display_pc_char                [378]
       enter_pc_charset_mode          [379]
       exit_pc_charset_mode           [380]
       enter_scancode_mode            [381]
       exit_scancode_mode             [382]
       pc_term_options                [383]
       scancode_escape                [384]
       alt_scancode_esc               [385]
       enter_horizontal_hl_mode       [386]
       enter_left_hl_mode             [387]
       enter_low_hl_mode              [388]
       enter_right_hl_mode            [389]
       enter_top_hl_mode              [390]
       enter_vertical_hl_mode         [391]
       set_a_attributes               [392]
       set_pglen_inch                 [393]
       termcap_init2                  [394]
       termcap_reset                  [395]
       linefeed_if_not_lf             [396]
       backspace_if_not_bs            [397]
       other_non_function_keys        [398]
       arrow_key_map                  [399]
       acs_ulcorner                   [400]
       acs_llcorner                   [401]
       acs_urcorner                   [402]
       acs_lrcorner                   [403]
       acs_ltee                       [404]
       acs_rtee                       [405]
       acs_btee                       [406]
       acs_ttee                       [407]
       acs_hline                      [408]
       acs_vline                      [409]
       acs_plus                       [410]
       memory_lock                    [411]
       memory_unlock                  [412]
       box_chars_1                    [413]
 OUTPUT
     ebx = pointer to string for key if bx not = -1
 NOTES
   Source file: terminfo_extract_key.asm
   See asmref terminfo entry for more information

-----------------------------------------------------------------------
759 terminfo_extract_number - get value from terminfo
-----------------------------------------------------------------------
 INPUTS
     the routines env_stack and terminfo_read must be
       called before using this function. Also the
       buffer filled by terminfo_read must be unmodified.
     eax = number index as follows:
       columns                        [0]
       init_tabs                      [1]
       lines                          [2]
       lines_of_memory                [3]
       magic_cookie_glitch            [4]
       padding_baud_rate              [5]
       virtual_terminal               [6]
       width_status_line              [7]
       num_labels                     [8]
       label_height                   [9]
       label_width                    [10]
       max_attributes                 [11]
       maximum_windows                [12]
       max_colors                     [13]
       max_pairs                      [14]
       no_color_video                 [15]
       buffer_capacity                [16]
       dot_vert_spacing               [17]
       dot_horz_spacing               [18]
       max_micro_address              [19]
       max_micro_jump                 [20]
       micro_col_size                 [21]
       micro_line_size                [22]
       number_of_pins                 [23]
       output_res_char                [24]
       output_res_line                [25]
       output_res_horz_inch           [26]
       output_res_vert_inch           [27]
       print_rate                     [28]
       wide_char_size                 [29]
       buttons                        [30]
       bit_image_entwining            [31]
       bit_image_type                 [32]
 OUTPUT
     ax = value
 NOTES
   Source file: terminfo_extract_number.asm
   See asmref terminfo entry for more information

-----------------------------------------------------------------------
760 terminfo_key_decode1 - decode non-aplha key strings and get process
-----------------------------------------------------------------------
 INPUTS
    edx = ptr to input buffer with key strings (zero terminated)
    esi = decode table with key# and processes,

          The decode table must be preprocessed with
          terminfo_decode_setup  before it is used.

          First, the table can have padding to allow
          for expansion of strings from terminfo.

          Next, one byte is flag telling
          terminfo_decode_setup that this table is
          in decode1  format.  It must equal 1

          The first and last key definitions are
          dword process address. When a alpha key
          key is found, the top process is returned.
          If no alpha or match of key then the
          dword at end is returned.  The middle entries
          are non alpha keys defned as follows:

          The body can have normal key definitons
          consisting of a key string, followed by
          a dword process address. If the key
          possibly appears in a terminfo file it
          can have a alternate format as follows:


            db -1        ;start of terminfo format
            dw x         ;terminfo index
            dd process   ;address of key handler
            db operator  ;-2=or -3=and following
            db (key string)
            dd process
                .
                .
            db -4        ;end of this terminfo format

     The decode table must be preprocessed with:
     terminfo_decode_setup.

   unprocessed decode table example
    times 3*4 db 0    ;padding for expansion of table
    db 1              ;flag for decode1 formatted table
    dd	gs_normal_char ;alpha key process

    db -1             ;start terminfo definition
    dw 12             ;home key value for terminfo
    dd gs_home        ; home process
    db -2             ;(or) the following
    db 1bh,'[3',0     ;key string
    dd gs_home        ;process
    db -4             ;end of this terminfo def
 
    db -1             ;lookup this key in terminfo
    dw 14             ;left arrow key code
    dd gs_left        ; left arrow process
    db -4             ;no and/or defs

    db 7fh,0          ; backspace
    dd gs_backspace   ; backspace process
    db 0              ;end of table
    dd no_match       ;no-match process

     After processing by terminfo_decode_setup, the table
     will appear as follows:

    dd	gs_normal_char ;alpha key process
    db 1bh,5bh,48h,0  ; pad_home
    dd gs_home        ; home process 
    db 1bh,5bh,44h,0  ; pad_left
    dd gs_left        ; left arrow process
    db 7fh,0          ; backspace
    dd gs_backspace   ; backspace process
    db 0              ;end of table
    dd no_match       ;no-match process

 OUTPUT
    eax = process pointer
 NOTES
   source file: key_decode1.asm
   see also crt_open, mouse_enable

-----------------------------------------------------------------------
761 terminfo_key_decode2 - decode key strings and get process
-----------------------------------------------------------------------
 INPUTS
    edx = ptr to input buffer with key strings (zero terminated)
    esi = decode table with key# and processes,

          The decode table must be preprocessed with
          terminfo_decode_setup  before it is used.

          First, the table must have padding for allow
          for expansion with string from terminfo.
          Usually  3*number_of_entries is enough

          Next, one byte is flag telling
          terminfo_decode_setup that this table is
          in decode2  format.  It must equal 2

          The body can have normal key definitons
          consisting of a key string, followed by
          a dword process address. If the key
          possibly appears in a terminfo file it
          can have a alternate format as follows:

            db -1        ;start of terminfo format
            dw x         ;terminfo index
            dd process   ;address of key handler
            db operator  ;-2=or -3=and following
            db (key string)
            dd process
                .
                .
            db -4        ;end of this terminfo format

     The decode table must be preprocessed with:
     terminfo_decode_setup.

   unprocessed decode table example
    times 3*4 db 0    ;padding for expansion of table
    db 2              ;flag for decode2 formatted table

    db -1             ;start terminfo definition
    dw 12             ;home key value for terminfo
    dd gs_home        ; home process
    db -2             ;(or) the following
    db 1bh,'[3',0     ;key string
    dd gs_home        ;process
    db -4             ;end of this terminfo def
 
    db -1             ;lookup this key in terminfo
    dw 14             ;left arrow key code
    dd gs_left        ; left arrow process
    db -4             ;no and/or defs

    db 7fh,0          ; backspace
    dd gs_backspace   ; backspace process
    db 0              ;end of table

     After processing by terminfo_decode_setup, the table
     will appear as follows:

    db 1bh,5bh,48h,0  ; pad_home
    dd gs_home        ; home process 
    db 1bh,5bh,44h,0  ; pad_left
    dd gs_left        ; left arrow process
    db 7fh,0          ; backspace
    dd gs_backspace   ; backspace process
    db 0              ;end of table

 OUTPUT
    eax = process pointer or zero if no match
 NOTES
   source file: terminfo_key_decode2.asm
   see also crt_open, mouse_enable

-----------------------------------------------------------------------
762 terminfo_read - search for terminfo and read into memory
-----------------------------------------------------------------------
 INPUTS
     the routine env_stack must be executed before.
     eax = work buffer ptr of size 4096
 OUTPUT
     eax = 0 if success
     The following globals are available if success
      [terminfo_flags] - ptr to flags, see terminfo_get_flag
      [terminfo_numbers] - ptr to values, see terminfo_get_numbers
      [terminfo_str_index] - ptr to index, see terminfo_get_strings
      [terminfo_strings] - ptr to top of string table, (terminfo_get_strings)
     The work buffer will contain terminfo if success
 NOTES
   source file: terminfo_read.asm
   see asmref terminfo entry for more information

-----------------------------------------------------------------------
763 timer_create - create posix timer
-----------------------------------------------------------------------
 INPUTS
     ebx = ptr to struc -> timer

    timer struc
    .type         resd 1  ;create - sets to zero for realtime timer
    .sigev_value  resd 1  ;create - passed to signal handler
    .sigev_signo  resd 1  ;create - signal # to generate
    .sigev_notify resd 1  ;create - 0 to create signal
    .sigev_compat resd 1  ;ignored
    .timer_id     resd 1  ;create - filled in with timer id
    .period_sec   resd 1  ;settime - active sec
    .period_nsec  resd 1  ;settime - active nsec
    .expire_sec   resd 1  ;settime - countdown sec
    .expire_nsec  resd 1  ;settime - countdown nsec
    .get_psec     resd 1  ;gettime - current state (doesn't change)
    .get_pnsec    resd 1  ;gettime - current state (doesn't change)
    .get_esec     resd 1  ;gettime - seconds (counting down)
    .get_ensec    resd 1  ;gettime - nsec (counting down)
    endstruc

    Set .type to zero for realtime timer, for other possible
      values see time.h.
    Set .sigev_value to anything code passed to signal handler
    Set .sigev_signo to signal number to generate when timer
      expires.
    Set .sigev_notify 0 for signal notification
    All other fields are ignored

 OUTPUT
    eax = return code, 0=success, else neg. system error
    ebx = ptr to struc (timer)
 NOTES
    file: timer_create.asm

-----------------------------------------------------------------------
764 timer_delete - delete posix timer
-----------------------------------------------------------------------
 INPUTS
     ebx = ptr to struc -> timer

    timer struc
    .type         resd 1  ;create - sets to zero for realtime timer
    .sigev_value  resd 1  ;create - passed to signal handler
    .sigev_signo  resd 1  ;create - signal # to generate
    .sigev_notify resd 1  ;create - 0 to create signal
    .sigev_compat resd 1  ;ignored
    .timer_id     resd 1  ;create - filled in with timer id
    .period_sec   resd 1  ;settime - active sec
    .period_nsec  resd 1  ;settime - active nsec
    .expire_sec   resd 1  ;settime - countdown sec
    .expire_nsec  resd 1  ;settime - countdown nsec
    .get_psec     resd 1  ;gettime - current state (doesn't change)
    .get_pnsec    resd 1  ;gettime - current state (doesn't change)
    .get_esec     resd 1  ;gettime - seconds (counting down)
    .get_ensec    resd 1  ;gettime - nsec (counting down)
    endstruc

 OUTPUT
    eax = return code, 0=success, else neg. system error
    ebx = ptr to struc (timer)
 NOTES
    file: timer_delete.asm

-----------------------------------------------------------------------
765 timer_getoverrun - get timer overrun count
-----------------------------------------------------------------------
 INPUTS
     ebx = ptr to struc -> timer

    timer struc
    .type         resd 1  ;create - sets to zero for realtime timer
    .sigev_value  resd 1  ;create - passed to signal handler
    .sigev_signo  resd 1  ;create - signal # to generate
    .sigev_notify resd 1  ;create - 0 to create signal
    .sigev_compat resd 1  ;ignored
    .timer_id     resd 1  ;create - filled in with timer id
    .period_sec   resd 1  ;settime - active sec
    .period_nsec  resd 1  ;settime - active nsec
    .expire_sec   resd 1  ;settime - countdown sec
    .expire_nsec  resd 1  ;settime - countdown nsec
    .get_psec     resd 1  ;gettime - current state (doesn't change)
    .get_pnsec    resd 1  ;gettime - current state (doesn't change)
    .get_esec     resd 1  ;gettime - seconds (counting down)
    .get_ensec    resd 1  ;gettime - nsec (counting down)
    endstruc


 OUTPUT
    eax = overrun count, else neg. system error
    ebx = ptr to struc (timer)
 NOTES
    file: timer_getoverrun.asm

-----------------------------------------------------------------------
766 timer_gettime - get timer state
-----------------------------------------------------------------------
 INPUTS
     ebx = ptr to struc -> timer

    timer struc
    .type         resd 1  ;create - sets to zero for realtime timer
    .sigev_value  resd 1  ;create - passed to signal handler
    .sigev_signo  resd 1  ;create - signal # to generate
    .sigev_notify resd 1  ;create - 0 to create signal
    .sigev_compat resd 1  ;ignored
    .timer_id     resd 1  ;create - filled in with timer id
    .period_sec   resd 1  ;settime - active sec
    .period_nsec  resd 1  ;settime - active nsec
    .expire_sec   resd 1  ;settime - countdown sec
    .expire_nsec  resd 1  ;settime - countdown nsec
    .get_psec     resd 1  ;gettime - current state (doesn't change)
    .get_pnsec    resd 1  ;gettime - current state (doesn't change)
    .get_esec     resd 1  ;gettime - seconds (counting down)
    .get_ensec    resd 1  ;gettime - nsec (counting down)
    endstruc

    The .period_xxx and .expire_xxx fields will be
    filled in by this call

 OUTPUT
    eax = return code, 0=success, else neg. system error
    ebx = ptr to struc (timer)
 NOTES
    file: timer_settime.asm

-----------------------------------------------------------------------
767 timer_settime - arm a dynamic timer
-----------------------------------------------------------------------
 INPUTS
     ebx = ptr to struc -> timer

    timer struc
    .type         resd 1  ;create - sets to zero for realtime timer
    .sigev_value  resd 1  ;create - passed to signal handler
    .sigev_signo  resd 1  ;create - signal # to generate
    .sigev_notify resd 1  ;create - 0 to create signal
    .sigev_compat resd 1  ;ignored
    .timer_id     resd 1  ;create - filled in with timer id
    .period_sec   resd 1  ;settime - active sec
    .period_nsec  resd 1  ;settime - active nsec
    .expire_sec   resd 1  ;settime - countdown sec
    .expire_nsec  resd 1  ;settime - countdown nsec
    .get_psec     resd 1  ;gettime - current state (doesn't change)
    .get_pnsec    resd 1  ;gettime - current state (doesn't change)
    .get_esec     resd 1  ;gettime - seconds (counting down)
    .get_ensec    resd 1  ;gettime - nsec (counting down)
    endstruc

    Set the .period_xxx and .expire_xxx fields.
    The period is time till expire, and the expire is
    current count down setting.  Values are relative
    to current time.

 OUTPUT
    eax = return code, 0=success, else neg. system error
    ebx = ptr to struc (timer)
 NOTES
    file: timer_settime.asm

-----------------------------------------------------------------------
768 dis_one - disassemble one instruction
-----------------------------------------------------------------------
 INPUTS    ebp = ptr to instruction data
           eax = instruction address (address at execution time)
           [symbol_process] - global variable which can be set if
                 a symbol table process is available to insert
                 address labels into disassembly string.
                 When [symbol_process] is non-zero it is called
                 mov  eax,[symbol_process]
                 mov  edi,(memory address)
                 call  eax
                 ;return eax=0 if symbol found and esi points at str
                 ;see hash functions for symbol table handler                   
 OUTPUT    eax = ptr to dis_block with disassembly results
                 [dis_block] - global dis_block location

     dis_block:   ;block of data returned to caller 
     warn_flag resb 1
        ;bit 01h = warning, nasm can not generate this opcode
        ;bit 02h = warning seg override found?
        ;bit 08h = warning unusual instruction, retn, push ax,

     error_flag resb 1
        ;bit  01h = illegal instruction 
        ;bit  02h = instruction size wrong
        ;bit  04h = unknown program state      
        ;bit  08h = unexpected prefix

     instruction_type resb 1
        ;bit 00h - normal instruction
        ;bit 01h - floating point
        ;bit 02h - conditional jmp
        ;bit 04h - proteced mode (system) instruction
        ;bit 08h - non-conditonal jmp (ret,call,jmp)

     operand_type  resb 1
        ;bit 01h - jmp adr at operand
        ;bit 02h - call adr at operand
        ;bit 04h - read/write byte adr at operand
        ;bit 08h - read/write word adr at operand
        ;bit 10h - read/write dword adr at operand
        ;bit 20h - probable adr in immediate (const) data operand

     operand  resd 1  ;address (physical) for
                              jmp,read,write, or operand if actions=0
     inst_length     resd 1  ;length of instruction, including
                              prefixs 66h,67h,f2h,f3h, but not lock.
                              segment prefixs set warning flag and
                              are included on some instructions.
 prefix flags

     state_flag:  resb  1
        ;0= instruction decoded ok,return info.
        ;40=escape prefix found, continue
        ;20=seg prefix found, continue
        ;10=66h opsize found, continue
        ;08=67h address  size, continue
        ;04=f2h  repne prefix found
        ;02=f3h rep prefix found

     the prefix flag is set by non-prefix opcodes and signals
     the end of decode.  It contains legal prefix's for this opcode.

     prefix_flag: resb 1
        ;80=found non-prefix opcode, decode done 
        ;40=escape prefix legal for opcode
        ;20=xx seg prefix legal for opcode
        ;10=66h opsize prefix legal for opcode
        ;08=67h address prefix legal for opcode
        ;04=f3h rep legal for this opcode
        ;02=f2h  repne legal for this opcode

     instruction data begins with a tab and is stored on
     one line.  It may include prefix  "rep" at
     front.  If an unknown instruction is found, it is
     returned as a "db  xx" and the appropiate error flag
     is set.
     
      inst_end resd 1   ;ptr end of data in instruction_asciiz
      inst     resb 140 ;ascii instruction build area


 NOTES:  Source file is dis.asm

-----------------------------------------------------------------------
769 trace_attach - attach to a running process
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
 OUTPUT  see trace_wait output

 NOTES
    "trace_attach" attaches to a running process.  The
    attached process is sent a SIGSTOP and we wait
    till the child to stops before returning.
    Another way to attach a process is to use the
    "traceme" function.
    Source file is: trace.inc

-----------------------------------------------------------------------
770 trace_continue - restart a stopped process or send signal
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         esi = 0 - normal restart of child
               n - signal to be sent to child
                   This signal is returned by wait4
                   instead of the SIGCHLD
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)

 NOTES
    "trace_continue" continue executing a process
    by either restarting it or sending it a signal
    Source file is: trace.inc

-----------------------------------------------------------------------
771 trace_detach - detach from a process
-----------------------------------------------------------------------
 INPUTS  
         [trace_pid] global variable set to child pid
                     before calling this function.
 OUTPUT  eax = 0 if success
               flags set for jz (success)
                             js (error)
 NOTES
    "trace_detach" restarts the stopped process after
    undoing the actions of either "attach" or "traceme".
    Source file is: trace.inc

-----------------------------------------------------------------------
772 trace_fregsget - get registers of traced process
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         esi = pointer to register storeage area
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
   if success ecx points to register structure as follows:
   user_i387_struct struc
    .cwd resd 1 ;control word
    .swd resd 1 ;status word
    .twd resd 1 ;tag word
    .fip resd 1 ;instruction offset
    .fcs resd 1 ;selector,opcode 
    .foo resd 1 ;data offset
    .fos resd 1 ;data selector
    .fd0 rest 1 ;80bit register
    .fd1 rest 1 ;80bit register
    .fd2 rest 1
    .fd3 rest 1
    .fd4 rest 1
    .fd5 rest 1
    .fd6 rest 1
    .fd7 rest 1
   endstruc

 NOTES
    "trace_fregsget" copies the traced process registers
    to buffer pointed at by -esi-

-----------------------------------------------------------------------
773 trace_fregsset - set registers of traced process
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         esi = pointer to register storeage area
   struct user_i387_struct
    .cwd resd 1 ;control word
    .swd resd 1 ;status word
    .twd resd 1 ;tag word
    .fip resd 1 ;instruction offset
    .fcs resd 1 ;selector,opcode 
    .foo resd 1 ;data offset
    .fos resd 1 ;data selector
    .fd0 rest 1 ;80bit register
    .fd1 rest 1 ;80bit register
    .fd2 rest 1
    .fd3 rest 1
    .fd4 rest 1
    .fd5 rest 1
    .fd6 rest 1
    .fd7 rest 1
   endstruc
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)

 NOTES
    "trace_fregsset" copies the data to traced process
    registers.

-----------------------------------------------------------------------
774 trace_fxregsget - get registers of traced process
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         esi = pointer to register storeage area
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
   if success ecx points to register structure as follows:

       struc fxsr
        .cwd	resw 1; control word
        .swd	resw 1; status word
        .twd	resw 1; tag word
        .fop	resw 1;
        .fip	resd 1;
        .fcs	resd 1;
        .foo	resd 1;
        .fos	resd 1;
        .mxcsr	resd 1;
        .reserved resw 2 ;
        .fd0	resb 16 ;floating reg
        .fd1	resb 16
        .fd2	resb 16
        .fd3	resb 16
        .fd4	resb 16
        .fd5	resb 16
        .fd6	resb 16
        .fd7	resb 16
        .xmm0	resb 16 ;XMM reg
        .xmm1	resb 16
        .xmm2	resb 16
        .xmm3	resb 16
        .xmm4	resb 16
        .xmm5	resb 16
        .xmm6	resb 16
        .xmm7	resb 16
        .padding resd 56;
       endstruc

 NOTES
    "trace_fxregsget" copies the traced process registers
    to buffer pointed at by -esi-

-----------------------------------------------------------------------
775 trace_fxregsset - set registers of traced process
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         esi = pointer to register storeage area
       struc fxsr
        .cwd	resw 1; control word
        .swd	resw 1; status word
        .twd	resw 1; tag word
        .fop	resw 1;
        .fip	resd 1;
        .fcs	resd 1;
        .foo	resd 1;
        .fos	resd 1;
        .mxcsr	resd 1;
        .reserved resw 2 ;
        .fd0	resb 16 ;floating reg
        .fd1	resb 16
        .fd2	resb 16
        .fd3	resb 16
        .fd4	resb 16
        .fd5	resb 16
        .fd6	resb 16
        .fd7	resb 16
        .xmm0	resb 16 ;XMM reg
        .xmm1	resb 16
        .xmm2	resb 16
        .xmm3	resb 16
        .xmm4	resb 16
        .xmm5	resb 16
        .xmm6	resb 16
        .xmm7	resb 16
        .padding resd 56;
       endstruc
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)

 NOTES
    "trace_fxregsset" copies the data to traced process
    registers.

-----------------------------------------------------------------------
776 trace_kill - kill a process being traced
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
               
 OUTPUT  eax = 0 if success
               flags set for jz (sucess)
                             js (error)

 NOTES
    "trace_kill" sends a SIGKILL to the traced
    process.

-----------------------------------------------------------------------
777 trace_peek - get data from traced process memory
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         edx = address within target process
         esi = pointer to storage dword
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
 NOTES
    "trace_peek" copies data from the traced process
    to our buffer.

-----------------------------------------------------------------------
778 trace_peek_bytes - get string from traced process memory
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         edx = address within target process
         esi = pointer to storage dword
         edi = number of bytes to read
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
 NOTES
    "trace_peek" copies data from the traced process
    to our buffer.

-----------------------------------------------------------------------
779 trace_poke - store data into traced process menory
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         edx = address within target process
         esi = data to stuff           
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
 NOTES
    "trace_poke" copies data from our buffer to
    traced process

-----------------------------------------------------------------------
780 trace_poke_bytes - store string into traced process
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         edx = address within target process
         esi = pointer to stuff data
         edi = count of bytes to store
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
 NOTES
    "trace_poke" copies data from our buffer to
    traced process

-----------------------------------------------------------------------
781 trace_regsget - get registers of traced process
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         esi = pointer to register storeage area
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
   if success ecx points to register structure as follows:
   struc regs
     .r_ebx resd 1
     .r_ecx resd 1
     .r_edx resd 1
     .r_esi resd 1
     .r_edi resd 1
     .r_ebp resd 1
     .r_eax resd 1
     .r_ds  resd 1
     .r_es  resd 1
     .r_fs  resd 1
     .r_gs  resd 1
     .r_old_eax resd 1
     .r_eip resd 1
     .r_cs  resd 1
     .r_flags resd 1
     .r_esp resd 1
     .r_ss  resd 1
   endstruc

 NOTES
    "trace_regsget" copies the traced process registers
    to buffer pointed at by -esi-

-----------------------------------------------------------------------
782 trace_regsset - set registers of traced process
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         esi = pointer to register storeage area
   struc regs
     .r_ebx resd 1
     .r_ecx resd 1
     .r_edx resd 1
     .r_esi resd 1
     .r_edi resd 1
     .r_ebp resd 1
     .r_eax resd 1
     .r_ds  resd 1
     .r_es  resd 1
     .r_fs  resd 1
     .r_gs  resd 1
     .r_old_eax resd 1
     .r_eip resd 1
     .r_cs  resd 1
     .r_flags resd 1
     .r_esp resd 1
     .r_ss  resd 1
   endstruc
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)

 NOTES
    "trace_regsset" copies the data to traced process
    registers.

-----------------------------------------------------------------------
783 trace_step - continue execution for one instruction
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         esi = optional signal number to send child
                   This signal is returned by wait4
                   instead of the SIGCHLD
               
 OUTPUT  eax = 0 if success
               flags set for jz (success)
                             js (error)
 NOTES
    "trace_step" restarts the stopped process
    and stops after next instruction.  Signals
    will also stop execution.  Process will appear to
    be stopped by SIGCHLD signal.

-----------------------------------------------------------------------
784 trace_syscall - continue execution till system call
-----------------------------------------------------------------------
 INPUTS
         [trace_pid] global variable set to child pid
                     before calling this function.
         esi = signal for child or zero
               This signal is sent to traced
               process
               
 OUTPUT  eax = 0 if success
               flags set for jz (success)
                             js (error)
 NOTES
    "trace_syscall" restarts the stopped process
    and stops at next syscall entry or exit.  Signals
    will also stop execution.  Process will appear to
    be stopped by SIGTRAP signal.
    Normally, we would wait for target process to
    stop by doing a wait4 syscall next.

-----------------------------------------------------------------------
785 trace_upeek - get data from kernel(user) memory
-----------------------------------------------------------------------
 INPUTS
         [child_pid] global variable set to child pid
                     before calling this function.
         edx = address index (see below)
         esi = pointer to storage dword
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
 NOTES
    "trace_upeek" copies data from kernel memory
    to our buffer.

    The user area data format is from kernel file user.h
    WARNING - the kernel may change this structure and the
    file user.h needs to be monitored for changes.
    WARNING - only index values 000h-040h appear to be
    correct in kernel 2.6.12 ?
    
      index  contents
      -----  ----------------------------
       000h   ebx
       004h   ecx
       008h   edx
       00ch   esi
       010h   edi
       014h   ebp
       018h   eax
       01ch   ds
       020h   es
       024h   fs
       028h   gs
       02ch   orig_eax
       030h   eip
       034h   cs
       038h   eflags
       03ch   esp
       040h   ss
       044h   u_fpvalid -floating point state flag, not implemented
                floating point registers struc follows
       048h   cwd
       04ch   swd
       050h   twd
       054h   fip
       058h   fcs
       05ch   foo
       060h   fos
       064h - 0B3  filler
       0B4h   u_tsize  text segment size
       0B8h   u_dsize  data segment size
       0BCh   u_ssize  stack segment size
       0C0h   start_code starting adr
       0C4h   start_stack starting address (top)
       0C8h   signal signal that caused core dump
       0CCh   reserved
               struct user_regs_struct*	u_ar0;
       0D0h   ebx
       0D4h   ecx
       0D8h   edx
       0Dch   esi
       0E0h   edi
       0E4h   ebp
       0E8h   eax
       0Ech   ds
       0F0h   es
       0F4h   fs
       0F8h   gs
       0Fch   orig_eax
       100h   eip
       104h   cs
       108h   eflags
       10ch   esp
       110h   ss
             struct user_fpregs_struct*	u_fpstate;
       114h   cwd
       118h   swd
       11ch   twd
       120h   fip
       124h   fcs
       128h   foo
       12ch   fos
       130h - 17fh filler
       
       180h   magic
       184h   u_comm [32]
       1a4h   u_debugreg [8];

    Source file: trace_user.inc

-----------------------------------------------------------------------
786 trace_upeek_bytes - get string from kernel memory
-----------------------------------------------------------------------
 INPUTS
         [child_pid] global variable set to child pid
                     before calling this function.
         edx = address index within kernel
         esi = pointer to storage dword
         edi = number of bytes to read
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
 NOTES
    "trace_upeek" copies data from kernel memory
    to our buffer.
    Source file: trace_user.inc

-----------------------------------------------------------------------
787 trace_upoke - store data into kernel menory
-----------------------------------------------------------------------
 INPUTS
         [child_pid] global variable set to child pid
                     before calling this function.
         edx = address index with kernel memory
         esi = data to stuff           
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
 NOTES
    "trace_upoke" copies data from our buffer to
    kernel memory.  
    WARNING - not all areas of kernel memory can
    be written.
    Source file: trace_user.inc

-----------------------------------------------------------------------
788 trace_upoke_bytes - store string into kernel memory
-----------------------------------------------------------------------
 INPUTS
         [child_pid] global variable set to child pid
                     before calling this function.
         edx = address index with kernel memory
         esi = pointer to stuff data
         edi = count of bytes to store
               
 OUTPUT  eax = 0 if success
         flags set for jz (success)
                       js (error)
 NOTES
    "trace_upoke" copies data from our buffer to
    kernel memory.
    WARNING not all areas of kernel memory an
    be written.
    Source file: trace_user.inc

-----------------------------------------------------------------------
789 trace_wait - wait for any child to stop
-----------------------------------------------------------------------
 INPUTS   [trace_pid] is set by parent
          this is a global variable
 OUTPUT
         [trace_pid] global variable set to child pid
                     before calling this function.

         if eax negative then error, else ebx is:
         ebx = child status if eax = child pid
            bl=status (7fh)-normal trace stop
                      (00) -exception code in status
            bh=signal if status non zero else exception
                      signal was not caught


    The format of status in ebx if eax positive:

    byte 1                   byte 2
    (bl in trace_wait call)  (bh in trace_wait call)
    -----------------------  -----------------------
    0   =process exited      kernel exit call reg "bl"
    1-7e=process killed      signal# that killed process
    7f  =process stopped     signal# that stopped process
    ff  =process continued   singal# that continued process

         examples:  ebx=0200 exception signal occured
                    ebx=0b7f illegal segment register set by code
                    ebx=087f divide by zero
                    ebx=0037 unknown signal 37h sent by ptrace_step
                    ebx=normal if int3 is encountered and no handler
                               has been setup.
                         
 NOTES
    Any signal to child will stop at trace_wait before delivery.
    To send the signal to child see: trace_step,trace_cont, or
    trace_syscall.
    Source file: trace.asm

-----------------------------------------------------------------------
790 traceme - enable trace for this process
-----------------------------------------------------------------------
 INPUTS  none
 OUTPUT  none

 NOTES
    "traceme" tells the kernel that this process is to be
    traced by its parent.  Any signal (except SIGKILL)
    delivered to this process will cause it to stop and
    the parent notified via wait.  All exec calls will
    notify the parent with a SIGCHLD signal.
    Another way to initiate trace is for another process
    to call the "trace_attach" function.
    A typical sequence is:
        mov	eax,20
        int	80h			;get our pid
        mov	[parent_pid],eax
        mov	eax,2
        int	80h			;fork
        mov	[trace_pid],eax
        or	eax,eax
        jnz	parent
        -----  child process  -----------------
        call	traceme
        mov	esi,executable_filename
        call	sys_run_die
        ------ parent process --------------
     parent:
        call	trace_wait		;wait till child stopped

    Source file is: trace.inc

-----------------------------------------------------------------------
791 rowcol_to_image - compute location in screen buffer
-----------------------------------------------------------------------
 INPUT
   bh = row     1+
   bl = colulmn 1+
 OUTPUT
   ebp = ptr to screen buffer
     ;the screen buffer contains:
                  (word) bit 15 = color/data changed flag
                  14-8 = color code
                  7-0  = char
     if accessed as bytes, data1,color1,data2,color2

 NOTE
   source file: vt_rowcol.asm

-----------------------------------------------------------------------
792 vt_clear - clear screen buffer
-----------------------------------------------------------------------
 INPUT
   [default_color] - set by vt_setup
 OUTPUT
   
 NOTE
   clear only sets display buffer, the function
   vt_flush must be called to update display

-----------------------------------------------------------------------
793 vt_close - close open vt display
-----------------------------------------------------------------------
 INPUTS
   none
 OUTPUT
   none
 NOTES
    source file: vt_setup.asm


-----------------------------------------------------------------------
794 vt_flush - write screen buffer to display
-----------------------------------------------------------------------
 INPUT
   none
 OUTPUT
   all image data not on screen is displayed.
 NOTE
   source file = vt_flush.asm

-----------------------------------------------------------------------
795 vt_in - feed input data to vt
-----------------------------------------------------------------------
 INPUT
   ecx = ptr to input data
   edx = length of input data
 OUTPUT
   
 NOTE
   Normally we read data from stdin and feed our
   vt world by using vt_in.  It is also possible
   to feed arbatrary commands to vt programs.

-----------------------------------------------------------------------
796 vt_out - send text to vt display
-----------------------------------------------------------------------
 INPUT
        ecx = ptr to string
        edx = lenght of string
        [vt_image] - ptr to top of screen image
        [color_image_ptr] - top color table
        [vt_image_write_color]        
        [vt_rows] - dword
        [vt_columns] - dword
        [ptty_fd] dword - used to send reports

 OUTPUT
         edx = number of char's unprocessed
         ecx = next char or end ptr
   
 NOTE
   Normally we read data from ptty_fd and feed
   the display by using vt_out.  It is also possible
   to feed arbatrary text to the display.

-----------------------------------------------------------------------
797 vt_set_all_writes - set write all on next flush
-----------------------------------------------------------------------
 INPUT
   none
 OUTPUT
   none
 NOTES
   source file: vt_set_all_writes.asm
   Normally vt_flush only sends changed data
   to the display, to resend all data, we need
   to modify the changed flag within vt_image.

-----------------------------------------------------------------------
798 vt_setup - setup for vt window
-----------------------------------------------------------------------
 INPUTS
   esi = input block pointer. The block
         is must be filled in by caller. It
         is copied to globals as follows:

         vt_rows: dd 0 ;rows in display
         vt_columns: dd 0 ;columns for display
         vt_image dd 0 ;ptr to buffer of size
                (window size) * 2 + 4
                buffer holds display image, each
                display char. is one word as follows
                   bit 15 = color/data changed flag
                   14-8 = color code
                   7-0  = char
         vt_fd: dd 0 set to 0 for /dev/tty, 1 for stdout
         vt_top_row: dd 0	;window starting row, 0+
         vt_top_left_col: dd 0	;window starting column, 0+
         default_color	    db grey_char + black_back
                  see dcache_colors.inc for color format.

 OUTPUT
   sign flag set for "js" if error
 NOTES
    source file: vt_setup.asm

    The vt funcitons keep a vt_image of display data and
    only update the display when vt_flush is called.

    Typically the vt functions are used as follows:
  call	env_stack
  call	read_window_size	;needed for vt_flush
  mov	esi,vt_setup_block      ;defines window
  call	vt_setup
  mov	eax,launch_name         ;program to run in window
  call	vt_ptty_setup           ;setup to run program
  call	vt_flush                ;clear window
  call	vt_ptty_launch          ;launch program in window
  (wait for input on stdin or ptty_fd)
  (send ptty_fd data to vt_out)
  (send stdin to ptty_fd)
  call	vt_flush
  (loop back to input for more data)
  (when done, call vt_close)


-----------------------------------------------------------------------
799 browse_dir - display and traverse directories
-----------------------------------------------------------------------

  The functions browse_dir_right and browse_dir_left call
  this function and provided a simplier calling sequence.

 INPUTS
    esi = pointer to the following structure

     struc  input
     .work_buf_ptr:       resd 1 ;memory allocation area, provided by
                                 brk kernel call
     .dircolor            resd 1 ;color of directories in list
     .linkcolor           resd 1 ;color of symlinks in list
     .selectcolor         resd 1 ;color of select bar
     .filecolor           resd 1 ;normal window color, and list color
     .win_location_row    resb 1 ;top row number for window
     .win_location_column resb 1 ;top left column number
     .win_rows:           resb 1 ;rows in window, includes outline if enabled
     .win_columns:        resb 1 ;number of columns, includes outline if enabled
     .box_flag            resb 1 ;0=no box 1=box
     .starting_path_ptr   resd 1 ;path to start browsing
     input_struc_size
     endstruc

     the following keys are recognized:
      right arrow - move into directory
      left arrow  - go back one directory
      up arrow    - move file select bar up
      down arrow  - move file select bar down
      pgup/pgdn   - move page up or down
      ESC         - exit without selecting
      enter       - exit and select file

    mouse clicks also select files
    colors = aaxxffbb  (aa-attribute ff-foreground  bb-background)
     30-black 31-red 32-green 33-brown 34-blue 35-purple 36-cyan 37-grey
    attributes 30-normal 31-bold 34-underscore 37-inverse

 OUTPUT
    eax = negative if error.  -1=escape typed.
          zero indicates success.
    ebx = ptr to full path if eax=0

 NOTES
   source file: browse_dir.asm


-----------------------------------------------------------------------
800 browse_dir_left - browse directories in left half of display
-----------------------------------------------------------------------

  The functions calls browse_dir and assumes defaults for most
  parameters.

 INPUTS
    esi = pointer to end of .bss section which will be used
          to allocate memory for buffers.

     the following keys are recognized:
      right arrow - move into directory
      left arrow  - go back one directory
      up arrow    - move file select bar up
      down arrow  - move file select bar down
      pgup/pgdn   - move page up or down
      ESC         - exit without selecting
      enter       - exit and select file

    mouse clicks also select files

 OUTPUT
    eax = negative if error.  -1=escape typed.
          zero indicates success.
    ebx = ptr to full path if eax=0

 NOTES
   source file: browse_dir_left.asm


-----------------------------------------------------------------------
801 browse_dir_right - browse directories in right half of display
-----------------------------------------------------------------------

  This function calls browse_dir and assumes defaults for most
  parameters.

 INPUTS
    esi = pointer to end of .bss section.  Will be used to allocate
          memory for work bufers.

     the following keys are recognized:
      right arrow - move into directory
      left arrow  - go back one directory
      up arrow    - move file select bar up
      down arrow  - move file select bar down
      pgup/pgdn   - move page up or down
      ESC         - exit without selecting
      enter       - exit and select file

    mouse clicks also select files
    colors = aaxxffbb  (aa-attribute ff-foreground  bb-background)
     30-black 31-red 32-green 33-brown 34-blue 35-purple 36-cyan 37-grey
    attributes 30-normal 31-bold 34-underscore 37-inverse

 OUTPUT
    eax = negative if error.  -1=escape typed.
          zero indicates success.
    ebx = ptr to full path if eax=0

 NOTES
   source file: browse_dir_right.asm


-----------------------------------------------------------------------
802 dir_browse - display and traverse directories
-----------------------------------------------------------------------

  (This function is being depreciated and may be
   removed, use browse_dir instead)

  The functions dir_browse_right and dir_browse_left call
  this function and provided a simplier calling sequence.

 INPUTS
    esi = pointer to the following structure

     struc  input
     .work_buf_ptr:        resd 1 ;pointer to work area size=100,000
                               buffer is used to read & sort directories
                               the large size is due to some /usr/share 
                               directory sizes, increase if program fails.
     .dircolor            resd 1 ;color of directories in list
     .linkcolor           resd 1 ;color of symlinks in list
     .selectcolor         resd 1 ;color of select bar
     .filecolor           resd 1 ;normal window color, and list color
     .win_location_row    resb 1 ;top row number for window
     .win_location_column resb 1 ;top left column number
     .win_rows:           resb 1 ;rows in window, includes outline if enabled
     .win_columns:        resb 1 ;number of columns, includes outline if enabled
     .box_flag            resb 1 ;0=no box 1=box
     .starting_path_ptr   resd 1 ;path to start browsing
     input_struc_size
     endstruc

     the following keys are recognized:
      right arrow - move into directory
      left arrow  - go back one directory
      up arrow    - move file select bar up
      down arrow  - move file select bar down
      pgup/pgdn   - move page up or down
      ESC         - exit without selecting
      enter       - exit and select file

    mouse clicks also select files
    colors = aaxxffbb  (aa-attribute ff-foreground  bb-background)
     30-black 31-red 32-green 33-brown 34-blue 35-purple 36-cyan 37-grey
    attributes 30-normal 31-bold 34-underscore 37-inverse

 OUTPUT
    eax = negative if error.  -1=escape typed.
          zero indicates success.
    ebx = ptr to full path if eax=0

 NOTES
   source file: dir_browse.asm


-----------------------------------------------------------------------
803 dir_browse_left - browse directories in left half of display
-----------------------------------------------------------------------

  (This function is being depreciated and may be removed, use
   browse_dir_left instead)

  The functions calls dir_browse and assumes defaults for most
  parameters.

 INPUTS
    esi = pointer to work area of size 200,000 or greater.

     the following keys are recognized:
      right arrow - move into directory
      left arrow  - go back one directory
      up arrow    - move file select bar up
      down arrow  - move file select bar down
      pgup/pgdn   - move page up or down
      ESC         - exit without selecting
      enter       - exit and select file

    mouse clicks also select files

 OUTPUT
    eax = negative if error.  -1=escape typed.
          zero indicates success.
    ebx = ptr to full path if eax=0

 NOTES
   source file: dir_browse_left.asm


-----------------------------------------------------------------------
804 dir_browse_right - browse directories in right half of display
-----------------------------------------------------------------------

  (This function is being depreciated, and may be removed, use
   browse_dir_right instead)

  This function calls dir_browse and assumes defaults for most
  parameters.

 INPUTS
    esi = pointer to work area of size 200,000 or greater.

     the following keys are recognized:
      right arrow - move into directory
      left arrow  - go back one directory
      up arrow    - move file select bar up
      down arrow  - move file select bar down
      pgup/pgdn   - move page up or down
      ESC         - exit without selecting
      enter       - exit and select file

    mouse clicks also select files
    colors = aaxxffbb  (aa-attribute ff-foreground  bb-background)
     30-black 31-red 32-green 33-brown 34-blue 35-purple 36-cyan 37-grey
    attributes 30-normal 31-bold 34-underscore 37-inverse

 OUTPUT
    eax = negative if error.  -1=escape typed.
          zero indicates success.
    ebx = ptr to full path if eax=0

 NOTES
   source file: dir_browse_right.asm


-----------------------------------------------------------------------
805 edit_file_in_box - edit small file inside box
-----------------------------------------------------------------------
 INPUTS
    ebx = ptr to full path of file or local file
    ecx = buffer size needed for file
    esi = pointer to structure below
      dd window color (see notes)
      dd data pointer. (set by edit_file_in_box )
      dd end of data ptr, beyond last display char.
         (end of data is set by edit_file_in_box )
      dd initial scroll left/right position
      db columns inside box
      db rows inside box
      db starting row (upper left corner row)
      db starting column (upper left corner column)
      dd outline box color (see notes)
         (set to zero to disable outline)
    lib_buf is used to build display lines
    keyboard is assumed to be in "raw" mode, see: crt_open
     
    example: 
        call	crt_open
        mov	ebx,filename
        mov	ecx,1024	;file buffer size
        mov	esi,boxplus     ;parameter block
        call	edit_file_in_box
        call	crt_close
        mov	eax,1
        int	80h
      
        [section .data]
      filename: db 'local_file',0
      
      boxplus:
      	dd	30003436h	;window color
      	dd	0		;filled in
      	dd	0		;filled in
      	dd	0		;scroll
      	db	50		;columns
      	db	10		;rows
      	db	3		;starting row
      	db	3		;starting column
      	dd	30003131h	;color for outline box
      
 OUTPUT
   eax = negative system error# or positive if success
 NOTES
    source file edit_text_in_box.asm
    -
    usage: keys are up,down,right,left,enter
    -      The tab,pgup,pgdn keys are ignored
    -      All other keys pop up a menu
    -
    The current window width is not checked, edit_text_in_box
    will attempth display even if window size too small.
    -
    Tabs are not handled and should not be used.
    - 
    color = aaxxffbb aa-attr ff-foreground  bb-background
    30-blk 31-red 32-grn 33-brn 34-blu 35-purple 36-cyan 37-gry
    attributes 30-normal 31-bold 34-underscore 37-inverse

-----------------------------------------------------------------------
806 edit_text_in_box - edit supplied string in a box
-----------------------------------------------------------------------
 INPUTS
    ecx = buffer end ptr
    esi = pointer to structure below
    - dd window color (see notes)
    - dd data pointer. ptr to start of string
    - dd end of data ptr, beyond last display char.
    -    (a nl will be stored here by edit_text_in_box)
    - dd initial scroll left/right position
    - db columns inside box
    - db rows inside box
    - db starting row (upper left corner row)
    - db starting column (upper left corner column)
    - dd outline box color (see notes)
    -    (set to zero to disable outline)
    lib_buf is used to build display lines
    keyboard is assumed to be in "raw" mode, see: crt_open
    -
    example: 
    -   call	crt_open
    -   mov	ecx,buf_end	;file buffer size
    -   mov	esi,boxplus     ;parameter block
    -   call	edit_file_in_box
    -   call	crt_close
    -   mov	eax,1
    -   int	80h
    - 
    -   [section .data]
    - filename: db 'local_file',0
    - 
    - boxplus:
    - 	dd	30003436h	;window color
    - 	dd	box_msg		;edit data pointer
    - 	dd	box_msg_end	;end of edit data
    - 	dd	0		;scroll right/left (usually zero)
    - 	db	50		;columns
    - 	db	10		;rows
    - 	db	3		;starting row
    - 	db	3		;starting column
    - 	dd	30003131h	;color for outline box
    -
    - box_msg: db 'hi there im a box',0ah
    - box_msg_end: db 0ah
    -   db 0,0
    - buf_end:	db	0ah
    - 
 OUTPUT
   eax = negative system error# or positive if success
   ebx = end of data ptr
 NOTES
    source file edit_text_in_box.asm
    -
    usage: keys are up,down,right,left,enter
    -      The tab,pgup,pgdn keys are ignored
    -      All other keys pop up a menu
    -
    The current window width is not checked, edit_text_in_box
    will attempth display even if window size too small.
    -
    Tabs are not handled and should not be used.
    - 
    color = aaxxffbb aa-attr ff-foreground  bb-background
    30-blk 31-red 32-grn 33-brn 34-blu 35-purple 36-cyan 37-gry
    attributes 30-normal 31-bold 34-underscore 37-inverse

-----------------------------------------------------------------------
807 form - display and accept user inputs to fill form
-----------------------------------------------------------------------
 INPUTS
    esi = ptr to list of pointers:
     dd aux_process    ;user process, called after each display
     dd edit_color     ;colors, list of colors
     dd string_block1 	;strings, list of string fields on screen
     dd display_tbl    ;display table, screen format table
     
    A form uses one screen.  It is defined by normal ascii
    text with embedded control characters.  The control characters
    are:
     0 - end of table          5 - blank rest of screen
     1 - color normal          6 - string, block# follows
     2 - color field           7 - key, key# follows
     3 - color active field    8 - process, process# follows
     4 - color button          9 - end of line (eol)
     
     
    As the user types or moves the mouse to fill out the
    form, all data is stored in the form.  Upon exit the
    form can be scanned by caller to obtain the data.
     
    string data will be stored in the table as entered.
    button selection is indicated by color code.  When selected
    the code "3" will indicate this button was selected.
     
    table codes use negative byte values in secondary
    fields, thus, ascii characters in range of 80h+ are not available
    as text.
 OUTPUT
    eax = negative error# if problems
    eax = positive, a return code defined as:
          0 = unknown key press at kbuf
          1 = escape pressed
    see example form file form_samp.asm
 NOTES
   source file: form.asm
   see also string_form.asm for a simplier form.

-----------------------------------------------------------------------
808 form2_input - get string data for form
-----------------------------------------------------------------------
 INPUTS
    ebp = ptr to info block
          note: info block must be in writable
                data section.  Text data must
                also be writable.
          note: form2 input can continue
                by calling with same input block

          info block is defined as follows:

          struc in_block
           .iendrow resb 1 ;rows in window
           .iendcol resb 1 ;ending column
           .istart_row resb 1 ;starting row
           .istart_col resb 1 ;startng column
           .itext  resd 1 ;ptr to text
           .top_def  resd 1 ;top str def list
           .active_str_def resd 1 ;ptr to active entry on str def list
           .icolor1 resd 1 ;selected string color
           .icolor2 resd 1 ;str block color
           .icolor3 resd 1 ;other colors follow here
          endstruc

          the text pointed at by .itext has normal text and
          codes to indicate string or colors. negative byte
          values are used for strings and the values 1-6 are
          used for colors

          The cursor color is selected by shell, it uses
          the normal color and inverts. To set cursor color
          change the color for selected string (icolor1)

          Each string has a descriptive block, see str_def.

          The first string block is indicated by using code
          of -1. the next is -2, etc.
 
          struc str_def
           .type  resb 1  ;-x=string id 2=button 3=toggle
           .srow  resb 1 ;row
           .scol  resb 1 ;col
           .scur  resb 1 ;cursor column
           .scroll resb 1 ;scroll counter
           .wsize  resb 1 ;columns in string window
           .bsize  resd 1 ;size of buffer
           .buf    resd 1 ;ptr to buffer
          endstruc

         Other input data types (toggle,button) are also
         created and pointers put in the def-list
         They are defined as follows:

         struc in_def
         .type  resb 1 ;2=button 3=toggle
         .srow  resb 1 ;row
         .scol  resb 1 ;column
         .mod_col resb 1 ;toggle mod column
         .mod_char resb 1 ;character for "on"
         .wsize resb 1 ;size of item
         .mod_stuff resd 1 ;ptr to color#, +2=toggle char
         .process resd 1 ;process to handle this

 OUTPUT
    eax = negative (redisplay request)
        = 0 (unknown key in kbuf)
        = process to call
    kbuf = non recognized key

    The state of toggles can be extraced from form by checking
    at .mod_stuff

 NOTES
   source file: form2.asm
   see also string_form, and form.asm for a more complex form function.

-----------------------------------------------------------------------
809 form2_show - show form for input of data
-----------------------------------------------------------------------
 INPUTS
    ebp = ptr to info block
          note: info block must be in writable
                data section.  Text data must
                also be writable.
          note: string_form2 input can continue
                by calling with same input block

          info block is defined as follows:

          struc in_block
           .iendrow resb 1 ;rows in window
           .iendcol resb 1 ;ending column
           .istart_row resb 1 ;starting row
           .istart_col resb 1 ;startng column
           .itext  resd 1 ;ptr to text
           .top_def  resd 1 ;top str def list
           .active_def resd 1 ;ptr to active entry on str def list
           .icolor1 resd 1 ;selected string color
           .icolor2 resd 1 ;str block color
           .icolor3 resd 1 ;other colors follow here
          endstruc

          the text pointed at by .itext has normal text and
          codes to indicate string or colors. negative byte
          values are used for strings and the values 1-6 are
          used for colors

          The cursor color is selected by shell, it uses
          the normal color and inverts. To set cursor color
          change the color for selected string (icolor1)

          Each string has a descriptive block, see str_def.

          The first string block is indicated by using code
          of -1. the next is -2, etc.
 
          struc str_def
           .type  resb 1  ;-x=string id 2=button 3=toggle
           .srow  resb 1 ;row
           .scol  resb 1 ;col
           .scur  resb 1 ;cursor column
           .scroll resb 1 ;scroll counter
           .wsize  resb 1 ;columns in string window
           .bsize  resd 1 ;size of buffer
           .buf    resd 1 ;ptr to buffer
          endstruc

         Other input data types (toggle,button) are also
         created and pointers put in the def-list
         They are defined as follows:

         struc in_def
         .type  resb 1 ;2=button 3=toggle
         .srow  resb 1 ;row
         .scol  resb 1 ;column
         .mod_col resb 1 ;toggle mod column
         .mod_char resb 1 ;character for "on"
         .wsize resb 1 ;size of item
         .mod_stuff resd 1 ;select color ptr, +2=toggle char stuff in msg
         .process resd 1 ;process to handle this

 OUTPUT
    kbuf = non recognized key
 NOTES
   source file: string_form2.asm
   see also string_form, and form.asm for a more complex form function.

-----------------------------------------------------------------------
810 make_box - display box outline
-----------------------------------------------------------------------
 INPUTS
    esi = pointer to structure below
      db columns inside box
      db rows inside box
      db starting row
      db starting column
      dd box color (see notes)
    lib_buf is used to build display lines
 OUTPUT
   eax = negative system error# or positive if success
 NOTES
    source file make_box.asm
    The current window width is not checked, make_box
    will attempth display even if window size too small.
      
    color = aaxxffbb aa-attr ff-foreground  bb-background
    30-blk 31-red 32-grn 33-brn 34-blu 35-purple 36-cyan 37-gry
    attributes 30-normal 31-bold 34-underscore 37-inverse

-----------------------------------------------------------------------
811 message_box - display message and wait for key press
-----------------------------------------------------------------------
 INPUTS
    esi = pointer to structure below
      dd window color (see notes)
      dd data pointer.
      dd end of data ptr, beyond last display char
      dd initial scroll left/right position
      db columns inside box
      db rows inside box
      db starting row
      db starting column
      dd outline box color (see notes)
         (set to zero to disable outline)
    lib_buf is used to build display lines
 OUTPUT
   eax = return state of lib function key_mouse1
   [kbuf] contains key press
 NOTES
    source file message_box.asm
    The current window width is not checked, message_box
    will attempth display even if window size too small.
      
    color = aaxxffbb aa-attr ff-foreground  bb-background
    30-blk 31-red 32-grn 33-brn 34-blu 35-purple 36-cyan 37-gry
    attributes 30-normal 31-bold 34-underscore 37-inverse

-----------------------------------------------------------------------
812 popup_menu - popup menu box and wait for key/click
-----------------------------------------------------------------------
 INPUTS
    ebp = ptr to popup menu definition, as follows:

        dd menu text ending with zero byte
        db columns in window
        db rows in window
        db starting col
        db starting row
        dd normal color (color 1)
        dd button color (color 2)
        dd select bar button color (color 3)

     menu text consists of lines ending with 0ah, the last
     line ends with 0.  Lines can have embedded color codes
     using byte values of 1,2,3.
     The box is separated from rest of display by its color,
     the "normal color" is used to form box"

 OUTPUT
    eax = zero if no selection was made
        = ptr to start of selected row
    ecx = selection number times 4, if selection made,
          first selection number is 0, next is 4, etc.

 NOTES
    file popup_menu.asm
    1. menu text can have one blank line at top.
    2. menu items can have blank lines between entries
    3. normal color is asserted at start of each new line
        

-----------------------------------------------------------------------
813 select_1up_list_centered - display select window in center, fit to data size
-----------------------------------------------------------------------

 This is a high level function that calls select_list_engine to
 display a selection window.  To keep the calling interface simple
 the colors and other  values will be assumed.

   INPUTS
   ------

      edi=ptr to top of work area.
          work area size =  20+(size of text strings)+ 10*(button count).
      esi=ptr to text strings

      Select_1up_list_centered needs a list of text strings to
      place in buttons and a work area to setup for select_list_engine.
      The work area must be writable.

      Text strings can be multi line (using 0ah) and
      the last line is terminated by  zero byte.
      The last text string needs to have another zero
      byte indicating no more string follow.


   OUTPUT
   ------

    eax = return code

          When selected, the buttons return a code
          describing its position.
          Positions are encoded in two bytes in eax
          as ah=group number,  al=row number.  These
          are not physical row and columns, they are
          button positions.  the frist button is 1,1.
          The button below it is 1,2.

                1,1             2,1

                1,2             2,2

          If a error is found eax will contain -1.

          ESC key press returns eax=0

   Since select_1up_list_right only has one group of buttons
   all return values will have ah=1 and al=the button number.

   The work area will be modified to suit the select_list_engine and
   must be writable.


-----------------------------------------------------------------------
814 select_1up_list_full - display selection list as full screen window
-----------------------------------------------------------------------

 This is a high level function that calls select_list_engine to
 display a selection window.  To keep the calling interface simple
 the colors and other  values will be assumed.

   INPUTS
   ------

      edi=ptr to top of work area.
          work area size =  20+(size of text strings)+ 10*(button count).
      esi=ptr to text strings

      Select_1up_list_full needs a list of text strings to
      place in buttons and a work area to setup for select_list_engine.

      Text strings can be multi line (using 0ah) and
      the last line is terminated by  zero byte.
      The last text string needs to have another zero
      byte indicating no more string follow.

   OUTPUT
   ------

    eax = return code

          When selected, the buttons return a code
          describing its position.
          Positions are encoded in two bytes in eax
          as ah=group number,  al=row number.  These
          are not physical row and columns, they are
          button positions.  the frist button is 1,1.
          The button below it is 1,2.

                1,1             2,1

                1,2             2,2

          If a error is found eax will contain -1.
          
          ESC key press returns eax=0

   Since select_1up_list_right only has one group of buttons
   all return values will have ah=1 and al=the button number.

   The work area will be modified to suit the select_list_engine and
   must be writable.


-----------------------------------------------------------------------
815 select_1up_list_left - display selection list on left half of screen
-----------------------------------------------------------------------

 This is a high level function that calls select_list_engine to
 display a selection window.  To keep the calling interface simple
 the colors and other  values will be assumed.

   INPUTS
   ------

      edi=ptr to top of work area.
          work area size =  20+(size of text strings)+ 10*(button count).
      esi=ptr to text strings

      Select_1up_list_left needs a list of text strings to
      place in buttons and a work area to setup for select_list_engine.

      Text strings can be multi line (using 0ah) and
      the last line is terminated by  zero byte.
      The last text string needs to have another zero
      byte indicating no more string follow.

   OUTPUT
   ------

    eax = return code

          When selected, the buttons return a code
          describing its position.
          Positions are encoded in two bytes in eax
          as ah=group number,  al=row number.  These
          are not physical row and columns, they are
          button positions.  the frist button is 1,1.
          The button below it is 1,2.

                1,1             2,1

                1,2             2,2

          If a error is found eax will contain -1.
         
          ESC key press will return eax=0

   Since select_1up_list_right only has one group of buttons
   all return values will have ah=1 and al=the button number.

   The work area will be modified to suit the select_list_engine and
   must be writable.


-----------------------------------------------------------------------
816 select_1up_list_right - display selection list on right half of screen
-----------------------------------------------------------------------

 This is a high level function that calls select_list_engine to
 display a selection window.  To keep the calling interface simple
 the colors and other  values will be assumed.

   INPUTS
   ------

      edi=ptr to top of work area.
          work area size =  20+(size of text strings)+ 10*(button count).
      esi=ptr to text strings

      Select_1up_list_right needs a list of text strings to
      place in buttons and a work area to setup for select_list_engine.

      Text strings can be multi line (using 0ah) and
      the last line is terminated by  zero byte.
      The last text string needs to have another zero
      byte indicating no more string follow.

   OUTPUT
   ------

    eax = return code

          When selected, the buttons return a code
          describing its position.
          Positions are encoded in two bytes in eax
          as ah=group number,  al=row number.  These
          are not physical row and columns, they are
          button positions.  the frist button is 1,1.
          The button below it is 1,2.

                1,1             2,1

                1,2             2,2

          If a error is found eax will contain -1.

          ESC key press returns eax=0

   Since select_1up_list_right only has one group of buttons
   all return values will have ah=1 and al=the button number.

   The work area will be modified to suit the select_list_engine and
   must be writable.

   source file: select_1up_right.asm

-----------------------------------------------------------------------
817 select_buffer_line - view a buffer and select line
-----------------------------------------------------------------------
 INPUTS
    esi = data block (see crt_window also)
        dd color list
        dd win top ptr (buffer)
        dd buffer end
        dd scroll
        db columns in window
        db rows in window
        db starting row
        db starting col
        dd select line ptr
        dd select ptr color

 OUTPUT
    eax = zero if no selection was made
        = ptr to start of selected row
 NOTES
    file select_buffer_line.asm

-----------------------------------------------------------------------
818 select_file_line - view a buffer and select line
-----------------------------------------------------------------------
 INPUTS
    esi = buffer pointer for file data
    ebx = filename ptr
    edx = buffer length
    ecx = ignore (scroll left) for file data
 OUTPUT
    eax = zero if no selection was made or error
        = ptr to start of selected row
 OPERATION
    The screen size is optained from kernel and used
    to display page of file data.  Keys and mouse data
    is used to scroll up/down the data and make a
    selection.
 NOTES
    file select_file_line.asm

-----------------------------------------------------------------------
819 select_list_engine - display a list and wait for selection
-----------------------------------------------------------------------

    usage: This function reqires some setup which can be  avoided
           by calling the functions:

           select_1up_list_full - 1 column of lists using full screen
           select_2up_list_full - 2 columns of lists using full screen
           select_1up_list_left - 1 column of lists using left half of screen
           select_2up_list_left - 2 columns of lists using left half of screen
           select_1up_list_right - 1 column of lists using right half of screen
           select_2up_list_right - w columns of lists using right half of screen

           The above functions use defaults for colors and other parameters.
           If finer control is needed then the select_list_engine must be
           used (setup is described in the following paragraphs).

           WARNING: This function isn't difficult to setup, but it will
                    crash if parameters are wrong or if input data can
                    not be modified as needed.  It is recomended that
                    this documentation be read carefully.

    introduction:
          The caller must set up a general table describing the
          selection list window and also descriptions of the
          individual buttons.  Defaults exist for many parameters
          and other parameters may be calculated on the fly.
          All this is described by the following tables.
        
   INPUTS
   ------

   ebp = ptr to the following struc

struc sl
.button_groups	resb	1	;number of groups (button columns) calculated from button defs
.buttons_per_column resb 1	;number of buttons in each column, calculated from button defs.
.win_columns	resb	1	;size of our select window (columns) 0=use default, see note 1
                                window sizes are for contents, a one character frame is added.
                                Default is full screen.  
.win_rows	resb	1	;size of our select window (rows) 0=use default, see note 1
                                Default size for win_rows is full screen.
.win_left_column resb	1	;win location, left column, 1+,  see note 2, 0=use default
                                Default for win_left_olullmn is 1, left column.
.win_top_row	resb	1	;win location, top row, 1+, see note 2 , 0=use default
                                Default for win_top_row is 1, top of screen.
.box_color	resd	1	;color of box, -1=no box 0=default (see color format below)
.win_color	resd	1	;color of select window, 0=default
.button_size_columns resb 1	;all buttons are same length, calculated from button defs,
                                the largest text string +2 is button length.
.button_size_rows    resb 1	;all buttons are same size, calculated from button defs,
                                the button with largest number of lines is size for all buttons.
                                Lines end with 0ah and last line ends with a zero byte.
.button_separation_columns   resb 1 ;number of rows between buttons, 0=default of 0
.button_separation_rows   resb 1 ;number of rows between buttons, 0=default of 0
endstruc

  note 1: the window size includes a one character boarder or edge.  Useful area = size -2
  note 2: the box location is given for data inside box, the boarder will expand box by 1

 button definitions follow next:
  all buttons in a column (group) must be defined together.  If two columns
  are used, the second column is defined after column 1, etc.

struc button
.button_group		resb 1	;1=button column #1
.button_color		resd 1	;button unselected color, 0=use defaullt
.button_selected_color  resd 1	;button selected color (if -1, can't select, 0=default)
.button_text		resb 1  ;variable length text goes here, multi line text has 0ah
   (text field ends with 0 and may be following by another button defination or another
    zero.  When two zeros are together it indicates the end of button definitions)
endstruc

   note: colors are defined as hex values in a dword as follows:
      color = aaxxffbb  (aa-attribute ff-foreground  bb-background)
        30-black 31-red 32-green 33-brown 34-blue 35-purple 36-cyan 37-grey
      attributes 30-normal 31-bold 34-underscore 37-inverse

   note: headers and descriptive entries can be created by using buttons
         that have same color as background and setting them no-select.

   note: If multiple columns of buttons are defined, all columns must have
         the same number of buttons.  Holes can be created by setting color
         to non-button state and setting button non-selectable, but the area
         must have a definition.

   OUTPUT
   ------

    eax = return code

          When selected, the buttons return a code
          describing its position.
          Positions are encoded in two bytes in eax
          as ah=group number,  al=row number.  These
          are not physical row and columns, they are
          button positions.  the frist button is 1,1.
          The button below it is 1,2.

                1,1             2,1

                1,2             2,2

          If a error is found eax will contain -1.

          ESC key press returns eax=0

   The input struc's and button definitons may be modified and defaults
   filled in.  If this input set is to be reused the values may need to
   be refreshed or adjusted.  WARNING, the input data area must be
   writable and not in a code segment.


-----------------------------------------------------------------------
820 select_list_setup - setup the select list database
-----------------------------------------------------------------------

 This function is called by select_list_engine to fill
 in defaults.  It is also called by high level routines
 to build structures and calcuate values.  It is mostly
 for library use, but may be useful.
        
   INPUTS
   ------

          ebp = pointer to button definition structures.

          Register -al- has code describing action needed.

           al=1  build structures from text lists in buffer.
              edi=ptr to top of work area followed by text strings.
                  work area must be 20+10*(button count) in size.
              esi=ptr to text strings at end of work area.

              note: text strings can be multi line (using 0ah) and
                    the last line is terminated by  zero byte.

           al=2  fill in defaults for button structures
              [ptr2group_ptrs] - has ptr to group ptrs
              [ptrs2button_defs] - has pointer to list of pointers
                                   for each button group
              also set [max_text] - longest button text line size
                       [max_rows] - max number of button text rows
                       [max_groups] - number of button groups (columns)
                       [mrows]  - max number of buttons in a group
                       [crt_rows] - screen size from kernel call
                       [crt_columns] - screen size from kernel call
              
           al=3  calculate button separation values from known
                 -win_columns,button_size_columns
                 -win_rows,button_size_rows
                 calcuated values will be stored in structure.
                 sl.button_separation_columns, sl.button_separation_rows

                 note: calculation is for single group window only.
    
           al=4  calculate win_rows, win_columns from button_sizes and
                 separation_sizes.  Calculated values may exceed the
                 screen size.
                 calcuated values are stored at: s.win_columns and
                 sl.win_rows

                 note: calculation is for single group window only.

   OUTPUT
   ------

           Input option al=1 returns ebp set to start of structures.

           Input option al=2 returns information set in global varialbes
           as follows:

              byte [crt_rows] - set by calling read_window_size
              byte [crt_columns] - set by calling read_window_size
              byte [max_text] - size of longest button text line
              byte [max_rows] - row count for button with most rows
              byte [max_groups] - number of button columns (groups)


-----------------------------------------------------------------------
821 show_box - display boxed message with optional boarder
-----------------------------------------------------------------------
 INPUTS
    esi = pointer to structure below
      dd window color (see notes)
      dd data pointer.
      dd end of data ptr, beyond last display char
      dd initial scroll left/right position
      db columns inside box
      db rows inside box
      db starting row
      db starting column
      dd outline box color (see notes)
         (set to zero to disable outline)
    lib_buf is used to build display lines
 OUTPUT
   eax = negative system error# or positive if success
 NOTES
    source file show_box.asm
    The current window width is not checked, show_box
    will attempth display even if window size too small.
      
    color = aaxxffbb aa-attr ff-foreground  bb-background
    30-blk 31-red 32-grn 33-brn 34-blu 35-purple 36-cyan 37-gry
    attributes 30-normal 31-bold 34-underscore 37-inverse

-----------------------------------------------------------------------
822 string_form - get string data for form
-----------------------------------------------------------------------
 INPUTS
    ebp = ptr to info block
          note: info block must be in writable
                data section.  Text data must
                also be writable.
          note: string_form input can continue
                by calling with same input block

          info block is defined as follows:

          struc in_block
           .iendrow resb 1 ;rows in window
           .iendcol resb 1 ;ending column
           .istart_row resb 1 ;starting row
           .istart_col resb 1 ;startng column
           .icursor resd 1 ;ptr to string block with active cursor
           .icolor1 resd 1 ;body color
           .icolor2 resd 1 ;highlight/string color
           .itext  resd 1 ;ptr to text
          endstruc

          the text pointed at by .itext has normal text and
          imbedded string using the following format:

          struc str_def
           .srow  resb 1 ;row
           .scol  resb 1 ;col
           .scur  resb 1 ;cursor column
           .scroll  resb 1 ;scroll counter
           .wsize  resb 1 ;columns in string window
           .bsize  resd 1 ;size of buffer, (max=127)
          endstruc

          the text can also have areas highlighted with .icolor2
          by enclosing them with "<" and ">".
 
 OUTPUT
    kbuf = non recognized key
 NOTES
   source file: string_form.asm
   see also form.asm for a more complex form function.

-----------------------------------------------------------------------
823 view_buffer - display,search,scroll text
-----------------------------------------------------------------------
 INPUTS
    eax = length of text buffer
    ebx = 0
    ecx = pointer to buffer
; OUTPUT
   none
 NOTES
    source file: view_file.asm

-----------------------------------------------------------------------
824 view_file - display,search,scroll text  file
-----------------------------------------------------------------------
 INPUTS
    ebx = pointer to file path (name)

    if ebx = 0 then the following is assumed

    eax = length of text buffer
    ebx = 0
    ecx = pointer to buffer
; OUTPUT
   none
 NOTES
    source file: view_file.asm

-----------------------------------------------------------------------
825 screen_size - report screen size in pixels
-----------------------------------------------------------------------
    In the console this function returns the complete screen
    In xterm it retruns the terminal size
    In xterm-clones it returns the console screen size
 INPUTS
    env_stack must be called at start of program
 OUTPUT:
    eax = screen pixel width
    ebx = screen pixel height
    note: if terminal does not provide
          data, eax,ebx will = 0
 NOTES
   source file: screen_size.asm

    see also: crt_type - returns $TERM usually as "linux" or "xterm"
              terminal_type - returns code for console,xterm,clone
              read_winsize_x - returns winsize struc
              read_term_info_x - returns termios and winsize struc
              read_window_size - returns text size for console,xterm,clone
              get_screen_size - returns pixels for xterm or framebuffer
              win_size - returns xterm pixels or zero if not xterm
              win_txt_size - returns text size for xterm or zero if other term

-----------------------------------------------------------------------
826 win_deiconify - return window to prevous size
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    none
 OUTPUT:
    none
    
 NOTES
   source file: win_deiconify.asm

-----------------------------------------------------------------------
827 win_font - set window font 3,4,5,6 sizes
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    eax = font number
 OUTPUT:
    none
 NOTES
   source file: win_font.asm
   Usually, only font #6 is readable.  This function is
   of limited use.  Use "xtern -fn 10x20" instead.

-----------------------------------------------------------------------
828 win_iconify - convert window to icon
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    none
 OUTPUT:
    none
    
 NOTES
   source file: win_iconify.asm

-----------------------------------------------------------------------
829 win_lines - resize window to x lines
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    eax = line count for window
 OUTPUT:
    none
 NOTES
   source file: win_lines.asm

-----------------------------------------------------------------------
830 win_lower - lower window to bottom of stack (behind other windows)
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    none
 OUTPUT:
    none
    
 NOTES
   source file: win_lower.asm

-----------------------------------------------------------------------
831 win_maximize - fill screen with window
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    none
 OUTPUT:
    none
    
 NOTES
   source file: win_maximize.asm

-----------------------------------------------------------------------
832 win_move - move window to pixel location
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    eax = pixel column (upper left corner)
    ebx = pixel row (upper left corner)
 OUTPUT:
    none
 NOTES
   source file: win_move.asm

-----------------------------------------------------------------------
833 win_posn - report window position in pixels
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    none
 OUTPUT:
    eax = pixel column (upper left corner)
    ebx = pixel row (upper left corner)
 NOTES
   source file: win_posn.asm

-----------------------------------------------------------------------
834 win_raise - raise window to top of stack (make visible)
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    none
 OUTPUT:
    none
    
 NOTES
   source file: win_raise.asm

-----------------------------------------------------------------------
835 win_refresh - redisplay screen
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    none
 OUTPUT:
    none
    
 NOTES
   source file: win_refresh.asm
   This function may be useful after reducing font size

-----------------------------------------------------------------------
836 win_resize - resize window to x,y pixels
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    eax = pixel height
    ebx = pixel width
 OUTPUT:
    none
 NOTES
   source file: win_resize.asm

-----------------------------------------------------------------------
837 win_restore - return window to prevous size
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    none
 OUTPUT:
    none
    
 NOTES
   source file: win_restore.asm

-----------------------------------------------------------------------
838 win_size - report window size excluding title
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    none
 OUTPUT:
    eax = window pixel height
    ebx = window pixel width
    
 NOTES
   source file: win_size.asm

    see also: crt_type - returns $TERM usually as "linux" or "xterm"
              terminal_type - returns code for console,xterm,clone
              read_winsize_x - returns winsize struc
              read_term_info_x - returns termios and winsize struc
              read_window_size - returns text size for console,xterm,clone
              get_screen_size - returns pixels for xterm or framebuffer
              win_size - returns xterm pixels or zero if not xterm
              win_txt_size - returns text size for xterm or zero if other term

-----------------------------------------------------------------------
839 win_title - set window title
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    eax = ptr to title string
 OUTPUT:
    none
 NOTES
   source file: win_title.asm

-----------------------------------------------------------------------
840 win_txt_resize - resize text area to rows/columns
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    eax = height in rows
    ebx = width in columns
 OUTPUT:
    none
 NOTES
   source file: win_txt_resize.asm

-----------------------------------------------------------------------
841 win_txt_size - report window size excluding titlebar
-----------------------------------------------------------------------
    warning: this may only work on xterm, not other terminals
 INPUTS
    none
 OUTPUT:
    eax = height in  characters
    ebx = width in characters
 NOTES
   source file: win_txt_size.asm

    see also: crt_type - returns $TERM usually as "linux" or "xterm"
              terminal_type - returns code for console,xterm,clone
              read_winsize_x - returns winsize struc
              read_term_info_x - returns termios and winsize struc
              read_window_size - returns text size for console,xterm,clone
              get_screen_size - returns pixels for xterm or framebuffer
              win_size - returns xterm pixels or zero if not xterm
              win_txt_size - returns text size for xterm or zero if other term
